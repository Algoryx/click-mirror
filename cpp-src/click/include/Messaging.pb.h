// Generated by the protocol buffer compiler.  DO NOT EDIT!
// NO CHECKED-IN PROTOBUF GENCODE
// source: Messaging.proto
// Protobuf C++ Version: 5.27.0

#ifndef GOOGLE_PROTOBUF_INCLUDED_Messaging_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_Messaging_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>
#include <utility>

#include "google/protobuf/runtime_version.h"
#if PROTOBUF_VERSION != 5027000
#error "Protobuf C++ gencode is built with an incompatible version of"
#error "Protobuf C++ headers/runtime. See"
#error "https://protobuf.dev/support/cross-version-runtime-guarantee/#cpp"
#endif
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/map.h"  // IWYU pragma: export
#include "google/protobuf/map_entry.h"
#include "google/protobuf/map_field_inl.h"
#include "google/protobuf/generated_enum_reflection.h"
#include "google/protobuf/unknown_field_set.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_Messaging_2eproto

namespace google {
namespace protobuf {
namespace internal {
class AnyMetadata;
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct TableStruct_Messaging_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::google::protobuf::internal::DescriptorTable
    descriptor_table_Messaging_2eproto;
namespace click {
namespace protobuf {
class ControlMessage;
struct ControlMessageDefaultTypeInternal;
extern ControlMessageDefaultTypeInternal _ControlMessage_default_instance_;
class ControlMessage_Object;
struct ControlMessage_ObjectDefaultTypeInternal;
extern ControlMessage_ObjectDefaultTypeInternal _ControlMessage_Object_default_instance_;
class ControlMessage_Object_ControlEventsEntry_DoNotUse;
struct ControlMessage_Object_ControlEventsEntry_DoNotUseDefaultTypeInternal;
extern ControlMessage_Object_ControlEventsEntry_DoNotUseDefaultTypeInternal _ControlMessage_Object_ControlEventsEntry_DoNotUse_default_instance_;
class ControlMessage_ObjectsEntry_DoNotUse;
struct ControlMessage_ObjectsEntry_DoNotUseDefaultTypeInternal;
extern ControlMessage_ObjectsEntry_DoNotUseDefaultTypeInternal _ControlMessage_ObjectsEntry_DoNotUse_default_instance_;
class ErrorMessage;
struct ErrorMessageDefaultTypeInternal;
extern ErrorMessageDefaultTypeInternal _ErrorMessage_default_instance_;
class HandshakeInitMessage;
struct HandshakeInitMessageDefaultTypeInternal;
extern HandshakeInitMessageDefaultTypeInternal _HandshakeInitMessage_default_instance_;
class HandshakeMessage;
struct HandshakeMessageDefaultTypeInternal;
extern HandshakeMessageDefaultTypeInternal _HandshakeMessage_default_instance_;
class HandshakeMessage_Object;
struct HandshakeMessage_ObjectDefaultTypeInternal;
extern HandshakeMessage_ObjectDefaultTypeInternal _HandshakeMessage_Object_default_instance_;
class HandshakeMessage_Object_ControlEventsEntry_DoNotUse;
struct HandshakeMessage_Object_ControlEventsEntry_DoNotUseDefaultTypeInternal;
extern HandshakeMessage_Object_ControlEventsEntry_DoNotUseDefaultTypeInternal _HandshakeMessage_Object_ControlEventsEntry_DoNotUse_default_instance_;
class HandshakeMessage_Object_SensorsEntry_DoNotUse;
struct HandshakeMessage_Object_SensorsEntry_DoNotUseDefaultTypeInternal;
extern HandshakeMessage_Object_SensorsEntry_DoNotUseDefaultTypeInternal _HandshakeMessage_Object_SensorsEntry_DoNotUse_default_instance_;
class HandshakeMessage_ObjectsEntry_DoNotUse;
struct HandshakeMessage_ObjectsEntry_DoNotUseDefaultTypeInternal;
extern HandshakeMessage_ObjectsEntry_DoNotUseDefaultTypeInternal _HandshakeMessage_ObjectsEntry_DoNotUse_default_instance_;
class HandshakeMessage_Sensors;
struct HandshakeMessage_SensorsDefaultTypeInternal;
extern HandshakeMessage_SensorsDefaultTypeInternal _HandshakeMessage_Sensors_default_instance_;
class HandshakeMessage_SimulationSettings;
struct HandshakeMessage_SimulationSettingsDefaultTypeInternal;
extern HandshakeMessage_SimulationSettingsDefaultTypeInternal _HandshakeMessage_SimulationSettings_default_instance_;
class Message;
struct MessageDefaultTypeInternal;
extern MessageDefaultTypeInternal _Message_default_instance_;
class ResetMessage;
struct ResetMessageDefaultTypeInternal;
extern ResetMessageDefaultTypeInternal _ResetMessage_default_instance_;
class SensorMessage;
struct SensorMessageDefaultTypeInternal;
extern SensorMessageDefaultTypeInternal _SensorMessage_default_instance_;
class SensorMessage_Object;
struct SensorMessage_ObjectDefaultTypeInternal;
extern SensorMessage_ObjectDefaultTypeInternal _SensorMessage_Object_default_instance_;
class SensorMessage_Object_SensorsEntry_DoNotUse;
struct SensorMessage_Object_SensorsEntry_DoNotUseDefaultTypeInternal;
extern SensorMessage_Object_SensorsEntry_DoNotUseDefaultTypeInternal _SensorMessage_Object_SensorsEntry_DoNotUse_default_instance_;
class SensorMessage_ObjectsEntry_DoNotUse;
struct SensorMessage_ObjectsEntry_DoNotUseDefaultTypeInternal;
extern SensorMessage_ObjectsEntry_DoNotUseDefaultTypeInternal _SensorMessage_ObjectsEntry_DoNotUse_default_instance_;
class SensorMessage_Sensor;
struct SensorMessage_SensorDefaultTypeInternal;
extern SensorMessage_SensorDefaultTypeInternal _SensorMessage_Sensor_default_instance_;
class SensorMessage_Sensors;
struct SensorMessage_SensorsDefaultTypeInternal;
extern SensorMessage_SensorsDefaultTypeInternal _SensorMessage_Sensors_default_instance_;
class SensorMessage_SimulationVariables;
struct SensorMessage_SimulationVariablesDefaultTypeInternal;
extern SensorMessage_SimulationVariablesDefaultTypeInternal _SensorMessage_SimulationVariables_default_instance_;
class SensorMessage_Vec3;
struct SensorMessage_Vec3DefaultTypeInternal;
extern SensorMessage_Vec3DefaultTypeInternal _SensorMessage_Vec3_default_instance_;
class SensorRequestMessage;
struct SensorRequestMessageDefaultTypeInternal;
extern SensorRequestMessageDefaultTypeInternal _SensorRequestMessage_default_instance_;
}  // namespace protobuf
}  // namespace click
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google

namespace click {
namespace protobuf {
enum MessageType : int {
  HandshakeInitMessageType = 0,
  HandshakeMessageType = 1,
  SensorRequestMessageType = 6,
  ControlMessageType = 2,
  SensorMessageType = 3,
  ResetMessageType = 4,
  ErrorMessageType = 5,
  MessageType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  MessageType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool MessageType_IsValid(int value);
extern const uint32_t MessageType_internal_data_[];
constexpr MessageType MessageType_MIN = static_cast<MessageType>(0);
constexpr MessageType MessageType_MAX = static_cast<MessageType>(6);
constexpr int MessageType_ARRAYSIZE = 6 + 1;
const ::google::protobuf::EnumDescriptor*
MessageType_descriptor();
template <typename T>
const std::string& MessageType_Name(T value) {
  static_assert(std::is_same<T, MessageType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to MessageType_Name().");
  return MessageType_Name(static_cast<MessageType>(value));
}
template <>
inline const std::string& MessageType_Name(MessageType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<MessageType_descriptor,
                                                 0, 6>(
      static_cast<int>(value));
}
inline bool MessageType_Parse(absl::string_view name, MessageType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<MessageType>(
      MessageType_descriptor(), name, value);
}
enum ValueType : int {
  Angle = 0,
  AngularVelocity1D = 1,
  Torque1D = 2,
  Position = 3,
  RPY = 4,
  Activated = 5,
  Acceleration3D = 6,
  Force1D = 12,
  Force3D = 7,
  Torque3D = 8,
  AngularAcceleration3D = 9,
  Velocity3D = 10,
  AngularVelocity3D = 11,
  Multiple = 15,
  ValueType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  ValueType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool ValueType_IsValid(int value);
extern const uint32_t ValueType_internal_data_[];
constexpr ValueType ValueType_MIN = static_cast<ValueType>(0);
constexpr ValueType ValueType_MAX = static_cast<ValueType>(15);
constexpr int ValueType_ARRAYSIZE = 15 + 1;
const ::google::protobuf::EnumDescriptor*
ValueType_descriptor();
template <typename T>
const std::string& ValueType_Name(T value) {
  static_assert(std::is_same<T, ValueType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to ValueType_Name().");
  return ValueType_Name(static_cast<ValueType>(value));
}
template <>
inline const std::string& ValueType_Name(ValueType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<ValueType_descriptor,
                                                 0, 15>(
      static_cast<int>(value));
}
inline bool ValueType_Parse(absl::string_view name, ValueType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ValueType>(
      ValueType_descriptor(), name, value);
}
enum Version : int {
  UNDEFINED = 0,
  CURRENT_VERSION = 1,
  Version_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  Version_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool Version_IsValid(int value);
extern const uint32_t Version_internal_data_[];
constexpr Version Version_MIN = static_cast<Version>(0);
constexpr Version Version_MAX = static_cast<Version>(1);
constexpr int Version_ARRAYSIZE = 1 + 1;
const ::google::protobuf::EnumDescriptor*
Version_descriptor();
template <typename T>
const std::string& Version_Name(T value) {
  static_assert(std::is_same<T, Version>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to Version_Name().");
  return Version_Name(static_cast<Version>(value));
}
template <>
inline const std::string& Version_Name(Version value) {
  return ::google::protobuf::internal::NameOfDenseEnum<Version_descriptor,
                                                 0, 1>(
      static_cast<int>(value));
}
inline bool Version_Parse(absl::string_view name, Version* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Version>(
      Version_descriptor(), name, value);
}
enum ErrorType : int {
  VersionNotSupported = 0,
  ErrorType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  ErrorType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool ErrorType_IsValid(int value);
extern const uint32_t ErrorType_internal_data_[];
constexpr ErrorType ErrorType_MIN = static_cast<ErrorType>(0);
constexpr ErrorType ErrorType_MAX = static_cast<ErrorType>(0);
constexpr int ErrorType_ARRAYSIZE = 0 + 1;
const ::google::protobuf::EnumDescriptor*
ErrorType_descriptor();
template <typename T>
const std::string& ErrorType_Name(T value) {
  static_assert(std::is_same<T, ErrorType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to ErrorType_Name().");
  return ErrorType_Name(static_cast<ErrorType>(value));
}
template <>
inline const std::string& ErrorType_Name(ErrorType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<ErrorType_descriptor,
                                                 0, 0>(
      static_cast<int>(value));
}
inline bool ErrorType_Parse(absl::string_view name, ErrorType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ErrorType>(
      ErrorType_descriptor(), name, value);
}

// ===================================================================


// -------------------------------------------------------------------

class SensorRequestMessage final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:click.protobuf.SensorRequestMessage) */ {
 public:
  inline SensorRequestMessage() : SensorRequestMessage(nullptr) {}
  ~SensorRequestMessage() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR SensorRequestMessage(
      ::google::protobuf::internal::ConstantInitialized);

  inline SensorRequestMessage(const SensorRequestMessage& from) : SensorRequestMessage(nullptr, from) {}
  inline SensorRequestMessage(SensorRequestMessage&& from) noexcept
      : SensorRequestMessage(nullptr, std::move(from)) {}
  inline SensorRequestMessage& operator=(const SensorRequestMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline SensorRequestMessage& operator=(SensorRequestMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SensorRequestMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const SensorRequestMessage* internal_default_instance() {
    return reinterpret_cast<const SensorRequestMessage*>(
        &_SensorRequestMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 2;
  friend void swap(SensorRequestMessage& a, SensorRequestMessage& b) { a.Swap(&b); }
  inline void Swap(SensorRequestMessage* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SensorRequestMessage* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SensorRequestMessage* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<SensorRequestMessage>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SensorRequestMessage& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const SensorRequestMessage& from) { SensorRequestMessage::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(SensorRequestMessage* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "click.protobuf.SensorRequestMessage"; }

 protected:
  explicit SensorRequestMessage(::google::protobuf::Arena* arena);
  SensorRequestMessage(::google::protobuf::Arena* arena, const SensorRequestMessage& from);
  SensorRequestMessage(::google::protobuf::Arena* arena, SensorRequestMessage&& from) noexcept
      : SensorRequestMessage(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kMessageTypeFieldNumber = 1,
  };
  // .click.protobuf.MessageType messageType = 1;
  void clear_messagetype() ;
  ::click::protobuf::MessageType messagetype() const;
  void set_messagetype(::click::protobuf::MessageType value);

  private:
  ::click::protobuf::MessageType _internal_messagetype() const;
  void _internal_set_messagetype(::click::protobuf::MessageType value);

  public:
  // @@protoc_insertion_point(class_scope:click.protobuf.SensorRequestMessage)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_SensorRequestMessage_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const SensorRequestMessage& from_msg);
    int messagetype_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Messaging_2eproto;
};
// -------------------------------------------------------------------

class SensorMessage_Vec3 final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:click.protobuf.SensorMessage.Vec3) */ {
 public:
  inline SensorMessage_Vec3() : SensorMessage_Vec3(nullptr) {}
  ~SensorMessage_Vec3() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR SensorMessage_Vec3(
      ::google::protobuf::internal::ConstantInitialized);

  inline SensorMessage_Vec3(const SensorMessage_Vec3& from) : SensorMessage_Vec3(nullptr, from) {}
  inline SensorMessage_Vec3(SensorMessage_Vec3&& from) noexcept
      : SensorMessage_Vec3(nullptr, std::move(from)) {}
  inline SensorMessage_Vec3& operator=(const SensorMessage_Vec3& from) {
    CopyFrom(from);
    return *this;
  }
  inline SensorMessage_Vec3& operator=(SensorMessage_Vec3&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SensorMessage_Vec3& default_instance() {
    return *internal_default_instance();
  }
  static inline const SensorMessage_Vec3* internal_default_instance() {
    return reinterpret_cast<const SensorMessage_Vec3*>(
        &_SensorMessage_Vec3_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 14;
  friend void swap(SensorMessage_Vec3& a, SensorMessage_Vec3& b) { a.Swap(&b); }
  inline void Swap(SensorMessage_Vec3* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SensorMessage_Vec3* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SensorMessage_Vec3* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<SensorMessage_Vec3>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SensorMessage_Vec3& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const SensorMessage_Vec3& from) { SensorMessage_Vec3::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(SensorMessage_Vec3* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "click.protobuf.SensorMessage.Vec3"; }

 protected:
  explicit SensorMessage_Vec3(::google::protobuf::Arena* arena);
  SensorMessage_Vec3(::google::protobuf::Arena* arena, const SensorMessage_Vec3& from);
  SensorMessage_Vec3(::google::protobuf::Arena* arena, SensorMessage_Vec3&& from) noexcept
      : SensorMessage_Vec3(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kArrFieldNumber = 1,
  };
  // repeated double arr = 1;
  int arr_size() const;
  private:
  int _internal_arr_size() const;

  public:
  void clear_arr() ;
  double arr(int index) const;
  void set_arr(int index, double value);
  void add_arr(double value);
  const ::google::protobuf::RepeatedField<double>& arr() const;
  ::google::protobuf::RepeatedField<double>* mutable_arr();

  private:
  const ::google::protobuf::RepeatedField<double>& _internal_arr() const;
  ::google::protobuf::RepeatedField<double>* _internal_mutable_arr();

  public:
  // @@protoc_insertion_point(class_scope:click.protobuf.SensorMessage.Vec3)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_SensorMessage_Vec3_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const SensorMessage_Vec3& from_msg);
    ::google::protobuf::RepeatedField<double> arr_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Messaging_2eproto;
};
// -------------------------------------------------------------------

class SensorMessage_SimulationVariables final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:click.protobuf.SensorMessage.SimulationVariables) */ {
 public:
  inline SensorMessage_SimulationVariables() : SensorMessage_SimulationVariables(nullptr) {}
  ~SensorMessage_SimulationVariables() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR SensorMessage_SimulationVariables(
      ::google::protobuf::internal::ConstantInitialized);

  inline SensorMessage_SimulationVariables(const SensorMessage_SimulationVariables& from) : SensorMessage_SimulationVariables(nullptr, from) {}
  inline SensorMessage_SimulationVariables(SensorMessage_SimulationVariables&& from) noexcept
      : SensorMessage_SimulationVariables(nullptr, std::move(from)) {}
  inline SensorMessage_SimulationVariables& operator=(const SensorMessage_SimulationVariables& from) {
    CopyFrom(from);
    return *this;
  }
  inline SensorMessage_SimulationVariables& operator=(SensorMessage_SimulationVariables&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SensorMessage_SimulationVariables& default_instance() {
    return *internal_default_instance();
  }
  static inline const SensorMessage_SimulationVariables* internal_default_instance() {
    return reinterpret_cast<const SensorMessage_SimulationVariables*>(
        &_SensorMessage_SimulationVariables_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 19;
  friend void swap(SensorMessage_SimulationVariables& a, SensorMessage_SimulationVariables& b) { a.Swap(&b); }
  inline void Swap(SensorMessage_SimulationVariables* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SensorMessage_SimulationVariables* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SensorMessage_SimulationVariables* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<SensorMessage_SimulationVariables>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SensorMessage_SimulationVariables& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const SensorMessage_SimulationVariables& from) { SensorMessage_SimulationVariables::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(SensorMessage_SimulationVariables* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "click.protobuf.SensorMessage.SimulationVariables"; }

 protected:
  explicit SensorMessage_SimulationVariables(::google::protobuf::Arena* arena);
  SensorMessage_SimulationVariables(::google::protobuf::Arena* arena, const SensorMessage_SimulationVariables& from);
  SensorMessage_SimulationVariables(::google::protobuf::Arena* arena, SensorMessage_SimulationVariables&& from) noexcept
      : SensorMessage_SimulationVariables(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kSimulatedTimeFieldNumber = 1,
  };
  // double simulatedTime = 1;
  void clear_simulatedtime() ;
  double simulatedtime() const;
  void set_simulatedtime(double value);

  private:
  double _internal_simulatedtime() const;
  void _internal_set_simulatedtime(double value);

  public:
  // @@protoc_insertion_point(class_scope:click.protobuf.SensorMessage.SimulationVariables)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_SensorMessage_SimulationVariables_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const SensorMessage_SimulationVariables& from_msg);
    double simulatedtime_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Messaging_2eproto;
};
// -------------------------------------------------------------------

class ResetMessage final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:click.protobuf.ResetMessage) */ {
 public:
  inline ResetMessage() : ResetMessage(nullptr) {}
  ~ResetMessage() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ResetMessage(
      ::google::protobuf::internal::ConstantInitialized);

  inline ResetMessage(const ResetMessage& from) : ResetMessage(nullptr, from) {}
  inline ResetMessage(ResetMessage&& from) noexcept
      : ResetMessage(nullptr, std::move(from)) {}
  inline ResetMessage& operator=(const ResetMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline ResetMessage& operator=(ResetMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ResetMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const ResetMessage* internal_default_instance() {
    return reinterpret_cast<const ResetMessage*>(
        &_ResetMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 22;
  friend void swap(ResetMessage& a, ResetMessage& b) { a.Swap(&b); }
  inline void Swap(ResetMessage* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ResetMessage* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ResetMessage* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<ResetMessage>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ResetMessage& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ResetMessage& from) { ResetMessage::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(ResetMessage* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "click.protobuf.ResetMessage"; }

 protected:
  explicit ResetMessage(::google::protobuf::Arena* arena);
  ResetMessage(::google::protobuf::Arena* arena, const ResetMessage& from);
  ResetMessage(::google::protobuf::Arena* arena, ResetMessage&& from) noexcept
      : ResetMessage(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kMessageTypeFieldNumber = 1,
  };
  // .click.protobuf.MessageType messageType = 1;
  void clear_messagetype() ;
  ::click::protobuf::MessageType messagetype() const;
  void set_messagetype(::click::protobuf::MessageType value);

  private:
  ::click::protobuf::MessageType _internal_messagetype() const;
  void _internal_set_messagetype(::click::protobuf::MessageType value);

  public:
  // @@protoc_insertion_point(class_scope:click.protobuf.ResetMessage)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_ResetMessage_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const ResetMessage& from_msg);
    int messagetype_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Messaging_2eproto;
};
// -------------------------------------------------------------------

class Message final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:click.protobuf.Message) */ {
 public:
  inline Message() : Message(nullptr) {}
  ~Message() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Message(
      ::google::protobuf::internal::ConstantInitialized);

  inline Message(const Message& from) : Message(nullptr, from) {}
  inline Message(Message&& from) noexcept
      : Message(nullptr, std::move(from)) {}
  inline Message& operator=(const Message& from) {
    CopyFrom(from);
    return *this;
  }
  inline Message& operator=(Message&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Message& default_instance() {
    return *internal_default_instance();
  }
  static inline const Message* internal_default_instance() {
    return reinterpret_cast<const Message*>(
        &_Message_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 0;
  friend void swap(Message& a, Message& b) { a.Swap(&b); }
  inline void Swap(Message* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Message* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Message* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<Message>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Message& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Message& from) { Message::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Message* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "click.protobuf.Message"; }

 protected:
  explicit Message(::google::protobuf::Arena* arena);
  Message(::google::protobuf::Arena* arena, const Message& from);
  Message(::google::protobuf::Arena* arena, Message&& from) noexcept
      : Message(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kMessageTypeFieldNumber = 1,
    kIdFieldNumber = 2,
  };
  // .click.protobuf.MessageType messageType = 1;
  void clear_messagetype() ;
  ::click::protobuf::MessageType messagetype() const;
  void set_messagetype(::click::protobuf::MessageType value);

  private:
  ::click::protobuf::MessageType _internal_messagetype() const;
  void _internal_set_messagetype(::click::protobuf::MessageType value);

  public:
  // int32 id = 2;
  void clear_id() ;
  ::int32_t id() const;
  void set_id(::int32_t value);

  private:
  ::int32_t _internal_id() const;
  void _internal_set_id(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:click.protobuf.Message)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_Message_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Message& from_msg);
    int messagetype_;
    ::int32_t id_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Messaging_2eproto;
};
// -------------------------------------------------------------------

class HandshakeMessage_SimulationSettings final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:click.protobuf.HandshakeMessage.SimulationSettings) */ {
 public:
  inline HandshakeMessage_SimulationSettings() : HandshakeMessage_SimulationSettings(nullptr) {}
  ~HandshakeMessage_SimulationSettings() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR HandshakeMessage_SimulationSettings(
      ::google::protobuf::internal::ConstantInitialized);

  inline HandshakeMessage_SimulationSettings(const HandshakeMessage_SimulationSettings& from) : HandshakeMessage_SimulationSettings(nullptr, from) {}
  inline HandshakeMessage_SimulationSettings(HandshakeMessage_SimulationSettings&& from) noexcept
      : HandshakeMessage_SimulationSettings(nullptr, std::move(from)) {}
  inline HandshakeMessage_SimulationSettings& operator=(const HandshakeMessage_SimulationSettings& from) {
    CopyFrom(from);
    return *this;
  }
  inline HandshakeMessage_SimulationSettings& operator=(HandshakeMessage_SimulationSettings&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const HandshakeMessage_SimulationSettings& default_instance() {
    return *internal_default_instance();
  }
  static inline const HandshakeMessage_SimulationSettings* internal_default_instance() {
    return reinterpret_cast<const HandshakeMessage_SimulationSettings*>(
        &_HandshakeMessage_SimulationSettings_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 7;
  friend void swap(HandshakeMessage_SimulationSettings& a, HandshakeMessage_SimulationSettings& b) { a.Swap(&b); }
  inline void Swap(HandshakeMessage_SimulationSettings* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HandshakeMessage_SimulationSettings* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  HandshakeMessage_SimulationSettings* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<HandshakeMessage_SimulationSettings>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const HandshakeMessage_SimulationSettings& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const HandshakeMessage_SimulationSettings& from) { HandshakeMessage_SimulationSettings::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(HandshakeMessage_SimulationSettings* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "click.protobuf.HandshakeMessage.SimulationSettings"; }

 protected:
  explicit HandshakeMessage_SimulationSettings(::google::protobuf::Arena* arena);
  HandshakeMessage_SimulationSettings(::google::protobuf::Arena* arena, const HandshakeMessage_SimulationSettings& from);
  HandshakeMessage_SimulationSettings(::google::protobuf::Arena* arena, HandshakeMessage_SimulationSettings&& from) noexcept
      : HandshakeMessage_SimulationSettings(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kTimeStepFieldNumber = 1,
  };
  // double timeStep = 1;
  void clear_timestep() ;
  double timestep() const;
  void set_timestep(double value);

  private:
  double _internal_timestep() const;
  void _internal_set_timestep(double value);

  public:
  // @@protoc_insertion_point(class_scope:click.protobuf.HandshakeMessage.SimulationSettings)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_HandshakeMessage_SimulationSettings_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const HandshakeMessage_SimulationSettings& from_msg);
    double timestep_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Messaging_2eproto;
};
// -------------------------------------------------------------------

class HandshakeMessage_Sensors final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:click.protobuf.HandshakeMessage.Sensors) */ {
 public:
  inline HandshakeMessage_Sensors() : HandshakeMessage_Sensors(nullptr) {}
  ~HandshakeMessage_Sensors() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR HandshakeMessage_Sensors(
      ::google::protobuf::internal::ConstantInitialized);

  inline HandshakeMessage_Sensors(const HandshakeMessage_Sensors& from) : HandshakeMessage_Sensors(nullptr, from) {}
  inline HandshakeMessage_Sensors(HandshakeMessage_Sensors&& from) noexcept
      : HandshakeMessage_Sensors(nullptr, std::move(from)) {}
  inline HandshakeMessage_Sensors& operator=(const HandshakeMessage_Sensors& from) {
    CopyFrom(from);
    return *this;
  }
  inline HandshakeMessage_Sensors& operator=(HandshakeMessage_Sensors&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const HandshakeMessage_Sensors& default_instance() {
    return *internal_default_instance();
  }
  static inline const HandshakeMessage_Sensors* internal_default_instance() {
    return reinterpret_cast<const HandshakeMessage_Sensors*>(
        &_HandshakeMessage_Sensors_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 3;
  friend void swap(HandshakeMessage_Sensors& a, HandshakeMessage_Sensors& b) { a.Swap(&b); }
  inline void Swap(HandshakeMessage_Sensors* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HandshakeMessage_Sensors* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  HandshakeMessage_Sensors* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<HandshakeMessage_Sensors>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const HandshakeMessage_Sensors& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const HandshakeMessage_Sensors& from) { HandshakeMessage_Sensors::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(HandshakeMessage_Sensors* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "click.protobuf.HandshakeMessage.Sensors"; }

 protected:
  explicit HandshakeMessage_Sensors(::google::protobuf::Arena* arena);
  HandshakeMessage_Sensors(::google::protobuf::Arena* arena, const HandshakeMessage_Sensors& from);
  HandshakeMessage_Sensors(::google::protobuf::Arena* arena, HandshakeMessage_Sensors&& from) noexcept
      : HandshakeMessage_Sensors(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kTypesFieldNumber = 1,
  };
  // repeated .click.protobuf.ValueType types = 1;
  int types_size() const;
  private:
  int _internal_types_size() const;

  public:
  void clear_types() ;
  public:
  ::click::protobuf::ValueType types(int index) const;
  void set_types(int index, ::click::protobuf::ValueType value);
  void add_types(::click::protobuf::ValueType value);
  const ::google::protobuf::RepeatedField<int>& types() const;
  ::google::protobuf::RepeatedField<int>* mutable_types();

  private:
  const ::google::protobuf::RepeatedField<int>& _internal_types() const;
  ::google::protobuf::RepeatedField<int>* _internal_mutable_types();

  public:
  // @@protoc_insertion_point(class_scope:click.protobuf.HandshakeMessage.Sensors)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_HandshakeMessage_Sensors_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const HandshakeMessage_Sensors& from_msg);
    ::google::protobuf::RepeatedField<int> types_;
    mutable ::google::protobuf::internal::CachedSize _types_cached_byte_size_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Messaging_2eproto;
};
// -------------------------------------------------------------------

class HandshakeMessage_Object_ControlEventsEntry_DoNotUse final
    : public ::google::protobuf::internal::MapEntry<
          HandshakeMessage_Object_ControlEventsEntry_DoNotUse, std::string, ::click::protobuf::ValueType,
          ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
          ::google::protobuf::internal::WireFormatLite::TYPE_ENUM> {
 public:
  using SuperType = ::google::protobuf::internal::MapEntry<
      HandshakeMessage_Object_ControlEventsEntry_DoNotUse, std::string, ::click::protobuf::ValueType,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>;
  HandshakeMessage_Object_ControlEventsEntry_DoNotUse();
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR HandshakeMessage_Object_ControlEventsEntry_DoNotUse(
      ::google::protobuf::internal::ConstantInitialized);
  explicit HandshakeMessage_Object_ControlEventsEntry_DoNotUse(::google::protobuf::Arena* arena);
  static const HandshakeMessage_Object_ControlEventsEntry_DoNotUse* internal_default_instance() {
    return reinterpret_cast<const HandshakeMessage_Object_ControlEventsEntry_DoNotUse*>(
        &_HandshakeMessage_Object_ControlEventsEntry_DoNotUse_default_instance_);
  }
const ::google::protobuf::Message::ClassData* GetClassData() const final;
  friend struct ::TableStruct_Messaging_2eproto;
};
// -------------------------------------------------------------------

class HandshakeInitMessage final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:click.protobuf.HandshakeInitMessage) */ {
 public:
  inline HandshakeInitMessage() : HandshakeInitMessage(nullptr) {}
  ~HandshakeInitMessage() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR HandshakeInitMessage(
      ::google::protobuf::internal::ConstantInitialized);

  inline HandshakeInitMessage(const HandshakeInitMessage& from) : HandshakeInitMessage(nullptr, from) {}
  inline HandshakeInitMessage(HandshakeInitMessage&& from) noexcept
      : HandshakeInitMessage(nullptr, std::move(from)) {}
  inline HandshakeInitMessage& operator=(const HandshakeInitMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline HandshakeInitMessage& operator=(HandshakeInitMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const HandshakeInitMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const HandshakeInitMessage* internal_default_instance() {
    return reinterpret_cast<const HandshakeInitMessage*>(
        &_HandshakeInitMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 1;
  friend void swap(HandshakeInitMessage& a, HandshakeInitMessage& b) { a.Swap(&b); }
  inline void Swap(HandshakeInitMessage* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HandshakeInitMessage* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  HandshakeInitMessage* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<HandshakeInitMessage>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const HandshakeInitMessage& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const HandshakeInitMessage& from) { HandshakeInitMessage::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(HandshakeInitMessage* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "click.protobuf.HandshakeInitMessage"; }

 protected:
  explicit HandshakeInitMessage(::google::protobuf::Arena* arena);
  HandshakeInitMessage(::google::protobuf::Arena* arena, const HandshakeInitMessage& from);
  HandshakeInitMessage(::google::protobuf::Arena* arena, HandshakeInitMessage&& from) noexcept
      : HandshakeInitMessage(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kMessageTypeFieldNumber = 1,
    kVersionFieldNumber = 2,
  };
  // .click.protobuf.MessageType messageType = 1;
  void clear_messagetype() ;
  ::click::protobuf::MessageType messagetype() const;
  void set_messagetype(::click::protobuf::MessageType value);

  private:
  ::click::protobuf::MessageType _internal_messagetype() const;
  void _internal_set_messagetype(::click::protobuf::MessageType value);

  public:
  // .click.protobuf.Version version = 2;
  void clear_version() ;
  ::click::protobuf::Version version() const;
  void set_version(::click::protobuf::Version value);

  private:
  ::click::protobuf::Version _internal_version() const;
  void _internal_set_version(::click::protobuf::Version value);

  public:
  // @@protoc_insertion_point(class_scope:click.protobuf.HandshakeInitMessage)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_HandshakeInitMessage_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const HandshakeInitMessage& from_msg);
    int messagetype_;
    int version_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Messaging_2eproto;
};
// -------------------------------------------------------------------

class ErrorMessage final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:click.protobuf.ErrorMessage) */ {
 public:
  inline ErrorMessage() : ErrorMessage(nullptr) {}
  ~ErrorMessage() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ErrorMessage(
      ::google::protobuf::internal::ConstantInitialized);

  inline ErrorMessage(const ErrorMessage& from) : ErrorMessage(nullptr, from) {}
  inline ErrorMessage(ErrorMessage&& from) noexcept
      : ErrorMessage(nullptr, std::move(from)) {}
  inline ErrorMessage& operator=(const ErrorMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline ErrorMessage& operator=(ErrorMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ErrorMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const ErrorMessage* internal_default_instance() {
    return reinterpret_cast<const ErrorMessage*>(
        &_ErrorMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 23;
  friend void swap(ErrorMessage& a, ErrorMessage& b) { a.Swap(&b); }
  inline void Swap(ErrorMessage* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ErrorMessage* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ErrorMessage* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<ErrorMessage>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ErrorMessage& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ErrorMessage& from) { ErrorMessage::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(ErrorMessage* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "click.protobuf.ErrorMessage"; }

 protected:
  explicit ErrorMessage(::google::protobuf::Arena* arena);
  ErrorMessage(::google::protobuf::Arena* arena, const ErrorMessage& from);
  ErrorMessage(::google::protobuf::Arena* arena, ErrorMessage&& from) noexcept
      : ErrorMessage(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kErrormessageFieldNumber = 3,
    kMessageTypeFieldNumber = 1,
    kErrorFieldNumber = 2,
  };
  // string errormessage = 3;
  void clear_errormessage() ;
  const std::string& errormessage() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_errormessage(Arg_&& arg, Args_... args);
  std::string* mutable_errormessage();
  PROTOBUF_NODISCARD std::string* release_errormessage();
  void set_allocated_errormessage(std::string* value);

  private:
  const std::string& _internal_errormessage() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_errormessage(
      const std::string& value);
  std::string* _internal_mutable_errormessage();

  public:
  // .click.protobuf.MessageType messageType = 1;
  void clear_messagetype() ;
  ::click::protobuf::MessageType messagetype() const;
  void set_messagetype(::click::protobuf::MessageType value);

  private:
  ::click::protobuf::MessageType _internal_messagetype() const;
  void _internal_set_messagetype(::click::protobuf::MessageType value);

  public:
  // .click.protobuf.ErrorType error = 2;
  void clear_error() ;
  ::click::protobuf::ErrorType error() const;
  void set_error(::click::protobuf::ErrorType value);

  private:
  ::click::protobuf::ErrorType _internal_error() const;
  void _internal_set_error(::click::protobuf::ErrorType value);

  public:
  // @@protoc_insertion_point(class_scope:click.protobuf.ErrorMessage)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 0,
      48, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_ErrorMessage_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const ErrorMessage& from_msg);
    ::google::protobuf::internal::ArenaStringPtr errormessage_;
    int messagetype_;
    int error_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Messaging_2eproto;
};
// -------------------------------------------------------------------

class ControlMessage_Object_ControlEventsEntry_DoNotUse final
    : public ::google::protobuf::internal::MapEntry<
          ControlMessage_Object_ControlEventsEntry_DoNotUse, std::string, bool,
          ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
          ::google::protobuf::internal::WireFormatLite::TYPE_BOOL> {
 public:
  using SuperType = ::google::protobuf::internal::MapEntry<
      ControlMessage_Object_ControlEventsEntry_DoNotUse, std::string, bool,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>;
  ControlMessage_Object_ControlEventsEntry_DoNotUse();
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ControlMessage_Object_ControlEventsEntry_DoNotUse(
      ::google::protobuf::internal::ConstantInitialized);
  explicit ControlMessage_Object_ControlEventsEntry_DoNotUse(::google::protobuf::Arena* arena);
  static const ControlMessage_Object_ControlEventsEntry_DoNotUse* internal_default_instance() {
    return reinterpret_cast<const ControlMessage_Object_ControlEventsEntry_DoNotUse*>(
        &_ControlMessage_Object_ControlEventsEntry_DoNotUse_default_instance_);
  }
const ::google::protobuf::Message::ClassData* GetClassData() const final;
  friend struct ::TableStruct_Messaging_2eproto;
};
// -------------------------------------------------------------------

class SensorMessage_Sensor final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:click.protobuf.SensorMessage.Sensor) */ {
 public:
  inline SensorMessage_Sensor() : SensorMessage_Sensor(nullptr) {}
  ~SensorMessage_Sensor() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR SensorMessage_Sensor(
      ::google::protobuf::internal::ConstantInitialized);

  inline SensorMessage_Sensor(const SensorMessage_Sensor& from) : SensorMessage_Sensor(nullptr, from) {}
  inline SensorMessage_Sensor(SensorMessage_Sensor&& from) noexcept
      : SensorMessage_Sensor(nullptr, std::move(from)) {}
  inline SensorMessage_Sensor& operator=(const SensorMessage_Sensor& from) {
    CopyFrom(from);
    return *this;
  }
  inline SensorMessage_Sensor& operator=(SensorMessage_Sensor&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SensorMessage_Sensor& default_instance() {
    return *internal_default_instance();
  }
  enum ValueCase {
    kAngle = 1,
    kAngularVelocity1D = 2,
    kTorque1D = 3,
    kPosition = 4,
    kRpy = 5,
    kActivated = 6,
    kAcceleration3D = 7,
    kForce3D = 8,
    kTorque3D = 9,
    kAngularAcceleration3D = 10,
    kVelocity3D = 12,
    kAngularVelocity3D = 13,
    kForce1D = 14,
    VALUE_NOT_SET = 0,
  };
  static inline const SensorMessage_Sensor* internal_default_instance() {
    return reinterpret_cast<const SensorMessage_Sensor*>(
        &_SensorMessage_Sensor_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 15;
  friend void swap(SensorMessage_Sensor& a, SensorMessage_Sensor& b) { a.Swap(&b); }
  inline void Swap(SensorMessage_Sensor* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SensorMessage_Sensor* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SensorMessage_Sensor* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<SensorMessage_Sensor>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SensorMessage_Sensor& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const SensorMessage_Sensor& from) { SensorMessage_Sensor::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(SensorMessage_Sensor* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "click.protobuf.SensorMessage.Sensor"; }

 protected:
  explicit SensorMessage_Sensor(::google::protobuf::Arena* arena);
  SensorMessage_Sensor(::google::protobuf::Arena* arena, const SensorMessage_Sensor& from);
  SensorMessage_Sensor(::google::protobuf::Arena* arena, SensorMessage_Sensor&& from) noexcept
      : SensorMessage_Sensor(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kAngleFieldNumber = 1,
    kAngularVelocity1DFieldNumber = 2,
    kTorque1DFieldNumber = 3,
    kPositionFieldNumber = 4,
    kRpyFieldNumber = 5,
    kActivatedFieldNumber = 6,
    kAcceleration3DFieldNumber = 7,
    kForce3DFieldNumber = 8,
    kTorque3DFieldNumber = 9,
    kAngularAcceleration3DFieldNumber = 10,
    kVelocity3DFieldNumber = 12,
    kAngularVelocity3DFieldNumber = 13,
    kForce1DFieldNumber = 14,
  };
  // double angle = 1;
  bool has_angle() const;
  void clear_angle() ;
  double angle() const;
  void set_angle(double value);

  private:
  double _internal_angle() const;
  void _internal_set_angle(double value);

  public:
  // double angularVelocity1d = 2;
  bool has_angularvelocity1d() const;
  void clear_angularvelocity1d() ;
  double angularvelocity1d() const;
  void set_angularvelocity1d(double value);

  private:
  double _internal_angularvelocity1d() const;
  void _internal_set_angularvelocity1d(double value);

  public:
  // double torque1d = 3;
  bool has_torque1d() const;
  void clear_torque1d() ;
  double torque1d() const;
  void set_torque1d(double value);

  private:
  double _internal_torque1d() const;
  void _internal_set_torque1d(double value);

  public:
  // .click.protobuf.SensorMessage.Vec3 position = 4;
  bool has_position() const;
  private:
  bool _internal_has_position() const;

  public:
  void clear_position() ;
  const ::click::protobuf::SensorMessage_Vec3& position() const;
  PROTOBUF_NODISCARD ::click::protobuf::SensorMessage_Vec3* release_position();
  ::click::protobuf::SensorMessage_Vec3* mutable_position();
  void set_allocated_position(::click::protobuf::SensorMessage_Vec3* value);
  void unsafe_arena_set_allocated_position(::click::protobuf::SensorMessage_Vec3* value);
  ::click::protobuf::SensorMessage_Vec3* unsafe_arena_release_position();

  private:
  const ::click::protobuf::SensorMessage_Vec3& _internal_position() const;
  ::click::protobuf::SensorMessage_Vec3* _internal_mutable_position();

  public:
  // .click.protobuf.SensorMessage.Vec3 rpy = 5;
  bool has_rpy() const;
  private:
  bool _internal_has_rpy() const;

  public:
  void clear_rpy() ;
  const ::click::protobuf::SensorMessage_Vec3& rpy() const;
  PROTOBUF_NODISCARD ::click::protobuf::SensorMessage_Vec3* release_rpy();
  ::click::protobuf::SensorMessage_Vec3* mutable_rpy();
  void set_allocated_rpy(::click::protobuf::SensorMessage_Vec3* value);
  void unsafe_arena_set_allocated_rpy(::click::protobuf::SensorMessage_Vec3* value);
  ::click::protobuf::SensorMessage_Vec3* unsafe_arena_release_rpy();

  private:
  const ::click::protobuf::SensorMessage_Vec3& _internal_rpy() const;
  ::click::protobuf::SensorMessage_Vec3* _internal_mutable_rpy();

  public:
  // bool activated = 6;
  bool has_activated() const;
  void clear_activated() ;
  bool activated() const;
  void set_activated(bool value);

  private:
  bool _internal_activated() const;
  void _internal_set_activated(bool value);

  public:
  // .click.protobuf.SensorMessage.Vec3 acceleration3d = 7;
  bool has_acceleration3d() const;
  private:
  bool _internal_has_acceleration3d() const;

  public:
  void clear_acceleration3d() ;
  const ::click::protobuf::SensorMessage_Vec3& acceleration3d() const;
  PROTOBUF_NODISCARD ::click::protobuf::SensorMessage_Vec3* release_acceleration3d();
  ::click::protobuf::SensorMessage_Vec3* mutable_acceleration3d();
  void set_allocated_acceleration3d(::click::protobuf::SensorMessage_Vec3* value);
  void unsafe_arena_set_allocated_acceleration3d(::click::protobuf::SensorMessage_Vec3* value);
  ::click::protobuf::SensorMessage_Vec3* unsafe_arena_release_acceleration3d();

  private:
  const ::click::protobuf::SensorMessage_Vec3& _internal_acceleration3d() const;
  ::click::protobuf::SensorMessage_Vec3* _internal_mutable_acceleration3d();

  public:
  // .click.protobuf.SensorMessage.Vec3 force3d = 8;
  bool has_force3d() const;
  private:
  bool _internal_has_force3d() const;

  public:
  void clear_force3d() ;
  const ::click::protobuf::SensorMessage_Vec3& force3d() const;
  PROTOBUF_NODISCARD ::click::protobuf::SensorMessage_Vec3* release_force3d();
  ::click::protobuf::SensorMessage_Vec3* mutable_force3d();
  void set_allocated_force3d(::click::protobuf::SensorMessage_Vec3* value);
  void unsafe_arena_set_allocated_force3d(::click::protobuf::SensorMessage_Vec3* value);
  ::click::protobuf::SensorMessage_Vec3* unsafe_arena_release_force3d();

  private:
  const ::click::protobuf::SensorMessage_Vec3& _internal_force3d() const;
  ::click::protobuf::SensorMessage_Vec3* _internal_mutable_force3d();

  public:
  // .click.protobuf.SensorMessage.Vec3 torque3d = 9;
  bool has_torque3d() const;
  private:
  bool _internal_has_torque3d() const;

  public:
  void clear_torque3d() ;
  const ::click::protobuf::SensorMessage_Vec3& torque3d() const;
  PROTOBUF_NODISCARD ::click::protobuf::SensorMessage_Vec3* release_torque3d();
  ::click::protobuf::SensorMessage_Vec3* mutable_torque3d();
  void set_allocated_torque3d(::click::protobuf::SensorMessage_Vec3* value);
  void unsafe_arena_set_allocated_torque3d(::click::protobuf::SensorMessage_Vec3* value);
  ::click::protobuf::SensorMessage_Vec3* unsafe_arena_release_torque3d();

  private:
  const ::click::protobuf::SensorMessage_Vec3& _internal_torque3d() const;
  ::click::protobuf::SensorMessage_Vec3* _internal_mutable_torque3d();

  public:
  // .click.protobuf.SensorMessage.Vec3 angularAcceleration3d = 10;
  bool has_angularacceleration3d() const;
  private:
  bool _internal_has_angularacceleration3d() const;

  public:
  void clear_angularacceleration3d() ;
  const ::click::protobuf::SensorMessage_Vec3& angularacceleration3d() const;
  PROTOBUF_NODISCARD ::click::protobuf::SensorMessage_Vec3* release_angularacceleration3d();
  ::click::protobuf::SensorMessage_Vec3* mutable_angularacceleration3d();
  void set_allocated_angularacceleration3d(::click::protobuf::SensorMessage_Vec3* value);
  void unsafe_arena_set_allocated_angularacceleration3d(::click::protobuf::SensorMessage_Vec3* value);
  ::click::protobuf::SensorMessage_Vec3* unsafe_arena_release_angularacceleration3d();

  private:
  const ::click::protobuf::SensorMessage_Vec3& _internal_angularacceleration3d() const;
  ::click::protobuf::SensorMessage_Vec3* _internal_mutable_angularacceleration3d();

  public:
  // .click.protobuf.SensorMessage.Vec3 velocity3d = 12;
  bool has_velocity3d() const;
  private:
  bool _internal_has_velocity3d() const;

  public:
  void clear_velocity3d() ;
  const ::click::protobuf::SensorMessage_Vec3& velocity3d() const;
  PROTOBUF_NODISCARD ::click::protobuf::SensorMessage_Vec3* release_velocity3d();
  ::click::protobuf::SensorMessage_Vec3* mutable_velocity3d();
  void set_allocated_velocity3d(::click::protobuf::SensorMessage_Vec3* value);
  void unsafe_arena_set_allocated_velocity3d(::click::protobuf::SensorMessage_Vec3* value);
  ::click::protobuf::SensorMessage_Vec3* unsafe_arena_release_velocity3d();

  private:
  const ::click::protobuf::SensorMessage_Vec3& _internal_velocity3d() const;
  ::click::protobuf::SensorMessage_Vec3* _internal_mutable_velocity3d();

  public:
  // .click.protobuf.SensorMessage.Vec3 angularVelocity3d = 13;
  bool has_angularvelocity3d() const;
  private:
  bool _internal_has_angularvelocity3d() const;

  public:
  void clear_angularvelocity3d() ;
  const ::click::protobuf::SensorMessage_Vec3& angularvelocity3d() const;
  PROTOBUF_NODISCARD ::click::protobuf::SensorMessage_Vec3* release_angularvelocity3d();
  ::click::protobuf::SensorMessage_Vec3* mutable_angularvelocity3d();
  void set_allocated_angularvelocity3d(::click::protobuf::SensorMessage_Vec3* value);
  void unsafe_arena_set_allocated_angularvelocity3d(::click::protobuf::SensorMessage_Vec3* value);
  ::click::protobuf::SensorMessage_Vec3* unsafe_arena_release_angularvelocity3d();

  private:
  const ::click::protobuf::SensorMessage_Vec3& _internal_angularvelocity3d() const;
  ::click::protobuf::SensorMessage_Vec3* _internal_mutable_angularvelocity3d();

  public:
  // double force1d = 14;
  bool has_force1d() const;
  void clear_force1d() ;
  double force1d() const;
  void set_force1d(double value);

  private:
  double _internal_force1d() const;
  void _internal_set_force1d(double value);

  public:
  void clear_value();
  ValueCase value_case() const;
  // @@protoc_insertion_point(class_scope:click.protobuf.SensorMessage.Sensor)
 private:
  class _Internal;
  void set_has_angle();
  void set_has_angularvelocity1d();
  void set_has_torque1d();
  void set_has_position();
  void set_has_rpy();
  void set_has_activated();
  void set_has_acceleration3d();
  void set_has_force3d();
  void set_has_torque3d();
  void set_has_angularacceleration3d();
  void set_has_velocity3d();
  void set_has_angularvelocity3d();
  void set_has_force1d();
  inline bool has_value() const;
  inline void clear_has_value();
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 13, 8,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_SensorMessage_Sensor_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const SensorMessage_Sensor& from_msg);
    union ValueUnion {
      constexpr ValueUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      double angle_;
      double angularvelocity1d_;
      double torque1d_;
      ::click::protobuf::SensorMessage_Vec3* position_;
      ::click::protobuf::SensorMessage_Vec3* rpy_;
      bool activated_;
      ::click::protobuf::SensorMessage_Vec3* acceleration3d_;
      ::click::protobuf::SensorMessage_Vec3* force3d_;
      ::click::protobuf::SensorMessage_Vec3* torque3d_;
      ::click::protobuf::SensorMessage_Vec3* angularacceleration3d_;
      ::click::protobuf::SensorMessage_Vec3* velocity3d_;
      ::click::protobuf::SensorMessage_Vec3* angularvelocity3d_;
      double force1d_;
    } value_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[1];
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Messaging_2eproto;
};
// -------------------------------------------------------------------

class HandshakeMessage_Object_SensorsEntry_DoNotUse final
    : public ::google::protobuf::internal::MapEntry<
          HandshakeMessage_Object_SensorsEntry_DoNotUse, std::string, ::click::protobuf::HandshakeMessage_Sensors,
          ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
          ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE> {
 public:
  using SuperType = ::google::protobuf::internal::MapEntry<
      HandshakeMessage_Object_SensorsEntry_DoNotUse, std::string, ::click::protobuf::HandshakeMessage_Sensors,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE>;
  HandshakeMessage_Object_SensorsEntry_DoNotUse();
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR HandshakeMessage_Object_SensorsEntry_DoNotUse(
      ::google::protobuf::internal::ConstantInitialized);
  explicit HandshakeMessage_Object_SensorsEntry_DoNotUse(::google::protobuf::Arena* arena);
  static const HandshakeMessage_Object_SensorsEntry_DoNotUse* internal_default_instance() {
    return reinterpret_cast<const HandshakeMessage_Object_SensorsEntry_DoNotUse*>(
        &_HandshakeMessage_Object_SensorsEntry_DoNotUse_default_instance_);
  }
const ::google::protobuf::Message::ClassData* GetClassData() const final;
  friend struct ::TableStruct_Messaging_2eproto;
};
// -------------------------------------------------------------------

class ControlMessage_Object final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:click.protobuf.ControlMessage.Object) */ {
 public:
  inline ControlMessage_Object() : ControlMessage_Object(nullptr) {}
  ~ControlMessage_Object() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ControlMessage_Object(
      ::google::protobuf::internal::ConstantInitialized);

  inline ControlMessage_Object(const ControlMessage_Object& from) : ControlMessage_Object(nullptr, from) {}
  inline ControlMessage_Object(ControlMessage_Object&& from) noexcept
      : ControlMessage_Object(nullptr, std::move(from)) {}
  inline ControlMessage_Object& operator=(const ControlMessage_Object& from) {
    CopyFrom(from);
    return *this;
  }
  inline ControlMessage_Object& operator=(ControlMessage_Object&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ControlMessage_Object& default_instance() {
    return *internal_default_instance();
  }
  static inline const ControlMessage_Object* internal_default_instance() {
    return reinterpret_cast<const ControlMessage_Object*>(
        &_ControlMessage_Object_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 11;
  friend void swap(ControlMessage_Object& a, ControlMessage_Object& b) { a.Swap(&b); }
  inline void Swap(ControlMessage_Object* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ControlMessage_Object* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ControlMessage_Object* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<ControlMessage_Object>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ControlMessage_Object& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ControlMessage_Object& from) { ControlMessage_Object::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(ControlMessage_Object* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "click.protobuf.ControlMessage.Object"; }

 protected:
  explicit ControlMessage_Object(::google::protobuf::Arena* arena);
  ControlMessage_Object(::google::protobuf::Arena* arena, const ControlMessage_Object& from);
  ControlMessage_Object(::google::protobuf::Arena* arena, ControlMessage_Object&& from) noexcept
      : ControlMessage_Object(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kAnglesFieldNumber = 1,
    kAngularVelocitiesFieldNumber = 2,
    kTorquesFieldNumber = 3,
    kControlEventsFieldNumber = 4,
    kValuesFieldNumber = 5,
  };
  // repeated double angles = 1;
  int angles_size() const;
  private:
  int _internal_angles_size() const;

  public:
  void clear_angles() ;
  double angles(int index) const;
  void set_angles(int index, double value);
  void add_angles(double value);
  const ::google::protobuf::RepeatedField<double>& angles() const;
  ::google::protobuf::RepeatedField<double>* mutable_angles();

  private:
  const ::google::protobuf::RepeatedField<double>& _internal_angles() const;
  ::google::protobuf::RepeatedField<double>* _internal_mutable_angles();

  public:
  // repeated double angularVelocities = 2;
  int angularvelocities_size() const;
  private:
  int _internal_angularvelocities_size() const;

  public:
  void clear_angularvelocities() ;
  double angularvelocities(int index) const;
  void set_angularvelocities(int index, double value);
  void add_angularvelocities(double value);
  const ::google::protobuf::RepeatedField<double>& angularvelocities() const;
  ::google::protobuf::RepeatedField<double>* mutable_angularvelocities();

  private:
  const ::google::protobuf::RepeatedField<double>& _internal_angularvelocities() const;
  ::google::protobuf::RepeatedField<double>* _internal_mutable_angularvelocities();

  public:
  // repeated double torques = 3;
  int torques_size() const;
  private:
  int _internal_torques_size() const;

  public:
  void clear_torques() ;
  double torques(int index) const;
  void set_torques(int index, double value);
  void add_torques(double value);
  const ::google::protobuf::RepeatedField<double>& torques() const;
  ::google::protobuf::RepeatedField<double>* mutable_torques();

  private:
  const ::google::protobuf::RepeatedField<double>& _internal_torques() const;
  ::google::protobuf::RepeatedField<double>* _internal_mutable_torques();

  public:
  // map<string, bool> controlEvents = 4;
  int controlevents_size() const;
  private:
  int _internal_controlevents_size() const;

  public:
  void clear_controlevents() ;
  const ::google::protobuf::Map<std::string, bool>& controlevents() const;
  ::google::protobuf::Map<std::string, bool>* mutable_controlevents();

  private:
  const ::google::protobuf::Map<std::string, bool>& _internal_controlevents() const;
  ::google::protobuf::Map<std::string, bool>* _internal_mutable_controlevents();

  public:
  // repeated double values = 5;
  int values_size() const;
  private:
  int _internal_values_size() const;

  public:
  void clear_values() ;
  double values(int index) const;
  void set_values(int index, double value);
  void add_values(double value);
  const ::google::protobuf::RepeatedField<double>& values() const;
  ::google::protobuf::RepeatedField<double>* mutable_values();

  private:
  const ::google::protobuf::RepeatedField<double>& _internal_values() const;
  ::google::protobuf::RepeatedField<double>* _internal_mutable_values();

  public:
  // @@protoc_insertion_point(class_scope:click.protobuf.ControlMessage.Object)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 5, 1,
      58, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_ControlMessage_Object_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const ControlMessage_Object& from_msg);
    ::google::protobuf::RepeatedField<double> angles_;
    ::google::protobuf::RepeatedField<double> angularvelocities_;
    ::google::protobuf::RepeatedField<double> torques_;
    ::google::protobuf::internal::MapField<ControlMessage_Object_ControlEventsEntry_DoNotUse, std::string, bool,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
                      ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>
        controlevents_;
    ::google::protobuf::RepeatedField<double> values_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Messaging_2eproto;
};
// -------------------------------------------------------------------

class SensorMessage_Sensors final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:click.protobuf.SensorMessage.Sensors) */ {
 public:
  inline SensorMessage_Sensors() : SensorMessage_Sensors(nullptr) {}
  ~SensorMessage_Sensors() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR SensorMessage_Sensors(
      ::google::protobuf::internal::ConstantInitialized);

  inline SensorMessage_Sensors(const SensorMessage_Sensors& from) : SensorMessage_Sensors(nullptr, from) {}
  inline SensorMessage_Sensors(SensorMessage_Sensors&& from) noexcept
      : SensorMessage_Sensors(nullptr, std::move(from)) {}
  inline SensorMessage_Sensors& operator=(const SensorMessage_Sensors& from) {
    CopyFrom(from);
    return *this;
  }
  inline SensorMessage_Sensors& operator=(SensorMessage_Sensors&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SensorMessage_Sensors& default_instance() {
    return *internal_default_instance();
  }
  static inline const SensorMessage_Sensors* internal_default_instance() {
    return reinterpret_cast<const SensorMessage_Sensors*>(
        &_SensorMessage_Sensors_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 16;
  friend void swap(SensorMessage_Sensors& a, SensorMessage_Sensors& b) { a.Swap(&b); }
  inline void Swap(SensorMessage_Sensors* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SensorMessage_Sensors* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SensorMessage_Sensors* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<SensorMessage_Sensors>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SensorMessage_Sensors& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const SensorMessage_Sensors& from) { SensorMessage_Sensors::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(SensorMessage_Sensors* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "click.protobuf.SensorMessage.Sensors"; }

 protected:
  explicit SensorMessage_Sensors(::google::protobuf::Arena* arena);
  SensorMessage_Sensors(::google::protobuf::Arena* arena, const SensorMessage_Sensors& from);
  SensorMessage_Sensors(::google::protobuf::Arena* arena, SensorMessage_Sensors&& from) noexcept
      : SensorMessage_Sensors(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kSensorFieldNumber = 1,
  };
  // repeated .click.protobuf.SensorMessage.Sensor sensor = 1;
  int sensor_size() const;
  private:
  int _internal_sensor_size() const;

  public:
  void clear_sensor() ;
  ::click::protobuf::SensorMessage_Sensor* mutable_sensor(int index);
  ::google::protobuf::RepeatedPtrField<::click::protobuf::SensorMessage_Sensor>* mutable_sensor();

  private:
  const ::google::protobuf::RepeatedPtrField<::click::protobuf::SensorMessage_Sensor>& _internal_sensor() const;
  ::google::protobuf::RepeatedPtrField<::click::protobuf::SensorMessage_Sensor>* _internal_mutable_sensor();
  public:
  const ::click::protobuf::SensorMessage_Sensor& sensor(int index) const;
  ::click::protobuf::SensorMessage_Sensor* add_sensor();
  const ::google::protobuf::RepeatedPtrField<::click::protobuf::SensorMessage_Sensor>& sensor() const;
  // @@protoc_insertion_point(class_scope:click.protobuf.SensorMessage.Sensors)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_SensorMessage_Sensors_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const SensorMessage_Sensors& from_msg);
    ::google::protobuf::RepeatedPtrField< ::click::protobuf::SensorMessage_Sensor > sensor_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Messaging_2eproto;
};
// -------------------------------------------------------------------

class HandshakeMessage_Object final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:click.protobuf.HandshakeMessage.Object) */ {
 public:
  inline HandshakeMessage_Object() : HandshakeMessage_Object(nullptr) {}
  ~HandshakeMessage_Object() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR HandshakeMessage_Object(
      ::google::protobuf::internal::ConstantInitialized);

  inline HandshakeMessage_Object(const HandshakeMessage_Object& from) : HandshakeMessage_Object(nullptr, from) {}
  inline HandshakeMessage_Object(HandshakeMessage_Object&& from) noexcept
      : HandshakeMessage_Object(nullptr, std::move(from)) {}
  inline HandshakeMessage_Object& operator=(const HandshakeMessage_Object& from) {
    CopyFrom(from);
    return *this;
  }
  inline HandshakeMessage_Object& operator=(HandshakeMessage_Object&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const HandshakeMessage_Object& default_instance() {
    return *internal_default_instance();
  }
  static inline const HandshakeMessage_Object* internal_default_instance() {
    return reinterpret_cast<const HandshakeMessage_Object*>(
        &_HandshakeMessage_Object_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 6;
  friend void swap(HandshakeMessage_Object& a, HandshakeMessage_Object& b) { a.Swap(&b); }
  inline void Swap(HandshakeMessage_Object* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HandshakeMessage_Object* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  HandshakeMessage_Object* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<HandshakeMessage_Object>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const HandshakeMessage_Object& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const HandshakeMessage_Object& from) { HandshakeMessage_Object::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(HandshakeMessage_Object* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "click.protobuf.HandshakeMessage.Object"; }

 protected:
  explicit HandshakeMessage_Object(::google::protobuf::Arena* arena);
  HandshakeMessage_Object(::google::protobuf::Arena* arena, const HandshakeMessage_Object& from);
  HandshakeMessage_Object(::google::protobuf::Arena* arena, HandshakeMessage_Object&& from) noexcept
      : HandshakeMessage_Object(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kControlsInOrderFieldNumber = 1,
    kJointSensorsFieldNumber = 2,
    kControlEventsFieldNumber = 3,
    kSensorsFieldNumber = 4,
    kObjectSensorsFieldNumber = 6,
    kJointSensorsInOrderFieldNumber = 7,
    kControlTypesInOrderFieldNumber = 8,
  };
  // repeated string controlsInOrder = 1;
  int controlsinorder_size() const;
  private:
  int _internal_controlsinorder_size() const;

  public:
  void clear_controlsinorder() ;
  const std::string& controlsinorder(int index) const;
  std::string* mutable_controlsinorder(int index);
  void set_controlsinorder(int index, const std::string& value);
  void set_controlsinorder(int index, std::string&& value);
  void set_controlsinorder(int index, const char* value);
  void set_controlsinorder(int index, const char* value, std::size_t size);
  void set_controlsinorder(int index, absl::string_view value);
  std::string* add_controlsinorder();
  void add_controlsinorder(const std::string& value);
  void add_controlsinorder(std::string&& value);
  void add_controlsinorder(const char* value);
  void add_controlsinorder(const char* value, std::size_t size);
  void add_controlsinorder(absl::string_view value);
  const ::google::protobuf::RepeatedPtrField<std::string>& controlsinorder() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_controlsinorder();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_controlsinorder() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_controlsinorder();

  public:
  // repeated .click.protobuf.ValueType jointSensors = 2;
  int jointsensors_size() const;
  private:
  int _internal_jointsensors_size() const;

  public:
  void clear_jointsensors() ;
  public:
  ::click::protobuf::ValueType jointsensors(int index) const;
  void set_jointsensors(int index, ::click::protobuf::ValueType value);
  void add_jointsensors(::click::protobuf::ValueType value);
  const ::google::protobuf::RepeatedField<int>& jointsensors() const;
  ::google::protobuf::RepeatedField<int>* mutable_jointsensors();

  private:
  const ::google::protobuf::RepeatedField<int>& _internal_jointsensors() const;
  ::google::protobuf::RepeatedField<int>* _internal_mutable_jointsensors();

  public:
  // map<string, .click.protobuf.ValueType> controlEvents = 3;
  int controlevents_size() const;
  private:
  int _internal_controlevents_size() const;

  public:
  void clear_controlevents() ;
  const ::google::protobuf::Map<std::string, ::click::protobuf::ValueType>& controlevents() const;
  ::google::protobuf::Map<std::string, ::click::protobuf::ValueType>* mutable_controlevents();

  private:
  const ::google::protobuf::Map<std::string, ::click::protobuf::ValueType>& _internal_controlevents() const;
  ::google::protobuf::Map<std::string, ::click::protobuf::ValueType>* _internal_mutable_controlevents();

  public:
  // map<string, .click.protobuf.HandshakeMessage.Sensors> sensors = 4;
  int sensors_size() const;
  private:
  int _internal_sensors_size() const;

  public:
  void clear_sensors() ;
  const ::google::protobuf::Map<std::string, ::click::protobuf::HandshakeMessage_Sensors>& sensors() const;
  ::google::protobuf::Map<std::string, ::click::protobuf::HandshakeMessage_Sensors>* mutable_sensors();

  private:
  const ::google::protobuf::Map<std::string, ::click::protobuf::HandshakeMessage_Sensors>& _internal_sensors() const;
  ::google::protobuf::Map<std::string, ::click::protobuf::HandshakeMessage_Sensors>* _internal_mutable_sensors();

  public:
  // repeated .click.protobuf.ValueType objectSensors = 6;
  int objectsensors_size() const;
  private:
  int _internal_objectsensors_size() const;

  public:
  void clear_objectsensors() ;
  public:
  ::click::protobuf::ValueType objectsensors(int index) const;
  void set_objectsensors(int index, ::click::protobuf::ValueType value);
  void add_objectsensors(::click::protobuf::ValueType value);
  const ::google::protobuf::RepeatedField<int>& objectsensors() const;
  ::google::protobuf::RepeatedField<int>* mutable_objectsensors();

  private:
  const ::google::protobuf::RepeatedField<int>& _internal_objectsensors() const;
  ::google::protobuf::RepeatedField<int>* _internal_mutable_objectsensors();

  public:
  // repeated string jointSensorsInOrder = 7;
  int jointsensorsinorder_size() const;
  private:
  int _internal_jointsensorsinorder_size() const;

  public:
  void clear_jointsensorsinorder() ;
  const std::string& jointsensorsinorder(int index) const;
  std::string* mutable_jointsensorsinorder(int index);
  void set_jointsensorsinorder(int index, const std::string& value);
  void set_jointsensorsinorder(int index, std::string&& value);
  void set_jointsensorsinorder(int index, const char* value);
  void set_jointsensorsinorder(int index, const char* value, std::size_t size);
  void set_jointsensorsinorder(int index, absl::string_view value);
  std::string* add_jointsensorsinorder();
  void add_jointsensorsinorder(const std::string& value);
  void add_jointsensorsinorder(std::string&& value);
  void add_jointsensorsinorder(const char* value);
  void add_jointsensorsinorder(const char* value, std::size_t size);
  void add_jointsensorsinorder(absl::string_view value);
  const ::google::protobuf::RepeatedPtrField<std::string>& jointsensorsinorder() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_jointsensorsinorder();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_jointsensorsinorder() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_jointsensorsinorder();

  public:
  // repeated .click.protobuf.ValueType controlTypesInOrder = 8;
  int controltypesinorder_size() const;
  private:
  int _internal_controltypesinorder_size() const;

  public:
  void clear_controltypesinorder() ;
  public:
  ::click::protobuf::ValueType controltypesinorder(int index) const;
  void set_controltypesinorder(int index, ::click::protobuf::ValueType value);
  void add_controltypesinorder(::click::protobuf::ValueType value);
  const ::google::protobuf::RepeatedField<int>& controltypesinorder() const;
  ::google::protobuf::RepeatedField<int>* mutable_controltypesinorder();

  private:
  const ::google::protobuf::RepeatedField<int>& _internal_controltypesinorder() const;
  ::google::protobuf::RepeatedField<int>* _internal_mutable_controltypesinorder();

  public:
  // @@protoc_insertion_point(class_scope:click.protobuf.HandshakeMessage.Object)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 7, 3,
      101, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_HandshakeMessage_Object_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const HandshakeMessage_Object& from_msg);
    ::google::protobuf::RepeatedPtrField<std::string> controlsinorder_;
    ::google::protobuf::RepeatedField<int> jointsensors_;
    mutable ::google::protobuf::internal::CachedSize _jointsensors_cached_byte_size_;
    ::google::protobuf::internal::MapField<HandshakeMessage_Object_ControlEventsEntry_DoNotUse, std::string, ::click::protobuf::ValueType,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
                      ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>
        controlevents_;
    ::google::protobuf::internal::MapField<HandshakeMessage_Object_SensorsEntry_DoNotUse, std::string, ::click::protobuf::HandshakeMessage_Sensors,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
                      ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE>
        sensors_;
    ::google::protobuf::RepeatedField<int> objectsensors_;
    mutable ::google::protobuf::internal::CachedSize _objectsensors_cached_byte_size_;
    ::google::protobuf::RepeatedPtrField<std::string> jointsensorsinorder_;
    ::google::protobuf::RepeatedField<int> controltypesinorder_;
    mutable ::google::protobuf::internal::CachedSize _controltypesinorder_cached_byte_size_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Messaging_2eproto;
};
// -------------------------------------------------------------------

class ControlMessage_ObjectsEntry_DoNotUse final
    : public ::google::protobuf::internal::MapEntry<
          ControlMessage_ObjectsEntry_DoNotUse, std::string, ::click::protobuf::ControlMessage_Object,
          ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
          ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE> {
 public:
  using SuperType = ::google::protobuf::internal::MapEntry<
      ControlMessage_ObjectsEntry_DoNotUse, std::string, ::click::protobuf::ControlMessage_Object,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE>;
  ControlMessage_ObjectsEntry_DoNotUse();
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ControlMessage_ObjectsEntry_DoNotUse(
      ::google::protobuf::internal::ConstantInitialized);
  explicit ControlMessage_ObjectsEntry_DoNotUse(::google::protobuf::Arena* arena);
  static const ControlMessage_ObjectsEntry_DoNotUse* internal_default_instance() {
    return reinterpret_cast<const ControlMessage_ObjectsEntry_DoNotUse*>(
        &_ControlMessage_ObjectsEntry_DoNotUse_default_instance_);
  }
const ::google::protobuf::Message::ClassData* GetClassData() const final;
  friend struct ::TableStruct_Messaging_2eproto;
};
// -------------------------------------------------------------------

class SensorMessage_Object_SensorsEntry_DoNotUse final
    : public ::google::protobuf::internal::MapEntry<
          SensorMessage_Object_SensorsEntry_DoNotUse, std::string, ::click::protobuf::SensorMessage_Sensors,
          ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
          ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE> {
 public:
  using SuperType = ::google::protobuf::internal::MapEntry<
      SensorMessage_Object_SensorsEntry_DoNotUse, std::string, ::click::protobuf::SensorMessage_Sensors,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE>;
  SensorMessage_Object_SensorsEntry_DoNotUse();
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR SensorMessage_Object_SensorsEntry_DoNotUse(
      ::google::protobuf::internal::ConstantInitialized);
  explicit SensorMessage_Object_SensorsEntry_DoNotUse(::google::protobuf::Arena* arena);
  static const SensorMessage_Object_SensorsEntry_DoNotUse* internal_default_instance() {
    return reinterpret_cast<const SensorMessage_Object_SensorsEntry_DoNotUse*>(
        &_SensorMessage_Object_SensorsEntry_DoNotUse_default_instance_);
  }
const ::google::protobuf::Message::ClassData* GetClassData() const final;
  friend struct ::TableStruct_Messaging_2eproto;
};
// -------------------------------------------------------------------

class HandshakeMessage_ObjectsEntry_DoNotUse final
    : public ::google::protobuf::internal::MapEntry<
          HandshakeMessage_ObjectsEntry_DoNotUse, std::string, ::click::protobuf::HandshakeMessage_Object,
          ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
          ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE> {
 public:
  using SuperType = ::google::protobuf::internal::MapEntry<
      HandshakeMessage_ObjectsEntry_DoNotUse, std::string, ::click::protobuf::HandshakeMessage_Object,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE>;
  HandshakeMessage_ObjectsEntry_DoNotUse();
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR HandshakeMessage_ObjectsEntry_DoNotUse(
      ::google::protobuf::internal::ConstantInitialized);
  explicit HandshakeMessage_ObjectsEntry_DoNotUse(::google::protobuf::Arena* arena);
  static const HandshakeMessage_ObjectsEntry_DoNotUse* internal_default_instance() {
    return reinterpret_cast<const HandshakeMessage_ObjectsEntry_DoNotUse*>(
        &_HandshakeMessage_ObjectsEntry_DoNotUse_default_instance_);
  }
const ::google::protobuf::Message::ClassData* GetClassData() const final;
  friend struct ::TableStruct_Messaging_2eproto;
};
// -------------------------------------------------------------------

class ControlMessage final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:click.protobuf.ControlMessage) */ {
 public:
  inline ControlMessage() : ControlMessage(nullptr) {}
  ~ControlMessage() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ControlMessage(
      ::google::protobuf::internal::ConstantInitialized);

  inline ControlMessage(const ControlMessage& from) : ControlMessage(nullptr, from) {}
  inline ControlMessage(ControlMessage&& from) noexcept
      : ControlMessage(nullptr, std::move(from)) {}
  inline ControlMessage& operator=(const ControlMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline ControlMessage& operator=(ControlMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ControlMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const ControlMessage* internal_default_instance() {
    return reinterpret_cast<const ControlMessage*>(
        &_ControlMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 13;
  friend void swap(ControlMessage& a, ControlMessage& b) { a.Swap(&b); }
  inline void Swap(ControlMessage* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ControlMessage* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ControlMessage* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<ControlMessage>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ControlMessage& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ControlMessage& from) { ControlMessage::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(ControlMessage* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "click.protobuf.ControlMessage"; }

 protected:
  explicit ControlMessage(::google::protobuf::Arena* arena);
  ControlMessage(::google::protobuf::Arena* arena, const ControlMessage& from);
  ControlMessage(::google::protobuf::Arena* arena, ControlMessage&& from) noexcept
      : ControlMessage(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------
  using Object = ControlMessage_Object;

  // accessors -------------------------------------------------------
  enum : int {
    kObjectsFieldNumber = 2,
    kMessageTypeFieldNumber = 1,
  };
  // map<string, .click.protobuf.ControlMessage.Object> objects = 2;
  int objects_size() const;
  private:
  int _internal_objects_size() const;

  public:
  void clear_objects() ;
  const ::google::protobuf::Map<std::string, ::click::protobuf::ControlMessage_Object>& objects() const;
  ::google::protobuf::Map<std::string, ::click::protobuf::ControlMessage_Object>* mutable_objects();

  private:
  const ::google::protobuf::Map<std::string, ::click::protobuf::ControlMessage_Object>& _internal_objects() const;
  ::google::protobuf::Map<std::string, ::click::protobuf::ControlMessage_Object>* _internal_mutable_objects();

  public:
  // .click.protobuf.MessageType messageType = 1;
  void clear_messagetype() ;
  ::click::protobuf::MessageType messagetype() const;
  void set_messagetype(::click::protobuf::MessageType value);

  private:
  ::click::protobuf::MessageType _internal_messagetype() const;
  void _internal_set_messagetype(::click::protobuf::MessageType value);

  public:
  // @@protoc_insertion_point(class_scope:click.protobuf.ControlMessage)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 2, 2,
      45, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_ControlMessage_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const ControlMessage& from_msg);
    ::google::protobuf::internal::MapField<ControlMessage_ObjectsEntry_DoNotUse, std::string, ::click::protobuf::ControlMessage_Object,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
                      ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE>
        objects_;
    int messagetype_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Messaging_2eproto;
};
// -------------------------------------------------------------------

class SensorMessage_Object final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:click.protobuf.SensorMessage.Object) */ {
 public:
  inline SensorMessage_Object() : SensorMessage_Object(nullptr) {}
  ~SensorMessage_Object() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR SensorMessage_Object(
      ::google::protobuf::internal::ConstantInitialized);

  inline SensorMessage_Object(const SensorMessage_Object& from) : SensorMessage_Object(nullptr, from) {}
  inline SensorMessage_Object(SensorMessage_Object&& from) noexcept
      : SensorMessage_Object(nullptr, std::move(from)) {}
  inline SensorMessage_Object& operator=(const SensorMessage_Object& from) {
    CopyFrom(from);
    return *this;
  }
  inline SensorMessage_Object& operator=(SensorMessage_Object&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SensorMessage_Object& default_instance() {
    return *internal_default_instance();
  }
  static inline const SensorMessage_Object* internal_default_instance() {
    return reinterpret_cast<const SensorMessage_Object*>(
        &_SensorMessage_Object_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 18;
  friend void swap(SensorMessage_Object& a, SensorMessage_Object& b) { a.Swap(&b); }
  inline void Swap(SensorMessage_Object* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SensorMessage_Object* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SensorMessage_Object* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<SensorMessage_Object>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SensorMessage_Object& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const SensorMessage_Object& from) { SensorMessage_Object::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(SensorMessage_Object* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "click.protobuf.SensorMessage.Object"; }

 protected:
  explicit SensorMessage_Object(::google::protobuf::Arena* arena);
  SensorMessage_Object(::google::protobuf::Arena* arena, const SensorMessage_Object& from);
  SensorMessage_Object(::google::protobuf::Arena* arena, SensorMessage_Object&& from) noexcept
      : SensorMessage_Object(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kAngleSensorsFieldNumber = 1,
    kAngularVelocitySensorsFieldNumber = 2,
    kTorqueSensorsFieldNumber = 3,
    kObjectSensorsFieldNumber = 4,
    kForceSensorsFieldNumber = 5,
    kSensorsFieldNumber = 6,
  };
  // repeated double angleSensors = 1;
  int anglesensors_size() const;
  private:
  int _internal_anglesensors_size() const;

  public:
  void clear_anglesensors() ;
  double anglesensors(int index) const;
  void set_anglesensors(int index, double value);
  void add_anglesensors(double value);
  const ::google::protobuf::RepeatedField<double>& anglesensors() const;
  ::google::protobuf::RepeatedField<double>* mutable_anglesensors();

  private:
  const ::google::protobuf::RepeatedField<double>& _internal_anglesensors() const;
  ::google::protobuf::RepeatedField<double>* _internal_mutable_anglesensors();

  public:
  // repeated double angularVelocitySensors = 2;
  int angularvelocitysensors_size() const;
  private:
  int _internal_angularvelocitysensors_size() const;

  public:
  void clear_angularvelocitysensors() ;
  double angularvelocitysensors(int index) const;
  void set_angularvelocitysensors(int index, double value);
  void add_angularvelocitysensors(double value);
  const ::google::protobuf::RepeatedField<double>& angularvelocitysensors() const;
  ::google::protobuf::RepeatedField<double>* mutable_angularvelocitysensors();

  private:
  const ::google::protobuf::RepeatedField<double>& _internal_angularvelocitysensors() const;
  ::google::protobuf::RepeatedField<double>* _internal_mutable_angularvelocitysensors();

  public:
  // repeated double torqueSensors = 3;
  int torquesensors_size() const;
  private:
  int _internal_torquesensors_size() const;

  public:
  void clear_torquesensors() ;
  double torquesensors(int index) const;
  void set_torquesensors(int index, double value);
  void add_torquesensors(double value);
  const ::google::protobuf::RepeatedField<double>& torquesensors() const;
  ::google::protobuf::RepeatedField<double>* mutable_torquesensors();

  private:
  const ::google::protobuf::RepeatedField<double>& _internal_torquesensors() const;
  ::google::protobuf::RepeatedField<double>* _internal_mutable_torquesensors();

  public:
  // repeated .click.protobuf.SensorMessage.Sensor objectSensors = 4;
  int objectsensors_size() const;
  private:
  int _internal_objectsensors_size() const;

  public:
  void clear_objectsensors() ;
  ::click::protobuf::SensorMessage_Sensor* mutable_objectsensors(int index);
  ::google::protobuf::RepeatedPtrField<::click::protobuf::SensorMessage_Sensor>* mutable_objectsensors();

  private:
  const ::google::protobuf::RepeatedPtrField<::click::protobuf::SensorMessage_Sensor>& _internal_objectsensors() const;
  ::google::protobuf::RepeatedPtrField<::click::protobuf::SensorMessage_Sensor>* _internal_mutable_objectsensors();
  public:
  const ::click::protobuf::SensorMessage_Sensor& objectsensors(int index) const;
  ::click::protobuf::SensorMessage_Sensor* add_objectsensors();
  const ::google::protobuf::RepeatedPtrField<::click::protobuf::SensorMessage_Sensor>& objectsensors() const;
  // repeated .click.protobuf.SensorMessage.Vec3 forceSensors = 5;
  int forcesensors_size() const;
  private:
  int _internal_forcesensors_size() const;

  public:
  void clear_forcesensors() ;
  ::click::protobuf::SensorMessage_Vec3* mutable_forcesensors(int index);
  ::google::protobuf::RepeatedPtrField<::click::protobuf::SensorMessage_Vec3>* mutable_forcesensors();

  private:
  const ::google::protobuf::RepeatedPtrField<::click::protobuf::SensorMessage_Vec3>& _internal_forcesensors() const;
  ::google::protobuf::RepeatedPtrField<::click::protobuf::SensorMessage_Vec3>* _internal_mutable_forcesensors();
  public:
  const ::click::protobuf::SensorMessage_Vec3& forcesensors(int index) const;
  ::click::protobuf::SensorMessage_Vec3* add_forcesensors();
  const ::google::protobuf::RepeatedPtrField<::click::protobuf::SensorMessage_Vec3>& forcesensors() const;
  // map<string, .click.protobuf.SensorMessage.Sensors> sensors = 6;
  int sensors_size() const;
  private:
  int _internal_sensors_size() const;

  public:
  void clear_sensors() ;
  const ::google::protobuf::Map<std::string, ::click::protobuf::SensorMessage_Sensors>& sensors() const;
  ::google::protobuf::Map<std::string, ::click::protobuf::SensorMessage_Sensors>* mutable_sensors();

  private:
  const ::google::protobuf::Map<std::string, ::click::protobuf::SensorMessage_Sensors>& _internal_sensors() const;
  ::google::protobuf::Map<std::string, ::click::protobuf::SensorMessage_Sensors>* _internal_mutable_sensors();

  public:
  // @@protoc_insertion_point(class_scope:click.protobuf.SensorMessage.Object)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 6, 4,
      51, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_SensorMessage_Object_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const SensorMessage_Object& from_msg);
    ::google::protobuf::RepeatedField<double> anglesensors_;
    ::google::protobuf::RepeatedField<double> angularvelocitysensors_;
    ::google::protobuf::RepeatedField<double> torquesensors_;
    ::google::protobuf::RepeatedPtrField< ::click::protobuf::SensorMessage_Sensor > objectsensors_;
    ::google::protobuf::RepeatedPtrField< ::click::protobuf::SensorMessage_Vec3 > forcesensors_;
    ::google::protobuf::internal::MapField<SensorMessage_Object_SensorsEntry_DoNotUse, std::string, ::click::protobuf::SensorMessage_Sensors,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
                      ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE>
        sensors_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Messaging_2eproto;
};
// -------------------------------------------------------------------

class HandshakeMessage final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:click.protobuf.HandshakeMessage) */ {
 public:
  inline HandshakeMessage() : HandshakeMessage(nullptr) {}
  ~HandshakeMessage() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR HandshakeMessage(
      ::google::protobuf::internal::ConstantInitialized);

  inline HandshakeMessage(const HandshakeMessage& from) : HandshakeMessage(nullptr, from) {}
  inline HandshakeMessage(HandshakeMessage&& from) noexcept
      : HandshakeMessage(nullptr, std::move(from)) {}
  inline HandshakeMessage& operator=(const HandshakeMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline HandshakeMessage& operator=(HandshakeMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const HandshakeMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const HandshakeMessage* internal_default_instance() {
    return reinterpret_cast<const HandshakeMessage*>(
        &_HandshakeMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 9;
  friend void swap(HandshakeMessage& a, HandshakeMessage& b) { a.Swap(&b); }
  inline void Swap(HandshakeMessage* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HandshakeMessage* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  HandshakeMessage* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<HandshakeMessage>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const HandshakeMessage& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const HandshakeMessage& from) { HandshakeMessage::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(HandshakeMessage* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "click.protobuf.HandshakeMessage"; }

 protected:
  explicit HandshakeMessage(::google::protobuf::Arena* arena);
  HandshakeMessage(::google::protobuf::Arena* arena, const HandshakeMessage& from);
  HandshakeMessage(::google::protobuf::Arena* arena, HandshakeMessage&& from) noexcept
      : HandshakeMessage(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------
  using Sensors = HandshakeMessage_Sensors;
  using Object = HandshakeMessage_Object;
  using SimulationSettings = HandshakeMessage_SimulationSettings;

  // accessors -------------------------------------------------------
  enum : int {
    kObjectsFieldNumber = 4,
    kSimSettingsFieldNumber = 5,
    kMessageTypeFieldNumber = 1,
    kVersionFieldNumber = 2,
    kControlTypeFieldNumber = 3,
  };
  // map<string, .click.protobuf.HandshakeMessage.Object> objects = 4;
  int objects_size() const;
  private:
  int _internal_objects_size() const;

  public:
  void clear_objects() ;
  const ::google::protobuf::Map<std::string, ::click::protobuf::HandshakeMessage_Object>& objects() const;
  ::google::protobuf::Map<std::string, ::click::protobuf::HandshakeMessage_Object>* mutable_objects();

  private:
  const ::google::protobuf::Map<std::string, ::click::protobuf::HandshakeMessage_Object>& _internal_objects() const;
  ::google::protobuf::Map<std::string, ::click::protobuf::HandshakeMessage_Object>* _internal_mutable_objects();

  public:
  // .click.protobuf.HandshakeMessage.SimulationSettings simSettings = 5;
  bool has_simsettings() const;
  void clear_simsettings() ;
  const ::click::protobuf::HandshakeMessage_SimulationSettings& simsettings() const;
  PROTOBUF_NODISCARD ::click::protobuf::HandshakeMessage_SimulationSettings* release_simsettings();
  ::click::protobuf::HandshakeMessage_SimulationSettings* mutable_simsettings();
  void set_allocated_simsettings(::click::protobuf::HandshakeMessage_SimulationSettings* value);
  void unsafe_arena_set_allocated_simsettings(::click::protobuf::HandshakeMessage_SimulationSettings* value);
  ::click::protobuf::HandshakeMessage_SimulationSettings* unsafe_arena_release_simsettings();

  private:
  const ::click::protobuf::HandshakeMessage_SimulationSettings& _internal_simsettings() const;
  ::click::protobuf::HandshakeMessage_SimulationSettings* _internal_mutable_simsettings();

  public:
  // .click.protobuf.MessageType messageType = 1;
  void clear_messagetype() ;
  ::click::protobuf::MessageType messagetype() const;
  void set_messagetype(::click::protobuf::MessageType value);

  private:
  ::click::protobuf::MessageType _internal_messagetype() const;
  void _internal_set_messagetype(::click::protobuf::MessageType value);

  public:
  // .click.protobuf.Version version = 2;
  void clear_version() ;
  ::click::protobuf::Version version() const;
  void set_version(::click::protobuf::Version value);

  private:
  ::click::protobuf::Version _internal_version() const;
  void _internal_set_version(::click::protobuf::Version value);

  public:
  // .click.protobuf.ValueType controlType = 3;
  void clear_controltype() ;
  ::click::protobuf::ValueType controltype() const;
  void set_controltype(::click::protobuf::ValueType value);

  private:
  ::click::protobuf::ValueType _internal_controltype() const;
  void _internal_set_controltype(::click::protobuf::ValueType value);

  public:
  // @@protoc_insertion_point(class_scope:click.protobuf.HandshakeMessage)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 5, 3,
      47, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_HandshakeMessage_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const HandshakeMessage& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::MapField<HandshakeMessage_ObjectsEntry_DoNotUse, std::string, ::click::protobuf::HandshakeMessage_Object,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
                      ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE>
        objects_;
    ::click::protobuf::HandshakeMessage_SimulationSettings* simsettings_;
    int messagetype_;
    int version_;
    int controltype_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Messaging_2eproto;
};
// -------------------------------------------------------------------

class SensorMessage_ObjectsEntry_DoNotUse final
    : public ::google::protobuf::internal::MapEntry<
          SensorMessage_ObjectsEntry_DoNotUse, std::string, ::click::protobuf::SensorMessage_Object,
          ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
          ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE> {
 public:
  using SuperType = ::google::protobuf::internal::MapEntry<
      SensorMessage_ObjectsEntry_DoNotUse, std::string, ::click::protobuf::SensorMessage_Object,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE>;
  SensorMessage_ObjectsEntry_DoNotUse();
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR SensorMessage_ObjectsEntry_DoNotUse(
      ::google::protobuf::internal::ConstantInitialized);
  explicit SensorMessage_ObjectsEntry_DoNotUse(::google::protobuf::Arena* arena);
  static const SensorMessage_ObjectsEntry_DoNotUse* internal_default_instance() {
    return reinterpret_cast<const SensorMessage_ObjectsEntry_DoNotUse*>(
        &_SensorMessage_ObjectsEntry_DoNotUse_default_instance_);
  }
const ::google::protobuf::Message::ClassData* GetClassData() const final;
  friend struct ::TableStruct_Messaging_2eproto;
};
// -------------------------------------------------------------------

class SensorMessage final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:click.protobuf.SensorMessage) */ {
 public:
  inline SensorMessage() : SensorMessage(nullptr) {}
  ~SensorMessage() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR SensorMessage(
      ::google::protobuf::internal::ConstantInitialized);

  inline SensorMessage(const SensorMessage& from) : SensorMessage(nullptr, from) {}
  inline SensorMessage(SensorMessage&& from) noexcept
      : SensorMessage(nullptr, std::move(from)) {}
  inline SensorMessage& operator=(const SensorMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline SensorMessage& operator=(SensorMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SensorMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const SensorMessage* internal_default_instance() {
    return reinterpret_cast<const SensorMessage*>(
        &_SensorMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 21;
  friend void swap(SensorMessage& a, SensorMessage& b) { a.Swap(&b); }
  inline void Swap(SensorMessage* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SensorMessage* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SensorMessage* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<SensorMessage>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SensorMessage& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const SensorMessage& from) { SensorMessage::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(SensorMessage* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "click.protobuf.SensorMessage"; }

 protected:
  explicit SensorMessage(::google::protobuf::Arena* arena);
  SensorMessage(::google::protobuf::Arena* arena, const SensorMessage& from);
  SensorMessage(::google::protobuf::Arena* arena, SensorMessage&& from) noexcept
      : SensorMessage(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------
  using Vec3 = SensorMessage_Vec3;
  using Sensor = SensorMessage_Sensor;
  using Sensors = SensorMessage_Sensors;
  using Object = SensorMessage_Object;
  using SimulationVariables = SensorMessage_SimulationVariables;

  // accessors -------------------------------------------------------
  enum : int {
    kObjectsFieldNumber = 3,
    kSimVarsFieldNumber = 4,
    kMessageTypeFieldNumber = 1,
  };
  // map<string, .click.protobuf.SensorMessage.Object> objects = 3;
  int objects_size() const;
  private:
  int _internal_objects_size() const;

  public:
  void clear_objects() ;
  const ::google::protobuf::Map<std::string, ::click::protobuf::SensorMessage_Object>& objects() const;
  ::google::protobuf::Map<std::string, ::click::protobuf::SensorMessage_Object>* mutable_objects();

  private:
  const ::google::protobuf::Map<std::string, ::click::protobuf::SensorMessage_Object>& _internal_objects() const;
  ::google::protobuf::Map<std::string, ::click::protobuf::SensorMessage_Object>* _internal_mutable_objects();

  public:
  // .click.protobuf.SensorMessage.SimulationVariables simVars = 4;
  bool has_simvars() const;
  void clear_simvars() ;
  const ::click::protobuf::SensorMessage_SimulationVariables& simvars() const;
  PROTOBUF_NODISCARD ::click::protobuf::SensorMessage_SimulationVariables* release_simvars();
  ::click::protobuf::SensorMessage_SimulationVariables* mutable_simvars();
  void set_allocated_simvars(::click::protobuf::SensorMessage_SimulationVariables* value);
  void unsafe_arena_set_allocated_simvars(::click::protobuf::SensorMessage_SimulationVariables* value);
  ::click::protobuf::SensorMessage_SimulationVariables* unsafe_arena_release_simvars();

  private:
  const ::click::protobuf::SensorMessage_SimulationVariables& _internal_simvars() const;
  ::click::protobuf::SensorMessage_SimulationVariables* _internal_mutable_simvars();

  public:
  // .click.protobuf.MessageType messageType = 1;
  void clear_messagetype() ;
  ::click::protobuf::MessageType messagetype() const;
  void set_messagetype(::click::protobuf::MessageType value);

  private:
  ::click::protobuf::MessageType _internal_messagetype() const;
  void _internal_set_messagetype(::click::protobuf::MessageType value);

  public:
  // @@protoc_insertion_point(class_scope:click.protobuf.SensorMessage)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 3, 3,
      44, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_SensorMessage_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const SensorMessage& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::MapField<SensorMessage_ObjectsEntry_DoNotUse, std::string, ::click::protobuf::SensorMessage_Object,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
                      ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE>
        objects_;
    ::click::protobuf::SensorMessage_SimulationVariables* simvars_;
    int messagetype_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Messaging_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// Message

// .click.protobuf.MessageType messageType = 1;
inline void Message::clear_messagetype() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.messagetype_ = 0;
}
inline ::click::protobuf::MessageType Message::messagetype() const {
  // @@protoc_insertion_point(field_get:click.protobuf.Message.messageType)
  return _internal_messagetype();
}
inline void Message::set_messagetype(::click::protobuf::MessageType value) {
  _internal_set_messagetype(value);
  // @@protoc_insertion_point(field_set:click.protobuf.Message.messageType)
}
inline ::click::protobuf::MessageType Message::_internal_messagetype() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::click::protobuf::MessageType>(_impl_.messagetype_);
}
inline void Message::_internal_set_messagetype(::click::protobuf::MessageType value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.messagetype_ = value;
}

// int32 id = 2;
inline void Message::clear_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_ = 0;
}
inline ::int32_t Message::id() const {
  // @@protoc_insertion_point(field_get:click.protobuf.Message.id)
  return _internal_id();
}
inline void Message::set_id(::int32_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:click.protobuf.Message.id)
}
inline ::int32_t Message::_internal_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.id_;
}
inline void Message::_internal_set_id(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_ = value;
}

// -------------------------------------------------------------------

// HandshakeInitMessage

// .click.protobuf.MessageType messageType = 1;
inline void HandshakeInitMessage::clear_messagetype() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.messagetype_ = 0;
}
inline ::click::protobuf::MessageType HandshakeInitMessage::messagetype() const {
  // @@protoc_insertion_point(field_get:click.protobuf.HandshakeInitMessage.messageType)
  return _internal_messagetype();
}
inline void HandshakeInitMessage::set_messagetype(::click::protobuf::MessageType value) {
  _internal_set_messagetype(value);
  // @@protoc_insertion_point(field_set:click.protobuf.HandshakeInitMessage.messageType)
}
inline ::click::protobuf::MessageType HandshakeInitMessage::_internal_messagetype() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::click::protobuf::MessageType>(_impl_.messagetype_);
}
inline void HandshakeInitMessage::_internal_set_messagetype(::click::protobuf::MessageType value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.messagetype_ = value;
}

// .click.protobuf.Version version = 2;
inline void HandshakeInitMessage::clear_version() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.version_ = 0;
}
inline ::click::protobuf::Version HandshakeInitMessage::version() const {
  // @@protoc_insertion_point(field_get:click.protobuf.HandshakeInitMessage.version)
  return _internal_version();
}
inline void HandshakeInitMessage::set_version(::click::protobuf::Version value) {
  _internal_set_version(value);
  // @@protoc_insertion_point(field_set:click.protobuf.HandshakeInitMessage.version)
}
inline ::click::protobuf::Version HandshakeInitMessage::_internal_version() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::click::protobuf::Version>(_impl_.version_);
}
inline void HandshakeInitMessage::_internal_set_version(::click::protobuf::Version value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.version_ = value;
}

// -------------------------------------------------------------------

// SensorRequestMessage

// .click.protobuf.MessageType messageType = 1;
inline void SensorRequestMessage::clear_messagetype() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.messagetype_ = 0;
}
inline ::click::protobuf::MessageType SensorRequestMessage::messagetype() const {
  // @@protoc_insertion_point(field_get:click.protobuf.SensorRequestMessage.messageType)
  return _internal_messagetype();
}
inline void SensorRequestMessage::set_messagetype(::click::protobuf::MessageType value) {
  _internal_set_messagetype(value);
  // @@protoc_insertion_point(field_set:click.protobuf.SensorRequestMessage.messageType)
}
inline ::click::protobuf::MessageType SensorRequestMessage::_internal_messagetype() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::click::protobuf::MessageType>(_impl_.messagetype_);
}
inline void SensorRequestMessage::_internal_set_messagetype(::click::protobuf::MessageType value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.messagetype_ = value;
}

// -------------------------------------------------------------------

// HandshakeMessage_Sensors

// repeated .click.protobuf.ValueType types = 1;
inline int HandshakeMessage_Sensors::_internal_types_size() const {
  return _internal_types().size();
}
inline int HandshakeMessage_Sensors::types_size() const {
  return _internal_types_size();
}
inline void HandshakeMessage_Sensors::clear_types() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.types_.Clear();
}
inline ::click::protobuf::ValueType HandshakeMessage_Sensors::types(int index) const {
  // @@protoc_insertion_point(field_get:click.protobuf.HandshakeMessage.Sensors.types)
  return static_cast<::click::protobuf::ValueType>(_internal_types().Get(index));
}
inline void HandshakeMessage_Sensors::set_types(int index, ::click::protobuf::ValueType value) {
  _internal_mutable_types()->Set(index, value);
  // @@protoc_insertion_point(field_set:click.protobuf.HandshakeMessage.Sensors.types)
}
inline void HandshakeMessage_Sensors::add_types(::click::protobuf::ValueType value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_types()->Add(value);
  // @@protoc_insertion_point(field_add:click.protobuf.HandshakeMessage.Sensors.types)
}
inline const ::google::protobuf::RepeatedField<int>& HandshakeMessage_Sensors::types() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:click.protobuf.HandshakeMessage.Sensors.types)
  return _internal_types();
}
inline ::google::protobuf::RepeatedField<int>* HandshakeMessage_Sensors::mutable_types()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:click.protobuf.HandshakeMessage.Sensors.types)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_types();
}
inline const ::google::protobuf::RepeatedField<int>& HandshakeMessage_Sensors::_internal_types()
    const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.types_;
}
inline ::google::protobuf::RepeatedField<int>* HandshakeMessage_Sensors::_internal_mutable_types() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.types_;
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// HandshakeMessage_Object

// repeated string controlsInOrder = 1;
inline int HandshakeMessage_Object::_internal_controlsinorder_size() const {
  return _internal_controlsinorder().size();
}
inline int HandshakeMessage_Object::controlsinorder_size() const {
  return _internal_controlsinorder_size();
}
inline void HandshakeMessage_Object::clear_controlsinorder() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.controlsinorder_.Clear();
}
inline std::string* HandshakeMessage_Object::add_controlsinorder()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  std::string* _s = _internal_mutable_controlsinorder()->Add();
  // @@protoc_insertion_point(field_add_mutable:click.protobuf.HandshakeMessage.Object.controlsInOrder)
  return _s;
}
inline const std::string& HandshakeMessage_Object::controlsinorder(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:click.protobuf.HandshakeMessage.Object.controlsInOrder)
  return _internal_controlsinorder().Get(index);
}
inline std::string* HandshakeMessage_Object::mutable_controlsinorder(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:click.protobuf.HandshakeMessage.Object.controlsInOrder)
  return _internal_mutable_controlsinorder()->Mutable(index);
}
inline void HandshakeMessage_Object::set_controlsinorder(int index, const std::string& value) {
  _internal_mutable_controlsinorder()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:click.protobuf.HandshakeMessage.Object.controlsInOrder)
}
inline void HandshakeMessage_Object::set_controlsinorder(int index, std::string&& value) {
  _internal_mutable_controlsinorder()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:click.protobuf.HandshakeMessage.Object.controlsInOrder)
}
inline void HandshakeMessage_Object::set_controlsinorder(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_controlsinorder()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:click.protobuf.HandshakeMessage.Object.controlsInOrder)
}
inline void HandshakeMessage_Object::set_controlsinorder(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_controlsinorder()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:click.protobuf.HandshakeMessage.Object.controlsInOrder)
}
inline void HandshakeMessage_Object::set_controlsinorder(int index, absl::string_view value) {
  _internal_mutable_controlsinorder()->Mutable(index)->assign(
      value.data(), value.size());
  // @@protoc_insertion_point(field_set_string_piece:click.protobuf.HandshakeMessage.Object.controlsInOrder)
}
inline void HandshakeMessage_Object::add_controlsinorder(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_controlsinorder()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:click.protobuf.HandshakeMessage.Object.controlsInOrder)
}
inline void HandshakeMessage_Object::add_controlsinorder(std::string&& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_controlsinorder()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:click.protobuf.HandshakeMessage.Object.controlsInOrder)
}
inline void HandshakeMessage_Object::add_controlsinorder(const char* value) {
  ABSL_DCHECK(value != nullptr);
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_controlsinorder()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:click.protobuf.HandshakeMessage.Object.controlsInOrder)
}
inline void HandshakeMessage_Object::add_controlsinorder(const char* value, std::size_t size) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_controlsinorder()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:click.protobuf.HandshakeMessage.Object.controlsInOrder)
}
inline void HandshakeMessage_Object::add_controlsinorder(absl::string_view value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_controlsinorder()->Add()->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_add_string_piece:click.protobuf.HandshakeMessage.Object.controlsInOrder)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
HandshakeMessage_Object::controlsinorder() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:click.protobuf.HandshakeMessage.Object.controlsInOrder)
  return _internal_controlsinorder();
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
HandshakeMessage_Object::mutable_controlsinorder() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:click.protobuf.HandshakeMessage.Object.controlsInOrder)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_controlsinorder();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
HandshakeMessage_Object::_internal_controlsinorder() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.controlsinorder_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
HandshakeMessage_Object::_internal_mutable_controlsinorder() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.controlsinorder_;
}

// repeated .click.protobuf.ValueType controlTypesInOrder = 8;
inline int HandshakeMessage_Object::_internal_controltypesinorder_size() const {
  return _internal_controltypesinorder().size();
}
inline int HandshakeMessage_Object::controltypesinorder_size() const {
  return _internal_controltypesinorder_size();
}
inline void HandshakeMessage_Object::clear_controltypesinorder() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.controltypesinorder_.Clear();
}
inline ::click::protobuf::ValueType HandshakeMessage_Object::controltypesinorder(int index) const {
  // @@protoc_insertion_point(field_get:click.protobuf.HandshakeMessage.Object.controlTypesInOrder)
  return static_cast<::click::protobuf::ValueType>(_internal_controltypesinorder().Get(index));
}
inline void HandshakeMessage_Object::set_controltypesinorder(int index, ::click::protobuf::ValueType value) {
  _internal_mutable_controltypesinorder()->Set(index, value);
  // @@protoc_insertion_point(field_set:click.protobuf.HandshakeMessage.Object.controlTypesInOrder)
}
inline void HandshakeMessage_Object::add_controltypesinorder(::click::protobuf::ValueType value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_controltypesinorder()->Add(value);
  // @@protoc_insertion_point(field_add:click.protobuf.HandshakeMessage.Object.controlTypesInOrder)
}
inline const ::google::protobuf::RepeatedField<int>& HandshakeMessage_Object::controltypesinorder() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:click.protobuf.HandshakeMessage.Object.controlTypesInOrder)
  return _internal_controltypesinorder();
}
inline ::google::protobuf::RepeatedField<int>* HandshakeMessage_Object::mutable_controltypesinorder()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:click.protobuf.HandshakeMessage.Object.controlTypesInOrder)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_controltypesinorder();
}
inline const ::google::protobuf::RepeatedField<int>& HandshakeMessage_Object::_internal_controltypesinorder()
    const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.controltypesinorder_;
}
inline ::google::protobuf::RepeatedField<int>* HandshakeMessage_Object::_internal_mutable_controltypesinorder() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.controltypesinorder_;
}

// repeated string jointSensorsInOrder = 7;
inline int HandshakeMessage_Object::_internal_jointsensorsinorder_size() const {
  return _internal_jointsensorsinorder().size();
}
inline int HandshakeMessage_Object::jointsensorsinorder_size() const {
  return _internal_jointsensorsinorder_size();
}
inline void HandshakeMessage_Object::clear_jointsensorsinorder() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.jointsensorsinorder_.Clear();
}
inline std::string* HandshakeMessage_Object::add_jointsensorsinorder()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  std::string* _s = _internal_mutable_jointsensorsinorder()->Add();
  // @@protoc_insertion_point(field_add_mutable:click.protobuf.HandshakeMessage.Object.jointSensorsInOrder)
  return _s;
}
inline const std::string& HandshakeMessage_Object::jointsensorsinorder(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:click.protobuf.HandshakeMessage.Object.jointSensorsInOrder)
  return _internal_jointsensorsinorder().Get(index);
}
inline std::string* HandshakeMessage_Object::mutable_jointsensorsinorder(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:click.protobuf.HandshakeMessage.Object.jointSensorsInOrder)
  return _internal_mutable_jointsensorsinorder()->Mutable(index);
}
inline void HandshakeMessage_Object::set_jointsensorsinorder(int index, const std::string& value) {
  _internal_mutable_jointsensorsinorder()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:click.protobuf.HandshakeMessage.Object.jointSensorsInOrder)
}
inline void HandshakeMessage_Object::set_jointsensorsinorder(int index, std::string&& value) {
  _internal_mutable_jointsensorsinorder()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:click.protobuf.HandshakeMessage.Object.jointSensorsInOrder)
}
inline void HandshakeMessage_Object::set_jointsensorsinorder(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_jointsensorsinorder()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:click.protobuf.HandshakeMessage.Object.jointSensorsInOrder)
}
inline void HandshakeMessage_Object::set_jointsensorsinorder(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_jointsensorsinorder()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:click.protobuf.HandshakeMessage.Object.jointSensorsInOrder)
}
inline void HandshakeMessage_Object::set_jointsensorsinorder(int index, absl::string_view value) {
  _internal_mutable_jointsensorsinorder()->Mutable(index)->assign(
      value.data(), value.size());
  // @@protoc_insertion_point(field_set_string_piece:click.protobuf.HandshakeMessage.Object.jointSensorsInOrder)
}
inline void HandshakeMessage_Object::add_jointsensorsinorder(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_jointsensorsinorder()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:click.protobuf.HandshakeMessage.Object.jointSensorsInOrder)
}
inline void HandshakeMessage_Object::add_jointsensorsinorder(std::string&& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_jointsensorsinorder()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:click.protobuf.HandshakeMessage.Object.jointSensorsInOrder)
}
inline void HandshakeMessage_Object::add_jointsensorsinorder(const char* value) {
  ABSL_DCHECK(value != nullptr);
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_jointsensorsinorder()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:click.protobuf.HandshakeMessage.Object.jointSensorsInOrder)
}
inline void HandshakeMessage_Object::add_jointsensorsinorder(const char* value, std::size_t size) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_jointsensorsinorder()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:click.protobuf.HandshakeMessage.Object.jointSensorsInOrder)
}
inline void HandshakeMessage_Object::add_jointsensorsinorder(absl::string_view value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_jointsensorsinorder()->Add()->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_add_string_piece:click.protobuf.HandshakeMessage.Object.jointSensorsInOrder)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
HandshakeMessage_Object::jointsensorsinorder() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:click.protobuf.HandshakeMessage.Object.jointSensorsInOrder)
  return _internal_jointsensorsinorder();
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
HandshakeMessage_Object::mutable_jointsensorsinorder() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:click.protobuf.HandshakeMessage.Object.jointSensorsInOrder)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_jointsensorsinorder();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
HandshakeMessage_Object::_internal_jointsensorsinorder() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.jointsensorsinorder_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
HandshakeMessage_Object::_internal_mutable_jointsensorsinorder() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.jointsensorsinorder_;
}

// repeated .click.protobuf.ValueType jointSensors = 2;
inline int HandshakeMessage_Object::_internal_jointsensors_size() const {
  return _internal_jointsensors().size();
}
inline int HandshakeMessage_Object::jointsensors_size() const {
  return _internal_jointsensors_size();
}
inline void HandshakeMessage_Object::clear_jointsensors() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.jointsensors_.Clear();
}
inline ::click::protobuf::ValueType HandshakeMessage_Object::jointsensors(int index) const {
  // @@protoc_insertion_point(field_get:click.protobuf.HandshakeMessage.Object.jointSensors)
  return static_cast<::click::protobuf::ValueType>(_internal_jointsensors().Get(index));
}
inline void HandshakeMessage_Object::set_jointsensors(int index, ::click::protobuf::ValueType value) {
  _internal_mutable_jointsensors()->Set(index, value);
  // @@protoc_insertion_point(field_set:click.protobuf.HandshakeMessage.Object.jointSensors)
}
inline void HandshakeMessage_Object::add_jointsensors(::click::protobuf::ValueType value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_jointsensors()->Add(value);
  // @@protoc_insertion_point(field_add:click.protobuf.HandshakeMessage.Object.jointSensors)
}
inline const ::google::protobuf::RepeatedField<int>& HandshakeMessage_Object::jointsensors() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:click.protobuf.HandshakeMessage.Object.jointSensors)
  return _internal_jointsensors();
}
inline ::google::protobuf::RepeatedField<int>* HandshakeMessage_Object::mutable_jointsensors()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:click.protobuf.HandshakeMessage.Object.jointSensors)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_jointsensors();
}
inline const ::google::protobuf::RepeatedField<int>& HandshakeMessage_Object::_internal_jointsensors()
    const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.jointsensors_;
}
inline ::google::protobuf::RepeatedField<int>* HandshakeMessage_Object::_internal_mutable_jointsensors() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.jointsensors_;
}

// map<string, .click.protobuf.ValueType> controlEvents = 3;
inline int HandshakeMessage_Object::_internal_controlevents_size() const {
  return _internal_controlevents().size();
}
inline int HandshakeMessage_Object::controlevents_size() const {
  return _internal_controlevents_size();
}
inline void HandshakeMessage_Object::clear_controlevents() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.controlevents_.Clear();
}
inline const ::google::protobuf::Map<std::string, ::click::protobuf::ValueType>& HandshakeMessage_Object::_internal_controlevents() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.controlevents_.GetMap();
}
inline const ::google::protobuf::Map<std::string, ::click::protobuf::ValueType>& HandshakeMessage_Object::controlevents() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_map:click.protobuf.HandshakeMessage.Object.controlEvents)
  return _internal_controlevents();
}
inline ::google::protobuf::Map<std::string, ::click::protobuf::ValueType>* HandshakeMessage_Object::_internal_mutable_controlevents() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.controlevents_.MutableMap();
}
inline ::google::protobuf::Map<std::string, ::click::protobuf::ValueType>* HandshakeMessage_Object::mutable_controlevents() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_map:click.protobuf.HandshakeMessage.Object.controlEvents)
  return _internal_mutable_controlevents();
}

// map<string, .click.protobuf.HandshakeMessage.Sensors> sensors = 4;
inline int HandshakeMessage_Object::_internal_sensors_size() const {
  return _internal_sensors().size();
}
inline int HandshakeMessage_Object::sensors_size() const {
  return _internal_sensors_size();
}
inline void HandshakeMessage_Object::clear_sensors() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.sensors_.Clear();
}
inline const ::google::protobuf::Map<std::string, ::click::protobuf::HandshakeMessage_Sensors>& HandshakeMessage_Object::_internal_sensors() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.sensors_.GetMap();
}
inline const ::google::protobuf::Map<std::string, ::click::protobuf::HandshakeMessage_Sensors>& HandshakeMessage_Object::sensors() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_map:click.protobuf.HandshakeMessage.Object.sensors)
  return _internal_sensors();
}
inline ::google::protobuf::Map<std::string, ::click::protobuf::HandshakeMessage_Sensors>* HandshakeMessage_Object::_internal_mutable_sensors() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.sensors_.MutableMap();
}
inline ::google::protobuf::Map<std::string, ::click::protobuf::HandshakeMessage_Sensors>* HandshakeMessage_Object::mutable_sensors() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_map:click.protobuf.HandshakeMessage.Object.sensors)
  return _internal_mutable_sensors();
}

// repeated .click.protobuf.ValueType objectSensors = 6;
inline int HandshakeMessage_Object::_internal_objectsensors_size() const {
  return _internal_objectsensors().size();
}
inline int HandshakeMessage_Object::objectsensors_size() const {
  return _internal_objectsensors_size();
}
inline void HandshakeMessage_Object::clear_objectsensors() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.objectsensors_.Clear();
}
inline ::click::protobuf::ValueType HandshakeMessage_Object::objectsensors(int index) const {
  // @@protoc_insertion_point(field_get:click.protobuf.HandshakeMessage.Object.objectSensors)
  return static_cast<::click::protobuf::ValueType>(_internal_objectsensors().Get(index));
}
inline void HandshakeMessage_Object::set_objectsensors(int index, ::click::protobuf::ValueType value) {
  _internal_mutable_objectsensors()->Set(index, value);
  // @@protoc_insertion_point(field_set:click.protobuf.HandshakeMessage.Object.objectSensors)
}
inline void HandshakeMessage_Object::add_objectsensors(::click::protobuf::ValueType value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_objectsensors()->Add(value);
  // @@protoc_insertion_point(field_add:click.protobuf.HandshakeMessage.Object.objectSensors)
}
inline const ::google::protobuf::RepeatedField<int>& HandshakeMessage_Object::objectsensors() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:click.protobuf.HandshakeMessage.Object.objectSensors)
  return _internal_objectsensors();
}
inline ::google::protobuf::RepeatedField<int>* HandshakeMessage_Object::mutable_objectsensors()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:click.protobuf.HandshakeMessage.Object.objectSensors)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_objectsensors();
}
inline const ::google::protobuf::RepeatedField<int>& HandshakeMessage_Object::_internal_objectsensors()
    const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.objectsensors_;
}
inline ::google::protobuf::RepeatedField<int>* HandshakeMessage_Object::_internal_mutable_objectsensors() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.objectsensors_;
}

// -------------------------------------------------------------------

// HandshakeMessage_SimulationSettings

// double timeStep = 1;
inline void HandshakeMessage_SimulationSettings::clear_timestep() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.timestep_ = 0;
}
inline double HandshakeMessage_SimulationSettings::timestep() const {
  // @@protoc_insertion_point(field_get:click.protobuf.HandshakeMessage.SimulationSettings.timeStep)
  return _internal_timestep();
}
inline void HandshakeMessage_SimulationSettings::set_timestep(double value) {
  _internal_set_timestep(value);
  // @@protoc_insertion_point(field_set:click.protobuf.HandshakeMessage.SimulationSettings.timeStep)
}
inline double HandshakeMessage_SimulationSettings::_internal_timestep() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.timestep_;
}
inline void HandshakeMessage_SimulationSettings::_internal_set_timestep(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.timestep_ = value;
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// HandshakeMessage

// .click.protobuf.MessageType messageType = 1;
inline void HandshakeMessage::clear_messagetype() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.messagetype_ = 0;
}
inline ::click::protobuf::MessageType HandshakeMessage::messagetype() const {
  // @@protoc_insertion_point(field_get:click.protobuf.HandshakeMessage.messageType)
  return _internal_messagetype();
}
inline void HandshakeMessage::set_messagetype(::click::protobuf::MessageType value) {
  _internal_set_messagetype(value);
  // @@protoc_insertion_point(field_set:click.protobuf.HandshakeMessage.messageType)
}
inline ::click::protobuf::MessageType HandshakeMessage::_internal_messagetype() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::click::protobuf::MessageType>(_impl_.messagetype_);
}
inline void HandshakeMessage::_internal_set_messagetype(::click::protobuf::MessageType value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.messagetype_ = value;
}

// .click.protobuf.Version version = 2;
inline void HandshakeMessage::clear_version() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.version_ = 0;
}
inline ::click::protobuf::Version HandshakeMessage::version() const {
  // @@protoc_insertion_point(field_get:click.protobuf.HandshakeMessage.version)
  return _internal_version();
}
inline void HandshakeMessage::set_version(::click::protobuf::Version value) {
  _internal_set_version(value);
  // @@protoc_insertion_point(field_set:click.protobuf.HandshakeMessage.version)
}
inline ::click::protobuf::Version HandshakeMessage::_internal_version() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::click::protobuf::Version>(_impl_.version_);
}
inline void HandshakeMessage::_internal_set_version(::click::protobuf::Version value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.version_ = value;
}

// .click.protobuf.ValueType controlType = 3;
inline void HandshakeMessage::clear_controltype() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.controltype_ = 0;
}
inline ::click::protobuf::ValueType HandshakeMessage::controltype() const {
  // @@protoc_insertion_point(field_get:click.protobuf.HandshakeMessage.controlType)
  return _internal_controltype();
}
inline void HandshakeMessage::set_controltype(::click::protobuf::ValueType value) {
  _internal_set_controltype(value);
  // @@protoc_insertion_point(field_set:click.protobuf.HandshakeMessage.controlType)
}
inline ::click::protobuf::ValueType HandshakeMessage::_internal_controltype() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::click::protobuf::ValueType>(_impl_.controltype_);
}
inline void HandshakeMessage::_internal_set_controltype(::click::protobuf::ValueType value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.controltype_ = value;
}

// map<string, .click.protobuf.HandshakeMessage.Object> objects = 4;
inline int HandshakeMessage::_internal_objects_size() const {
  return _internal_objects().size();
}
inline int HandshakeMessage::objects_size() const {
  return _internal_objects_size();
}
inline void HandshakeMessage::clear_objects() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.objects_.Clear();
}
inline const ::google::protobuf::Map<std::string, ::click::protobuf::HandshakeMessage_Object>& HandshakeMessage::_internal_objects() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.objects_.GetMap();
}
inline const ::google::protobuf::Map<std::string, ::click::protobuf::HandshakeMessage_Object>& HandshakeMessage::objects() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_map:click.protobuf.HandshakeMessage.objects)
  return _internal_objects();
}
inline ::google::protobuf::Map<std::string, ::click::protobuf::HandshakeMessage_Object>* HandshakeMessage::_internal_mutable_objects() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.objects_.MutableMap();
}
inline ::google::protobuf::Map<std::string, ::click::protobuf::HandshakeMessage_Object>* HandshakeMessage::mutable_objects() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_map:click.protobuf.HandshakeMessage.objects)
  return _internal_mutable_objects();
}

// .click.protobuf.HandshakeMessage.SimulationSettings simSettings = 5;
inline bool HandshakeMessage::has_simsettings() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.simsettings_ != nullptr);
  return value;
}
inline void HandshakeMessage::clear_simsettings() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.simsettings_ != nullptr) _impl_.simsettings_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::click::protobuf::HandshakeMessage_SimulationSettings& HandshakeMessage::_internal_simsettings() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::click::protobuf::HandshakeMessage_SimulationSettings* p = _impl_.simsettings_;
  return p != nullptr ? *p : reinterpret_cast<const ::click::protobuf::HandshakeMessage_SimulationSettings&>(::click::protobuf::_HandshakeMessage_SimulationSettings_default_instance_);
}
inline const ::click::protobuf::HandshakeMessage_SimulationSettings& HandshakeMessage::simsettings() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:click.protobuf.HandshakeMessage.simSettings)
  return _internal_simsettings();
}
inline void HandshakeMessage::unsafe_arena_set_allocated_simsettings(::click::protobuf::HandshakeMessage_SimulationSettings* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.simsettings_);
  }
  _impl_.simsettings_ = reinterpret_cast<::click::protobuf::HandshakeMessage_SimulationSettings*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:click.protobuf.HandshakeMessage.simSettings)
}
inline ::click::protobuf::HandshakeMessage_SimulationSettings* HandshakeMessage::release_simsettings() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::click::protobuf::HandshakeMessage_SimulationSettings* released = _impl_.simsettings_;
  _impl_.simsettings_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::click::protobuf::HandshakeMessage_SimulationSettings* HandshakeMessage::unsafe_arena_release_simsettings() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:click.protobuf.HandshakeMessage.simSettings)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::click::protobuf::HandshakeMessage_SimulationSettings* temp = _impl_.simsettings_;
  _impl_.simsettings_ = nullptr;
  return temp;
}
inline ::click::protobuf::HandshakeMessage_SimulationSettings* HandshakeMessage::_internal_mutable_simsettings() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.simsettings_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::click::protobuf::HandshakeMessage_SimulationSettings>(GetArena());
    _impl_.simsettings_ = reinterpret_cast<::click::protobuf::HandshakeMessage_SimulationSettings*>(p);
  }
  return _impl_.simsettings_;
}
inline ::click::protobuf::HandshakeMessage_SimulationSettings* HandshakeMessage::mutable_simsettings() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::click::protobuf::HandshakeMessage_SimulationSettings* _msg = _internal_mutable_simsettings();
  // @@protoc_insertion_point(field_mutable:click.protobuf.HandshakeMessage.simSettings)
  return _msg;
}
inline void HandshakeMessage::set_allocated_simsettings(::click::protobuf::HandshakeMessage_SimulationSettings* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.simsettings_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.simsettings_ = reinterpret_cast<::click::protobuf::HandshakeMessage_SimulationSettings*>(value);
  // @@protoc_insertion_point(field_set_allocated:click.protobuf.HandshakeMessage.simSettings)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// ControlMessage_Object

// repeated double angles = 1;
inline int ControlMessage_Object::_internal_angles_size() const {
  return _internal_angles().size();
}
inline int ControlMessage_Object::angles_size() const {
  return _internal_angles_size();
}
inline void ControlMessage_Object::clear_angles() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.angles_.Clear();
}
inline double ControlMessage_Object::angles(int index) const {
  // @@protoc_insertion_point(field_get:click.protobuf.ControlMessage.Object.angles)
  return _internal_angles().Get(index);
}
inline void ControlMessage_Object::set_angles(int index, double value) {
  _internal_mutable_angles()->Set(index, value);
  // @@protoc_insertion_point(field_set:click.protobuf.ControlMessage.Object.angles)
}
inline void ControlMessage_Object::add_angles(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_angles()->Add(value);
  // @@protoc_insertion_point(field_add:click.protobuf.ControlMessage.Object.angles)
}
inline const ::google::protobuf::RepeatedField<double>& ControlMessage_Object::angles() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:click.protobuf.ControlMessage.Object.angles)
  return _internal_angles();
}
inline ::google::protobuf::RepeatedField<double>* ControlMessage_Object::mutable_angles()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:click.protobuf.ControlMessage.Object.angles)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_angles();
}
inline const ::google::protobuf::RepeatedField<double>&
ControlMessage_Object::_internal_angles() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.angles_;
}
inline ::google::protobuf::RepeatedField<double>* ControlMessage_Object::_internal_mutable_angles() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.angles_;
}

// repeated double angularVelocities = 2;
inline int ControlMessage_Object::_internal_angularvelocities_size() const {
  return _internal_angularvelocities().size();
}
inline int ControlMessage_Object::angularvelocities_size() const {
  return _internal_angularvelocities_size();
}
inline void ControlMessage_Object::clear_angularvelocities() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.angularvelocities_.Clear();
}
inline double ControlMessage_Object::angularvelocities(int index) const {
  // @@protoc_insertion_point(field_get:click.protobuf.ControlMessage.Object.angularVelocities)
  return _internal_angularvelocities().Get(index);
}
inline void ControlMessage_Object::set_angularvelocities(int index, double value) {
  _internal_mutable_angularvelocities()->Set(index, value);
  // @@protoc_insertion_point(field_set:click.protobuf.ControlMessage.Object.angularVelocities)
}
inline void ControlMessage_Object::add_angularvelocities(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_angularvelocities()->Add(value);
  // @@protoc_insertion_point(field_add:click.protobuf.ControlMessage.Object.angularVelocities)
}
inline const ::google::protobuf::RepeatedField<double>& ControlMessage_Object::angularvelocities() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:click.protobuf.ControlMessage.Object.angularVelocities)
  return _internal_angularvelocities();
}
inline ::google::protobuf::RepeatedField<double>* ControlMessage_Object::mutable_angularvelocities()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:click.protobuf.ControlMessage.Object.angularVelocities)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_angularvelocities();
}
inline const ::google::protobuf::RepeatedField<double>&
ControlMessage_Object::_internal_angularvelocities() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.angularvelocities_;
}
inline ::google::protobuf::RepeatedField<double>* ControlMessage_Object::_internal_mutable_angularvelocities() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.angularvelocities_;
}

// repeated double torques = 3;
inline int ControlMessage_Object::_internal_torques_size() const {
  return _internal_torques().size();
}
inline int ControlMessage_Object::torques_size() const {
  return _internal_torques_size();
}
inline void ControlMessage_Object::clear_torques() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.torques_.Clear();
}
inline double ControlMessage_Object::torques(int index) const {
  // @@protoc_insertion_point(field_get:click.protobuf.ControlMessage.Object.torques)
  return _internal_torques().Get(index);
}
inline void ControlMessage_Object::set_torques(int index, double value) {
  _internal_mutable_torques()->Set(index, value);
  // @@protoc_insertion_point(field_set:click.protobuf.ControlMessage.Object.torques)
}
inline void ControlMessage_Object::add_torques(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_torques()->Add(value);
  // @@protoc_insertion_point(field_add:click.protobuf.ControlMessage.Object.torques)
}
inline const ::google::protobuf::RepeatedField<double>& ControlMessage_Object::torques() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:click.protobuf.ControlMessage.Object.torques)
  return _internal_torques();
}
inline ::google::protobuf::RepeatedField<double>* ControlMessage_Object::mutable_torques()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:click.protobuf.ControlMessage.Object.torques)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_torques();
}
inline const ::google::protobuf::RepeatedField<double>&
ControlMessage_Object::_internal_torques() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.torques_;
}
inline ::google::protobuf::RepeatedField<double>* ControlMessage_Object::_internal_mutable_torques() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.torques_;
}

// repeated double values = 5;
inline int ControlMessage_Object::_internal_values_size() const {
  return _internal_values().size();
}
inline int ControlMessage_Object::values_size() const {
  return _internal_values_size();
}
inline void ControlMessage_Object::clear_values() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.values_.Clear();
}
inline double ControlMessage_Object::values(int index) const {
  // @@protoc_insertion_point(field_get:click.protobuf.ControlMessage.Object.values)
  return _internal_values().Get(index);
}
inline void ControlMessage_Object::set_values(int index, double value) {
  _internal_mutable_values()->Set(index, value);
  // @@protoc_insertion_point(field_set:click.protobuf.ControlMessage.Object.values)
}
inline void ControlMessage_Object::add_values(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_values()->Add(value);
  // @@protoc_insertion_point(field_add:click.protobuf.ControlMessage.Object.values)
}
inline const ::google::protobuf::RepeatedField<double>& ControlMessage_Object::values() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:click.protobuf.ControlMessage.Object.values)
  return _internal_values();
}
inline ::google::protobuf::RepeatedField<double>* ControlMessage_Object::mutable_values()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:click.protobuf.ControlMessage.Object.values)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_values();
}
inline const ::google::protobuf::RepeatedField<double>&
ControlMessage_Object::_internal_values() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.values_;
}
inline ::google::protobuf::RepeatedField<double>* ControlMessage_Object::_internal_mutable_values() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.values_;
}

// map<string, bool> controlEvents = 4;
inline int ControlMessage_Object::_internal_controlevents_size() const {
  return _internal_controlevents().size();
}
inline int ControlMessage_Object::controlevents_size() const {
  return _internal_controlevents_size();
}
inline void ControlMessage_Object::clear_controlevents() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.controlevents_.Clear();
}
inline const ::google::protobuf::Map<std::string, bool>& ControlMessage_Object::_internal_controlevents() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.controlevents_.GetMap();
}
inline const ::google::protobuf::Map<std::string, bool>& ControlMessage_Object::controlevents() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_map:click.protobuf.ControlMessage.Object.controlEvents)
  return _internal_controlevents();
}
inline ::google::protobuf::Map<std::string, bool>* ControlMessage_Object::_internal_mutable_controlevents() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.controlevents_.MutableMap();
}
inline ::google::protobuf::Map<std::string, bool>* ControlMessage_Object::mutable_controlevents() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_map:click.protobuf.ControlMessage.Object.controlEvents)
  return _internal_mutable_controlevents();
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// ControlMessage

// .click.protobuf.MessageType messageType = 1;
inline void ControlMessage::clear_messagetype() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.messagetype_ = 0;
}
inline ::click::protobuf::MessageType ControlMessage::messagetype() const {
  // @@protoc_insertion_point(field_get:click.protobuf.ControlMessage.messageType)
  return _internal_messagetype();
}
inline void ControlMessage::set_messagetype(::click::protobuf::MessageType value) {
  _internal_set_messagetype(value);
  // @@protoc_insertion_point(field_set:click.protobuf.ControlMessage.messageType)
}
inline ::click::protobuf::MessageType ControlMessage::_internal_messagetype() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::click::protobuf::MessageType>(_impl_.messagetype_);
}
inline void ControlMessage::_internal_set_messagetype(::click::protobuf::MessageType value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.messagetype_ = value;
}

// map<string, .click.protobuf.ControlMessage.Object> objects = 2;
inline int ControlMessage::_internal_objects_size() const {
  return _internal_objects().size();
}
inline int ControlMessage::objects_size() const {
  return _internal_objects_size();
}
inline void ControlMessage::clear_objects() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.objects_.Clear();
}
inline const ::google::protobuf::Map<std::string, ::click::protobuf::ControlMessage_Object>& ControlMessage::_internal_objects() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.objects_.GetMap();
}
inline const ::google::protobuf::Map<std::string, ::click::protobuf::ControlMessage_Object>& ControlMessage::objects() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_map:click.protobuf.ControlMessage.objects)
  return _internal_objects();
}
inline ::google::protobuf::Map<std::string, ::click::protobuf::ControlMessage_Object>* ControlMessage::_internal_mutable_objects() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.objects_.MutableMap();
}
inline ::google::protobuf::Map<std::string, ::click::protobuf::ControlMessage_Object>* ControlMessage::mutable_objects() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_map:click.protobuf.ControlMessage.objects)
  return _internal_mutable_objects();
}

// -------------------------------------------------------------------

// SensorMessage_Vec3

// repeated double arr = 1;
inline int SensorMessage_Vec3::_internal_arr_size() const {
  return _internal_arr().size();
}
inline int SensorMessage_Vec3::arr_size() const {
  return _internal_arr_size();
}
inline void SensorMessage_Vec3::clear_arr() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.arr_.Clear();
}
inline double SensorMessage_Vec3::arr(int index) const {
  // @@protoc_insertion_point(field_get:click.protobuf.SensorMessage.Vec3.arr)
  return _internal_arr().Get(index);
}
inline void SensorMessage_Vec3::set_arr(int index, double value) {
  _internal_mutable_arr()->Set(index, value);
  // @@protoc_insertion_point(field_set:click.protobuf.SensorMessage.Vec3.arr)
}
inline void SensorMessage_Vec3::add_arr(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_arr()->Add(value);
  // @@protoc_insertion_point(field_add:click.protobuf.SensorMessage.Vec3.arr)
}
inline const ::google::protobuf::RepeatedField<double>& SensorMessage_Vec3::arr() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:click.protobuf.SensorMessage.Vec3.arr)
  return _internal_arr();
}
inline ::google::protobuf::RepeatedField<double>* SensorMessage_Vec3::mutable_arr()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:click.protobuf.SensorMessage.Vec3.arr)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_arr();
}
inline const ::google::protobuf::RepeatedField<double>&
SensorMessage_Vec3::_internal_arr() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.arr_;
}
inline ::google::protobuf::RepeatedField<double>* SensorMessage_Vec3::_internal_mutable_arr() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.arr_;
}

// -------------------------------------------------------------------

// SensorMessage_Sensor

// double angle = 1;
inline bool SensorMessage_Sensor::has_angle() const {
  return value_case() == kAngle;
}
inline void SensorMessage_Sensor::set_has_angle() {
  _impl_._oneof_case_[0] = kAngle;
}
inline void SensorMessage_Sensor::clear_angle() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value_case() == kAngle) {
    _impl_.value_.angle_ = 0;
    clear_has_value();
  }
}
inline double SensorMessage_Sensor::angle() const {
  // @@protoc_insertion_point(field_get:click.protobuf.SensorMessage.Sensor.angle)
  return _internal_angle();
}
inline void SensorMessage_Sensor::set_angle(double value) {
  if (value_case() != kAngle) {
    clear_value();
    set_has_angle();
  }
  _impl_.value_.angle_ = value;
  // @@protoc_insertion_point(field_set:click.protobuf.SensorMessage.Sensor.angle)
}
inline double SensorMessage_Sensor::_internal_angle() const {
  if (value_case() == kAngle) {
    return _impl_.value_.angle_;
  }
  return 0;
}

// double angularVelocity1d = 2;
inline bool SensorMessage_Sensor::has_angularvelocity1d() const {
  return value_case() == kAngularVelocity1D;
}
inline void SensorMessage_Sensor::set_has_angularvelocity1d() {
  _impl_._oneof_case_[0] = kAngularVelocity1D;
}
inline void SensorMessage_Sensor::clear_angularvelocity1d() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value_case() == kAngularVelocity1D) {
    _impl_.value_.angularvelocity1d_ = 0;
    clear_has_value();
  }
}
inline double SensorMessage_Sensor::angularvelocity1d() const {
  // @@protoc_insertion_point(field_get:click.protobuf.SensorMessage.Sensor.angularVelocity1d)
  return _internal_angularvelocity1d();
}
inline void SensorMessage_Sensor::set_angularvelocity1d(double value) {
  if (value_case() != kAngularVelocity1D) {
    clear_value();
    set_has_angularvelocity1d();
  }
  _impl_.value_.angularvelocity1d_ = value;
  // @@protoc_insertion_point(field_set:click.protobuf.SensorMessage.Sensor.angularVelocity1d)
}
inline double SensorMessage_Sensor::_internal_angularvelocity1d() const {
  if (value_case() == kAngularVelocity1D) {
    return _impl_.value_.angularvelocity1d_;
  }
  return 0;
}

// double torque1d = 3;
inline bool SensorMessage_Sensor::has_torque1d() const {
  return value_case() == kTorque1D;
}
inline void SensorMessage_Sensor::set_has_torque1d() {
  _impl_._oneof_case_[0] = kTorque1D;
}
inline void SensorMessage_Sensor::clear_torque1d() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value_case() == kTorque1D) {
    _impl_.value_.torque1d_ = 0;
    clear_has_value();
  }
}
inline double SensorMessage_Sensor::torque1d() const {
  // @@protoc_insertion_point(field_get:click.protobuf.SensorMessage.Sensor.torque1d)
  return _internal_torque1d();
}
inline void SensorMessage_Sensor::set_torque1d(double value) {
  if (value_case() != kTorque1D) {
    clear_value();
    set_has_torque1d();
  }
  _impl_.value_.torque1d_ = value;
  // @@protoc_insertion_point(field_set:click.protobuf.SensorMessage.Sensor.torque1d)
}
inline double SensorMessage_Sensor::_internal_torque1d() const {
  if (value_case() == kTorque1D) {
    return _impl_.value_.torque1d_;
  }
  return 0;
}

// .click.protobuf.SensorMessage.Vec3 position = 4;
inline bool SensorMessage_Sensor::has_position() const {
  return value_case() == kPosition;
}
inline bool SensorMessage_Sensor::_internal_has_position() const {
  return value_case() == kPosition;
}
inline void SensorMessage_Sensor::set_has_position() {
  _impl_._oneof_case_[0] = kPosition;
}
inline void SensorMessage_Sensor::clear_position() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value_case() == kPosition) {
    if (GetArena() == nullptr) {
      delete _impl_.value_.position_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.value_.position_);
    }
    clear_has_value();
  }
}
inline ::click::protobuf::SensorMessage_Vec3* SensorMessage_Sensor::release_position() {
  // @@protoc_insertion_point(field_release:click.protobuf.SensorMessage.Sensor.position)
  if (value_case() == kPosition) {
    clear_has_value();
    auto* temp = _impl_.value_.position_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.value_.position_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::click::protobuf::SensorMessage_Vec3& SensorMessage_Sensor::_internal_position() const {
  return value_case() == kPosition ? *_impl_.value_.position_ : reinterpret_cast<::click::protobuf::SensorMessage_Vec3&>(::click::protobuf::_SensorMessage_Vec3_default_instance_);
}
inline const ::click::protobuf::SensorMessage_Vec3& SensorMessage_Sensor::position() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:click.protobuf.SensorMessage.Sensor.position)
  return _internal_position();
}
inline ::click::protobuf::SensorMessage_Vec3* SensorMessage_Sensor::unsafe_arena_release_position() {
  // @@protoc_insertion_point(field_unsafe_arena_release:click.protobuf.SensorMessage.Sensor.position)
  if (value_case() == kPosition) {
    clear_has_value();
    auto* temp = _impl_.value_.position_;
    _impl_.value_.position_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SensorMessage_Sensor::unsafe_arena_set_allocated_position(::click::protobuf::SensorMessage_Vec3* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_value();
  if (value) {
    set_has_position();
    _impl_.value_.position_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:click.protobuf.SensorMessage.Sensor.position)
}
inline ::click::protobuf::SensorMessage_Vec3* SensorMessage_Sensor::_internal_mutable_position() {
  if (value_case() != kPosition) {
    clear_value();
    set_has_position();
    _impl_.value_.position_ =
        ::google::protobuf::Message::DefaultConstruct<::click::protobuf::SensorMessage_Vec3>(GetArena());
  }
  return _impl_.value_.position_;
}
inline ::click::protobuf::SensorMessage_Vec3* SensorMessage_Sensor::mutable_position() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::click::protobuf::SensorMessage_Vec3* _msg = _internal_mutable_position();
  // @@protoc_insertion_point(field_mutable:click.protobuf.SensorMessage.Sensor.position)
  return _msg;
}

// .click.protobuf.SensorMessage.Vec3 rpy = 5;
inline bool SensorMessage_Sensor::has_rpy() const {
  return value_case() == kRpy;
}
inline bool SensorMessage_Sensor::_internal_has_rpy() const {
  return value_case() == kRpy;
}
inline void SensorMessage_Sensor::set_has_rpy() {
  _impl_._oneof_case_[0] = kRpy;
}
inline void SensorMessage_Sensor::clear_rpy() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value_case() == kRpy) {
    if (GetArena() == nullptr) {
      delete _impl_.value_.rpy_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.value_.rpy_);
    }
    clear_has_value();
  }
}
inline ::click::protobuf::SensorMessage_Vec3* SensorMessage_Sensor::release_rpy() {
  // @@protoc_insertion_point(field_release:click.protobuf.SensorMessage.Sensor.rpy)
  if (value_case() == kRpy) {
    clear_has_value();
    auto* temp = _impl_.value_.rpy_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.value_.rpy_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::click::protobuf::SensorMessage_Vec3& SensorMessage_Sensor::_internal_rpy() const {
  return value_case() == kRpy ? *_impl_.value_.rpy_ : reinterpret_cast<::click::protobuf::SensorMessage_Vec3&>(::click::protobuf::_SensorMessage_Vec3_default_instance_);
}
inline const ::click::protobuf::SensorMessage_Vec3& SensorMessage_Sensor::rpy() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:click.protobuf.SensorMessage.Sensor.rpy)
  return _internal_rpy();
}
inline ::click::protobuf::SensorMessage_Vec3* SensorMessage_Sensor::unsafe_arena_release_rpy() {
  // @@protoc_insertion_point(field_unsafe_arena_release:click.protobuf.SensorMessage.Sensor.rpy)
  if (value_case() == kRpy) {
    clear_has_value();
    auto* temp = _impl_.value_.rpy_;
    _impl_.value_.rpy_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SensorMessage_Sensor::unsafe_arena_set_allocated_rpy(::click::protobuf::SensorMessage_Vec3* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_value();
  if (value) {
    set_has_rpy();
    _impl_.value_.rpy_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:click.protobuf.SensorMessage.Sensor.rpy)
}
inline ::click::protobuf::SensorMessage_Vec3* SensorMessage_Sensor::_internal_mutable_rpy() {
  if (value_case() != kRpy) {
    clear_value();
    set_has_rpy();
    _impl_.value_.rpy_ =
        ::google::protobuf::Message::DefaultConstruct<::click::protobuf::SensorMessage_Vec3>(GetArena());
  }
  return _impl_.value_.rpy_;
}
inline ::click::protobuf::SensorMessage_Vec3* SensorMessage_Sensor::mutable_rpy() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::click::protobuf::SensorMessage_Vec3* _msg = _internal_mutable_rpy();
  // @@protoc_insertion_point(field_mutable:click.protobuf.SensorMessage.Sensor.rpy)
  return _msg;
}

// bool activated = 6;
inline bool SensorMessage_Sensor::has_activated() const {
  return value_case() == kActivated;
}
inline void SensorMessage_Sensor::set_has_activated() {
  _impl_._oneof_case_[0] = kActivated;
}
inline void SensorMessage_Sensor::clear_activated() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value_case() == kActivated) {
    _impl_.value_.activated_ = false;
    clear_has_value();
  }
}
inline bool SensorMessage_Sensor::activated() const {
  // @@protoc_insertion_point(field_get:click.protobuf.SensorMessage.Sensor.activated)
  return _internal_activated();
}
inline void SensorMessage_Sensor::set_activated(bool value) {
  if (value_case() != kActivated) {
    clear_value();
    set_has_activated();
  }
  _impl_.value_.activated_ = value;
  // @@protoc_insertion_point(field_set:click.protobuf.SensorMessage.Sensor.activated)
}
inline bool SensorMessage_Sensor::_internal_activated() const {
  if (value_case() == kActivated) {
    return _impl_.value_.activated_;
  }
  return false;
}

// .click.protobuf.SensorMessage.Vec3 acceleration3d = 7;
inline bool SensorMessage_Sensor::has_acceleration3d() const {
  return value_case() == kAcceleration3D;
}
inline bool SensorMessage_Sensor::_internal_has_acceleration3d() const {
  return value_case() == kAcceleration3D;
}
inline void SensorMessage_Sensor::set_has_acceleration3d() {
  _impl_._oneof_case_[0] = kAcceleration3D;
}
inline void SensorMessage_Sensor::clear_acceleration3d() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value_case() == kAcceleration3D) {
    if (GetArena() == nullptr) {
      delete _impl_.value_.acceleration3d_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.value_.acceleration3d_);
    }
    clear_has_value();
  }
}
inline ::click::protobuf::SensorMessage_Vec3* SensorMessage_Sensor::release_acceleration3d() {
  // @@protoc_insertion_point(field_release:click.protobuf.SensorMessage.Sensor.acceleration3d)
  if (value_case() == kAcceleration3D) {
    clear_has_value();
    auto* temp = _impl_.value_.acceleration3d_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.value_.acceleration3d_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::click::protobuf::SensorMessage_Vec3& SensorMessage_Sensor::_internal_acceleration3d() const {
  return value_case() == kAcceleration3D ? *_impl_.value_.acceleration3d_ : reinterpret_cast<::click::protobuf::SensorMessage_Vec3&>(::click::protobuf::_SensorMessage_Vec3_default_instance_);
}
inline const ::click::protobuf::SensorMessage_Vec3& SensorMessage_Sensor::acceleration3d() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:click.protobuf.SensorMessage.Sensor.acceleration3d)
  return _internal_acceleration3d();
}
inline ::click::protobuf::SensorMessage_Vec3* SensorMessage_Sensor::unsafe_arena_release_acceleration3d() {
  // @@protoc_insertion_point(field_unsafe_arena_release:click.protobuf.SensorMessage.Sensor.acceleration3d)
  if (value_case() == kAcceleration3D) {
    clear_has_value();
    auto* temp = _impl_.value_.acceleration3d_;
    _impl_.value_.acceleration3d_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SensorMessage_Sensor::unsafe_arena_set_allocated_acceleration3d(::click::protobuf::SensorMessage_Vec3* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_value();
  if (value) {
    set_has_acceleration3d();
    _impl_.value_.acceleration3d_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:click.protobuf.SensorMessage.Sensor.acceleration3d)
}
inline ::click::protobuf::SensorMessage_Vec3* SensorMessage_Sensor::_internal_mutable_acceleration3d() {
  if (value_case() != kAcceleration3D) {
    clear_value();
    set_has_acceleration3d();
    _impl_.value_.acceleration3d_ =
        ::google::protobuf::Message::DefaultConstruct<::click::protobuf::SensorMessage_Vec3>(GetArena());
  }
  return _impl_.value_.acceleration3d_;
}
inline ::click::protobuf::SensorMessage_Vec3* SensorMessage_Sensor::mutable_acceleration3d() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::click::protobuf::SensorMessage_Vec3* _msg = _internal_mutable_acceleration3d();
  // @@protoc_insertion_point(field_mutable:click.protobuf.SensorMessage.Sensor.acceleration3d)
  return _msg;
}

// .click.protobuf.SensorMessage.Vec3 force3d = 8;
inline bool SensorMessage_Sensor::has_force3d() const {
  return value_case() == kForce3D;
}
inline bool SensorMessage_Sensor::_internal_has_force3d() const {
  return value_case() == kForce3D;
}
inline void SensorMessage_Sensor::set_has_force3d() {
  _impl_._oneof_case_[0] = kForce3D;
}
inline void SensorMessage_Sensor::clear_force3d() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value_case() == kForce3D) {
    if (GetArena() == nullptr) {
      delete _impl_.value_.force3d_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.value_.force3d_);
    }
    clear_has_value();
  }
}
inline ::click::protobuf::SensorMessage_Vec3* SensorMessage_Sensor::release_force3d() {
  // @@protoc_insertion_point(field_release:click.protobuf.SensorMessage.Sensor.force3d)
  if (value_case() == kForce3D) {
    clear_has_value();
    auto* temp = _impl_.value_.force3d_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.value_.force3d_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::click::protobuf::SensorMessage_Vec3& SensorMessage_Sensor::_internal_force3d() const {
  return value_case() == kForce3D ? *_impl_.value_.force3d_ : reinterpret_cast<::click::protobuf::SensorMessage_Vec3&>(::click::protobuf::_SensorMessage_Vec3_default_instance_);
}
inline const ::click::protobuf::SensorMessage_Vec3& SensorMessage_Sensor::force3d() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:click.protobuf.SensorMessage.Sensor.force3d)
  return _internal_force3d();
}
inline ::click::protobuf::SensorMessage_Vec3* SensorMessage_Sensor::unsafe_arena_release_force3d() {
  // @@protoc_insertion_point(field_unsafe_arena_release:click.protobuf.SensorMessage.Sensor.force3d)
  if (value_case() == kForce3D) {
    clear_has_value();
    auto* temp = _impl_.value_.force3d_;
    _impl_.value_.force3d_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SensorMessage_Sensor::unsafe_arena_set_allocated_force3d(::click::protobuf::SensorMessage_Vec3* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_value();
  if (value) {
    set_has_force3d();
    _impl_.value_.force3d_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:click.protobuf.SensorMessage.Sensor.force3d)
}
inline ::click::protobuf::SensorMessage_Vec3* SensorMessage_Sensor::_internal_mutable_force3d() {
  if (value_case() != kForce3D) {
    clear_value();
    set_has_force3d();
    _impl_.value_.force3d_ =
        ::google::protobuf::Message::DefaultConstruct<::click::protobuf::SensorMessage_Vec3>(GetArena());
  }
  return _impl_.value_.force3d_;
}
inline ::click::protobuf::SensorMessage_Vec3* SensorMessage_Sensor::mutable_force3d() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::click::protobuf::SensorMessage_Vec3* _msg = _internal_mutable_force3d();
  // @@protoc_insertion_point(field_mutable:click.protobuf.SensorMessage.Sensor.force3d)
  return _msg;
}

// .click.protobuf.SensorMessage.Vec3 torque3d = 9;
inline bool SensorMessage_Sensor::has_torque3d() const {
  return value_case() == kTorque3D;
}
inline bool SensorMessage_Sensor::_internal_has_torque3d() const {
  return value_case() == kTorque3D;
}
inline void SensorMessage_Sensor::set_has_torque3d() {
  _impl_._oneof_case_[0] = kTorque3D;
}
inline void SensorMessage_Sensor::clear_torque3d() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value_case() == kTorque3D) {
    if (GetArena() == nullptr) {
      delete _impl_.value_.torque3d_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.value_.torque3d_);
    }
    clear_has_value();
  }
}
inline ::click::protobuf::SensorMessage_Vec3* SensorMessage_Sensor::release_torque3d() {
  // @@protoc_insertion_point(field_release:click.protobuf.SensorMessage.Sensor.torque3d)
  if (value_case() == kTorque3D) {
    clear_has_value();
    auto* temp = _impl_.value_.torque3d_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.value_.torque3d_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::click::protobuf::SensorMessage_Vec3& SensorMessage_Sensor::_internal_torque3d() const {
  return value_case() == kTorque3D ? *_impl_.value_.torque3d_ : reinterpret_cast<::click::protobuf::SensorMessage_Vec3&>(::click::protobuf::_SensorMessage_Vec3_default_instance_);
}
inline const ::click::protobuf::SensorMessage_Vec3& SensorMessage_Sensor::torque3d() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:click.protobuf.SensorMessage.Sensor.torque3d)
  return _internal_torque3d();
}
inline ::click::protobuf::SensorMessage_Vec3* SensorMessage_Sensor::unsafe_arena_release_torque3d() {
  // @@protoc_insertion_point(field_unsafe_arena_release:click.protobuf.SensorMessage.Sensor.torque3d)
  if (value_case() == kTorque3D) {
    clear_has_value();
    auto* temp = _impl_.value_.torque3d_;
    _impl_.value_.torque3d_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SensorMessage_Sensor::unsafe_arena_set_allocated_torque3d(::click::protobuf::SensorMessage_Vec3* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_value();
  if (value) {
    set_has_torque3d();
    _impl_.value_.torque3d_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:click.protobuf.SensorMessage.Sensor.torque3d)
}
inline ::click::protobuf::SensorMessage_Vec3* SensorMessage_Sensor::_internal_mutable_torque3d() {
  if (value_case() != kTorque3D) {
    clear_value();
    set_has_torque3d();
    _impl_.value_.torque3d_ =
        ::google::protobuf::Message::DefaultConstruct<::click::protobuf::SensorMessage_Vec3>(GetArena());
  }
  return _impl_.value_.torque3d_;
}
inline ::click::protobuf::SensorMessage_Vec3* SensorMessage_Sensor::mutable_torque3d() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::click::protobuf::SensorMessage_Vec3* _msg = _internal_mutable_torque3d();
  // @@protoc_insertion_point(field_mutable:click.protobuf.SensorMessage.Sensor.torque3d)
  return _msg;
}

// .click.protobuf.SensorMessage.Vec3 angularAcceleration3d = 10;
inline bool SensorMessage_Sensor::has_angularacceleration3d() const {
  return value_case() == kAngularAcceleration3D;
}
inline bool SensorMessage_Sensor::_internal_has_angularacceleration3d() const {
  return value_case() == kAngularAcceleration3D;
}
inline void SensorMessage_Sensor::set_has_angularacceleration3d() {
  _impl_._oneof_case_[0] = kAngularAcceleration3D;
}
inline void SensorMessage_Sensor::clear_angularacceleration3d() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value_case() == kAngularAcceleration3D) {
    if (GetArena() == nullptr) {
      delete _impl_.value_.angularacceleration3d_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.value_.angularacceleration3d_);
    }
    clear_has_value();
  }
}
inline ::click::protobuf::SensorMessage_Vec3* SensorMessage_Sensor::release_angularacceleration3d() {
  // @@protoc_insertion_point(field_release:click.protobuf.SensorMessage.Sensor.angularAcceleration3d)
  if (value_case() == kAngularAcceleration3D) {
    clear_has_value();
    auto* temp = _impl_.value_.angularacceleration3d_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.value_.angularacceleration3d_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::click::protobuf::SensorMessage_Vec3& SensorMessage_Sensor::_internal_angularacceleration3d() const {
  return value_case() == kAngularAcceleration3D ? *_impl_.value_.angularacceleration3d_ : reinterpret_cast<::click::protobuf::SensorMessage_Vec3&>(::click::protobuf::_SensorMessage_Vec3_default_instance_);
}
inline const ::click::protobuf::SensorMessage_Vec3& SensorMessage_Sensor::angularacceleration3d() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:click.protobuf.SensorMessage.Sensor.angularAcceleration3d)
  return _internal_angularacceleration3d();
}
inline ::click::protobuf::SensorMessage_Vec3* SensorMessage_Sensor::unsafe_arena_release_angularacceleration3d() {
  // @@protoc_insertion_point(field_unsafe_arena_release:click.protobuf.SensorMessage.Sensor.angularAcceleration3d)
  if (value_case() == kAngularAcceleration3D) {
    clear_has_value();
    auto* temp = _impl_.value_.angularacceleration3d_;
    _impl_.value_.angularacceleration3d_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SensorMessage_Sensor::unsafe_arena_set_allocated_angularacceleration3d(::click::protobuf::SensorMessage_Vec3* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_value();
  if (value) {
    set_has_angularacceleration3d();
    _impl_.value_.angularacceleration3d_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:click.protobuf.SensorMessage.Sensor.angularAcceleration3d)
}
inline ::click::protobuf::SensorMessage_Vec3* SensorMessage_Sensor::_internal_mutable_angularacceleration3d() {
  if (value_case() != kAngularAcceleration3D) {
    clear_value();
    set_has_angularacceleration3d();
    _impl_.value_.angularacceleration3d_ =
        ::google::protobuf::Message::DefaultConstruct<::click::protobuf::SensorMessage_Vec3>(GetArena());
  }
  return _impl_.value_.angularacceleration3d_;
}
inline ::click::protobuf::SensorMessage_Vec3* SensorMessage_Sensor::mutable_angularacceleration3d() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::click::protobuf::SensorMessage_Vec3* _msg = _internal_mutable_angularacceleration3d();
  // @@protoc_insertion_point(field_mutable:click.protobuf.SensorMessage.Sensor.angularAcceleration3d)
  return _msg;
}

// .click.protobuf.SensorMessage.Vec3 velocity3d = 12;
inline bool SensorMessage_Sensor::has_velocity3d() const {
  return value_case() == kVelocity3D;
}
inline bool SensorMessage_Sensor::_internal_has_velocity3d() const {
  return value_case() == kVelocity3D;
}
inline void SensorMessage_Sensor::set_has_velocity3d() {
  _impl_._oneof_case_[0] = kVelocity3D;
}
inline void SensorMessage_Sensor::clear_velocity3d() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value_case() == kVelocity3D) {
    if (GetArena() == nullptr) {
      delete _impl_.value_.velocity3d_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.value_.velocity3d_);
    }
    clear_has_value();
  }
}
inline ::click::protobuf::SensorMessage_Vec3* SensorMessage_Sensor::release_velocity3d() {
  // @@protoc_insertion_point(field_release:click.protobuf.SensorMessage.Sensor.velocity3d)
  if (value_case() == kVelocity3D) {
    clear_has_value();
    auto* temp = _impl_.value_.velocity3d_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.value_.velocity3d_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::click::protobuf::SensorMessage_Vec3& SensorMessage_Sensor::_internal_velocity3d() const {
  return value_case() == kVelocity3D ? *_impl_.value_.velocity3d_ : reinterpret_cast<::click::protobuf::SensorMessage_Vec3&>(::click::protobuf::_SensorMessage_Vec3_default_instance_);
}
inline const ::click::protobuf::SensorMessage_Vec3& SensorMessage_Sensor::velocity3d() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:click.protobuf.SensorMessage.Sensor.velocity3d)
  return _internal_velocity3d();
}
inline ::click::protobuf::SensorMessage_Vec3* SensorMessage_Sensor::unsafe_arena_release_velocity3d() {
  // @@protoc_insertion_point(field_unsafe_arena_release:click.protobuf.SensorMessage.Sensor.velocity3d)
  if (value_case() == kVelocity3D) {
    clear_has_value();
    auto* temp = _impl_.value_.velocity3d_;
    _impl_.value_.velocity3d_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SensorMessage_Sensor::unsafe_arena_set_allocated_velocity3d(::click::protobuf::SensorMessage_Vec3* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_value();
  if (value) {
    set_has_velocity3d();
    _impl_.value_.velocity3d_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:click.protobuf.SensorMessage.Sensor.velocity3d)
}
inline ::click::protobuf::SensorMessage_Vec3* SensorMessage_Sensor::_internal_mutable_velocity3d() {
  if (value_case() != kVelocity3D) {
    clear_value();
    set_has_velocity3d();
    _impl_.value_.velocity3d_ =
        ::google::protobuf::Message::DefaultConstruct<::click::protobuf::SensorMessage_Vec3>(GetArena());
  }
  return _impl_.value_.velocity3d_;
}
inline ::click::protobuf::SensorMessage_Vec3* SensorMessage_Sensor::mutable_velocity3d() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::click::protobuf::SensorMessage_Vec3* _msg = _internal_mutable_velocity3d();
  // @@protoc_insertion_point(field_mutable:click.protobuf.SensorMessage.Sensor.velocity3d)
  return _msg;
}

// .click.protobuf.SensorMessage.Vec3 angularVelocity3d = 13;
inline bool SensorMessage_Sensor::has_angularvelocity3d() const {
  return value_case() == kAngularVelocity3D;
}
inline bool SensorMessage_Sensor::_internal_has_angularvelocity3d() const {
  return value_case() == kAngularVelocity3D;
}
inline void SensorMessage_Sensor::set_has_angularvelocity3d() {
  _impl_._oneof_case_[0] = kAngularVelocity3D;
}
inline void SensorMessage_Sensor::clear_angularvelocity3d() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value_case() == kAngularVelocity3D) {
    if (GetArena() == nullptr) {
      delete _impl_.value_.angularvelocity3d_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.value_.angularvelocity3d_);
    }
    clear_has_value();
  }
}
inline ::click::protobuf::SensorMessage_Vec3* SensorMessage_Sensor::release_angularvelocity3d() {
  // @@protoc_insertion_point(field_release:click.protobuf.SensorMessage.Sensor.angularVelocity3d)
  if (value_case() == kAngularVelocity3D) {
    clear_has_value();
    auto* temp = _impl_.value_.angularvelocity3d_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.value_.angularvelocity3d_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::click::protobuf::SensorMessage_Vec3& SensorMessage_Sensor::_internal_angularvelocity3d() const {
  return value_case() == kAngularVelocity3D ? *_impl_.value_.angularvelocity3d_ : reinterpret_cast<::click::protobuf::SensorMessage_Vec3&>(::click::protobuf::_SensorMessage_Vec3_default_instance_);
}
inline const ::click::protobuf::SensorMessage_Vec3& SensorMessage_Sensor::angularvelocity3d() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:click.protobuf.SensorMessage.Sensor.angularVelocity3d)
  return _internal_angularvelocity3d();
}
inline ::click::protobuf::SensorMessage_Vec3* SensorMessage_Sensor::unsafe_arena_release_angularvelocity3d() {
  // @@protoc_insertion_point(field_unsafe_arena_release:click.protobuf.SensorMessage.Sensor.angularVelocity3d)
  if (value_case() == kAngularVelocity3D) {
    clear_has_value();
    auto* temp = _impl_.value_.angularvelocity3d_;
    _impl_.value_.angularvelocity3d_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SensorMessage_Sensor::unsafe_arena_set_allocated_angularvelocity3d(::click::protobuf::SensorMessage_Vec3* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_value();
  if (value) {
    set_has_angularvelocity3d();
    _impl_.value_.angularvelocity3d_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:click.protobuf.SensorMessage.Sensor.angularVelocity3d)
}
inline ::click::protobuf::SensorMessage_Vec3* SensorMessage_Sensor::_internal_mutable_angularvelocity3d() {
  if (value_case() != kAngularVelocity3D) {
    clear_value();
    set_has_angularvelocity3d();
    _impl_.value_.angularvelocity3d_ =
        ::google::protobuf::Message::DefaultConstruct<::click::protobuf::SensorMessage_Vec3>(GetArena());
  }
  return _impl_.value_.angularvelocity3d_;
}
inline ::click::protobuf::SensorMessage_Vec3* SensorMessage_Sensor::mutable_angularvelocity3d() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::click::protobuf::SensorMessage_Vec3* _msg = _internal_mutable_angularvelocity3d();
  // @@protoc_insertion_point(field_mutable:click.protobuf.SensorMessage.Sensor.angularVelocity3d)
  return _msg;
}

// double force1d = 14;
inline bool SensorMessage_Sensor::has_force1d() const {
  return value_case() == kForce1D;
}
inline void SensorMessage_Sensor::set_has_force1d() {
  _impl_._oneof_case_[0] = kForce1D;
}
inline void SensorMessage_Sensor::clear_force1d() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value_case() == kForce1D) {
    _impl_.value_.force1d_ = 0;
    clear_has_value();
  }
}
inline double SensorMessage_Sensor::force1d() const {
  // @@protoc_insertion_point(field_get:click.protobuf.SensorMessage.Sensor.force1d)
  return _internal_force1d();
}
inline void SensorMessage_Sensor::set_force1d(double value) {
  if (value_case() != kForce1D) {
    clear_value();
    set_has_force1d();
  }
  _impl_.value_.force1d_ = value;
  // @@protoc_insertion_point(field_set:click.protobuf.SensorMessage.Sensor.force1d)
}
inline double SensorMessage_Sensor::_internal_force1d() const {
  if (value_case() == kForce1D) {
    return _impl_.value_.force1d_;
  }
  return 0;
}

inline bool SensorMessage_Sensor::has_value() const {
  return value_case() != VALUE_NOT_SET;
}
inline void SensorMessage_Sensor::clear_has_value() {
  _impl_._oneof_case_[0] = VALUE_NOT_SET;
}
inline SensorMessage_Sensor::ValueCase SensorMessage_Sensor::value_case() const {
  return SensorMessage_Sensor::ValueCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// SensorMessage_Sensors

// repeated .click.protobuf.SensorMessage.Sensor sensor = 1;
inline int SensorMessage_Sensors::_internal_sensor_size() const {
  return _internal_sensor().size();
}
inline int SensorMessage_Sensors::sensor_size() const {
  return _internal_sensor_size();
}
inline void SensorMessage_Sensors::clear_sensor() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.sensor_.Clear();
}
inline ::click::protobuf::SensorMessage_Sensor* SensorMessage_Sensors::mutable_sensor(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:click.protobuf.SensorMessage.Sensors.sensor)
  return _internal_mutable_sensor()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::click::protobuf::SensorMessage_Sensor>* SensorMessage_Sensors::mutable_sensor()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:click.protobuf.SensorMessage.Sensors.sensor)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_sensor();
}
inline const ::click::protobuf::SensorMessage_Sensor& SensorMessage_Sensors::sensor(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:click.protobuf.SensorMessage.Sensors.sensor)
  return _internal_sensor().Get(index);
}
inline ::click::protobuf::SensorMessage_Sensor* SensorMessage_Sensors::add_sensor() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::click::protobuf::SensorMessage_Sensor* _add = _internal_mutable_sensor()->Add();
  // @@protoc_insertion_point(field_add:click.protobuf.SensorMessage.Sensors.sensor)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::click::protobuf::SensorMessage_Sensor>& SensorMessage_Sensors::sensor() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:click.protobuf.SensorMessage.Sensors.sensor)
  return _internal_sensor();
}
inline const ::google::protobuf::RepeatedPtrField<::click::protobuf::SensorMessage_Sensor>&
SensorMessage_Sensors::_internal_sensor() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.sensor_;
}
inline ::google::protobuf::RepeatedPtrField<::click::protobuf::SensorMessage_Sensor>*
SensorMessage_Sensors::_internal_mutable_sensor() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.sensor_;
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// SensorMessage_Object

// repeated double angleSensors = 1;
inline int SensorMessage_Object::_internal_anglesensors_size() const {
  return _internal_anglesensors().size();
}
inline int SensorMessage_Object::anglesensors_size() const {
  return _internal_anglesensors_size();
}
inline void SensorMessage_Object::clear_anglesensors() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.anglesensors_.Clear();
}
inline double SensorMessage_Object::anglesensors(int index) const {
  // @@protoc_insertion_point(field_get:click.protobuf.SensorMessage.Object.angleSensors)
  return _internal_anglesensors().Get(index);
}
inline void SensorMessage_Object::set_anglesensors(int index, double value) {
  _internal_mutable_anglesensors()->Set(index, value);
  // @@protoc_insertion_point(field_set:click.protobuf.SensorMessage.Object.angleSensors)
}
inline void SensorMessage_Object::add_anglesensors(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_anglesensors()->Add(value);
  // @@protoc_insertion_point(field_add:click.protobuf.SensorMessage.Object.angleSensors)
}
inline const ::google::protobuf::RepeatedField<double>& SensorMessage_Object::anglesensors() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:click.protobuf.SensorMessage.Object.angleSensors)
  return _internal_anglesensors();
}
inline ::google::protobuf::RepeatedField<double>* SensorMessage_Object::mutable_anglesensors()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:click.protobuf.SensorMessage.Object.angleSensors)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_anglesensors();
}
inline const ::google::protobuf::RepeatedField<double>&
SensorMessage_Object::_internal_anglesensors() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.anglesensors_;
}
inline ::google::protobuf::RepeatedField<double>* SensorMessage_Object::_internal_mutable_anglesensors() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.anglesensors_;
}

// repeated double angularVelocitySensors = 2;
inline int SensorMessage_Object::_internal_angularvelocitysensors_size() const {
  return _internal_angularvelocitysensors().size();
}
inline int SensorMessage_Object::angularvelocitysensors_size() const {
  return _internal_angularvelocitysensors_size();
}
inline void SensorMessage_Object::clear_angularvelocitysensors() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.angularvelocitysensors_.Clear();
}
inline double SensorMessage_Object::angularvelocitysensors(int index) const {
  // @@protoc_insertion_point(field_get:click.protobuf.SensorMessage.Object.angularVelocitySensors)
  return _internal_angularvelocitysensors().Get(index);
}
inline void SensorMessage_Object::set_angularvelocitysensors(int index, double value) {
  _internal_mutable_angularvelocitysensors()->Set(index, value);
  // @@protoc_insertion_point(field_set:click.protobuf.SensorMessage.Object.angularVelocitySensors)
}
inline void SensorMessage_Object::add_angularvelocitysensors(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_angularvelocitysensors()->Add(value);
  // @@protoc_insertion_point(field_add:click.protobuf.SensorMessage.Object.angularVelocitySensors)
}
inline const ::google::protobuf::RepeatedField<double>& SensorMessage_Object::angularvelocitysensors() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:click.protobuf.SensorMessage.Object.angularVelocitySensors)
  return _internal_angularvelocitysensors();
}
inline ::google::protobuf::RepeatedField<double>* SensorMessage_Object::mutable_angularvelocitysensors()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:click.protobuf.SensorMessage.Object.angularVelocitySensors)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_angularvelocitysensors();
}
inline const ::google::protobuf::RepeatedField<double>&
SensorMessage_Object::_internal_angularvelocitysensors() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.angularvelocitysensors_;
}
inline ::google::protobuf::RepeatedField<double>* SensorMessage_Object::_internal_mutable_angularvelocitysensors() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.angularvelocitysensors_;
}

// repeated double torqueSensors = 3;
inline int SensorMessage_Object::_internal_torquesensors_size() const {
  return _internal_torquesensors().size();
}
inline int SensorMessage_Object::torquesensors_size() const {
  return _internal_torquesensors_size();
}
inline void SensorMessage_Object::clear_torquesensors() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.torquesensors_.Clear();
}
inline double SensorMessage_Object::torquesensors(int index) const {
  // @@protoc_insertion_point(field_get:click.protobuf.SensorMessage.Object.torqueSensors)
  return _internal_torquesensors().Get(index);
}
inline void SensorMessage_Object::set_torquesensors(int index, double value) {
  _internal_mutable_torquesensors()->Set(index, value);
  // @@protoc_insertion_point(field_set:click.protobuf.SensorMessage.Object.torqueSensors)
}
inline void SensorMessage_Object::add_torquesensors(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_torquesensors()->Add(value);
  // @@protoc_insertion_point(field_add:click.protobuf.SensorMessage.Object.torqueSensors)
}
inline const ::google::protobuf::RepeatedField<double>& SensorMessage_Object::torquesensors() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:click.protobuf.SensorMessage.Object.torqueSensors)
  return _internal_torquesensors();
}
inline ::google::protobuf::RepeatedField<double>* SensorMessage_Object::mutable_torquesensors()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:click.protobuf.SensorMessage.Object.torqueSensors)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_torquesensors();
}
inline const ::google::protobuf::RepeatedField<double>&
SensorMessage_Object::_internal_torquesensors() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.torquesensors_;
}
inline ::google::protobuf::RepeatedField<double>* SensorMessage_Object::_internal_mutable_torquesensors() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.torquesensors_;
}

// repeated .click.protobuf.SensorMessage.Vec3 forceSensors = 5;
inline int SensorMessage_Object::_internal_forcesensors_size() const {
  return _internal_forcesensors().size();
}
inline int SensorMessage_Object::forcesensors_size() const {
  return _internal_forcesensors_size();
}
inline void SensorMessage_Object::clear_forcesensors() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.forcesensors_.Clear();
}
inline ::click::protobuf::SensorMessage_Vec3* SensorMessage_Object::mutable_forcesensors(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:click.protobuf.SensorMessage.Object.forceSensors)
  return _internal_mutable_forcesensors()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::click::protobuf::SensorMessage_Vec3>* SensorMessage_Object::mutable_forcesensors()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:click.protobuf.SensorMessage.Object.forceSensors)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_forcesensors();
}
inline const ::click::protobuf::SensorMessage_Vec3& SensorMessage_Object::forcesensors(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:click.protobuf.SensorMessage.Object.forceSensors)
  return _internal_forcesensors().Get(index);
}
inline ::click::protobuf::SensorMessage_Vec3* SensorMessage_Object::add_forcesensors() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::click::protobuf::SensorMessage_Vec3* _add = _internal_mutable_forcesensors()->Add();
  // @@protoc_insertion_point(field_add:click.protobuf.SensorMessage.Object.forceSensors)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::click::protobuf::SensorMessage_Vec3>& SensorMessage_Object::forcesensors() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:click.protobuf.SensorMessage.Object.forceSensors)
  return _internal_forcesensors();
}
inline const ::google::protobuf::RepeatedPtrField<::click::protobuf::SensorMessage_Vec3>&
SensorMessage_Object::_internal_forcesensors() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.forcesensors_;
}
inline ::google::protobuf::RepeatedPtrField<::click::protobuf::SensorMessage_Vec3>*
SensorMessage_Object::_internal_mutable_forcesensors() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.forcesensors_;
}

// repeated .click.protobuf.SensorMessage.Sensor objectSensors = 4;
inline int SensorMessage_Object::_internal_objectsensors_size() const {
  return _internal_objectsensors().size();
}
inline int SensorMessage_Object::objectsensors_size() const {
  return _internal_objectsensors_size();
}
inline void SensorMessage_Object::clear_objectsensors() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.objectsensors_.Clear();
}
inline ::click::protobuf::SensorMessage_Sensor* SensorMessage_Object::mutable_objectsensors(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:click.protobuf.SensorMessage.Object.objectSensors)
  return _internal_mutable_objectsensors()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::click::protobuf::SensorMessage_Sensor>* SensorMessage_Object::mutable_objectsensors()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:click.protobuf.SensorMessage.Object.objectSensors)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_objectsensors();
}
inline const ::click::protobuf::SensorMessage_Sensor& SensorMessage_Object::objectsensors(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:click.protobuf.SensorMessage.Object.objectSensors)
  return _internal_objectsensors().Get(index);
}
inline ::click::protobuf::SensorMessage_Sensor* SensorMessage_Object::add_objectsensors() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::click::protobuf::SensorMessage_Sensor* _add = _internal_mutable_objectsensors()->Add();
  // @@protoc_insertion_point(field_add:click.protobuf.SensorMessage.Object.objectSensors)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::click::protobuf::SensorMessage_Sensor>& SensorMessage_Object::objectsensors() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:click.protobuf.SensorMessage.Object.objectSensors)
  return _internal_objectsensors();
}
inline const ::google::protobuf::RepeatedPtrField<::click::protobuf::SensorMessage_Sensor>&
SensorMessage_Object::_internal_objectsensors() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.objectsensors_;
}
inline ::google::protobuf::RepeatedPtrField<::click::protobuf::SensorMessage_Sensor>*
SensorMessage_Object::_internal_mutable_objectsensors() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.objectsensors_;
}

// map<string, .click.protobuf.SensorMessage.Sensors> sensors = 6;
inline int SensorMessage_Object::_internal_sensors_size() const {
  return _internal_sensors().size();
}
inline int SensorMessage_Object::sensors_size() const {
  return _internal_sensors_size();
}
inline void SensorMessage_Object::clear_sensors() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.sensors_.Clear();
}
inline const ::google::protobuf::Map<std::string, ::click::protobuf::SensorMessage_Sensors>& SensorMessage_Object::_internal_sensors() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.sensors_.GetMap();
}
inline const ::google::protobuf::Map<std::string, ::click::protobuf::SensorMessage_Sensors>& SensorMessage_Object::sensors() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_map:click.protobuf.SensorMessage.Object.sensors)
  return _internal_sensors();
}
inline ::google::protobuf::Map<std::string, ::click::protobuf::SensorMessage_Sensors>* SensorMessage_Object::_internal_mutable_sensors() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.sensors_.MutableMap();
}
inline ::google::protobuf::Map<std::string, ::click::protobuf::SensorMessage_Sensors>* SensorMessage_Object::mutable_sensors() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_map:click.protobuf.SensorMessage.Object.sensors)
  return _internal_mutable_sensors();
}

// -------------------------------------------------------------------

// SensorMessage_SimulationVariables

// double simulatedTime = 1;
inline void SensorMessage_SimulationVariables::clear_simulatedtime() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.simulatedtime_ = 0;
}
inline double SensorMessage_SimulationVariables::simulatedtime() const {
  // @@protoc_insertion_point(field_get:click.protobuf.SensorMessage.SimulationVariables.simulatedTime)
  return _internal_simulatedtime();
}
inline void SensorMessage_SimulationVariables::set_simulatedtime(double value) {
  _internal_set_simulatedtime(value);
  // @@protoc_insertion_point(field_set:click.protobuf.SensorMessage.SimulationVariables.simulatedTime)
}
inline double SensorMessage_SimulationVariables::_internal_simulatedtime() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.simulatedtime_;
}
inline void SensorMessage_SimulationVariables::_internal_set_simulatedtime(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.simulatedtime_ = value;
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// SensorMessage

// .click.protobuf.MessageType messageType = 1;
inline void SensorMessage::clear_messagetype() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.messagetype_ = 0;
}
inline ::click::protobuf::MessageType SensorMessage::messagetype() const {
  // @@protoc_insertion_point(field_get:click.protobuf.SensorMessage.messageType)
  return _internal_messagetype();
}
inline void SensorMessage::set_messagetype(::click::protobuf::MessageType value) {
  _internal_set_messagetype(value);
  // @@protoc_insertion_point(field_set:click.protobuf.SensorMessage.messageType)
}
inline ::click::protobuf::MessageType SensorMessage::_internal_messagetype() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::click::protobuf::MessageType>(_impl_.messagetype_);
}
inline void SensorMessage::_internal_set_messagetype(::click::protobuf::MessageType value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.messagetype_ = value;
}

// map<string, .click.protobuf.SensorMessage.Object> objects = 3;
inline int SensorMessage::_internal_objects_size() const {
  return _internal_objects().size();
}
inline int SensorMessage::objects_size() const {
  return _internal_objects_size();
}
inline void SensorMessage::clear_objects() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.objects_.Clear();
}
inline const ::google::protobuf::Map<std::string, ::click::protobuf::SensorMessage_Object>& SensorMessage::_internal_objects() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.objects_.GetMap();
}
inline const ::google::protobuf::Map<std::string, ::click::protobuf::SensorMessage_Object>& SensorMessage::objects() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_map:click.protobuf.SensorMessage.objects)
  return _internal_objects();
}
inline ::google::protobuf::Map<std::string, ::click::protobuf::SensorMessage_Object>* SensorMessage::_internal_mutable_objects() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.objects_.MutableMap();
}
inline ::google::protobuf::Map<std::string, ::click::protobuf::SensorMessage_Object>* SensorMessage::mutable_objects() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_map:click.protobuf.SensorMessage.objects)
  return _internal_mutable_objects();
}

// .click.protobuf.SensorMessage.SimulationVariables simVars = 4;
inline bool SensorMessage::has_simvars() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.simvars_ != nullptr);
  return value;
}
inline void SensorMessage::clear_simvars() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.simvars_ != nullptr) _impl_.simvars_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::click::protobuf::SensorMessage_SimulationVariables& SensorMessage::_internal_simvars() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::click::protobuf::SensorMessage_SimulationVariables* p = _impl_.simvars_;
  return p != nullptr ? *p : reinterpret_cast<const ::click::protobuf::SensorMessage_SimulationVariables&>(::click::protobuf::_SensorMessage_SimulationVariables_default_instance_);
}
inline const ::click::protobuf::SensorMessage_SimulationVariables& SensorMessage::simvars() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:click.protobuf.SensorMessage.simVars)
  return _internal_simvars();
}
inline void SensorMessage::unsafe_arena_set_allocated_simvars(::click::protobuf::SensorMessage_SimulationVariables* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.simvars_);
  }
  _impl_.simvars_ = reinterpret_cast<::click::protobuf::SensorMessage_SimulationVariables*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:click.protobuf.SensorMessage.simVars)
}
inline ::click::protobuf::SensorMessage_SimulationVariables* SensorMessage::release_simvars() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::click::protobuf::SensorMessage_SimulationVariables* released = _impl_.simvars_;
  _impl_.simvars_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::click::protobuf::SensorMessage_SimulationVariables* SensorMessage::unsafe_arena_release_simvars() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:click.protobuf.SensorMessage.simVars)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::click::protobuf::SensorMessage_SimulationVariables* temp = _impl_.simvars_;
  _impl_.simvars_ = nullptr;
  return temp;
}
inline ::click::protobuf::SensorMessage_SimulationVariables* SensorMessage::_internal_mutable_simvars() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.simvars_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::click::protobuf::SensorMessage_SimulationVariables>(GetArena());
    _impl_.simvars_ = reinterpret_cast<::click::protobuf::SensorMessage_SimulationVariables*>(p);
  }
  return _impl_.simvars_;
}
inline ::click::protobuf::SensorMessage_SimulationVariables* SensorMessage::mutable_simvars() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::click::protobuf::SensorMessage_SimulationVariables* _msg = _internal_mutable_simvars();
  // @@protoc_insertion_point(field_mutable:click.protobuf.SensorMessage.simVars)
  return _msg;
}
inline void SensorMessage::set_allocated_simvars(::click::protobuf::SensorMessage_SimulationVariables* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.simvars_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.simvars_ = reinterpret_cast<::click::protobuf::SensorMessage_SimulationVariables*>(value);
  // @@protoc_insertion_point(field_set_allocated:click.protobuf.SensorMessage.simVars)
}

// -------------------------------------------------------------------

// ResetMessage

// .click.protobuf.MessageType messageType = 1;
inline void ResetMessage::clear_messagetype() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.messagetype_ = 0;
}
inline ::click::protobuf::MessageType ResetMessage::messagetype() const {
  // @@protoc_insertion_point(field_get:click.protobuf.ResetMessage.messageType)
  return _internal_messagetype();
}
inline void ResetMessage::set_messagetype(::click::protobuf::MessageType value) {
  _internal_set_messagetype(value);
  // @@protoc_insertion_point(field_set:click.protobuf.ResetMessage.messageType)
}
inline ::click::protobuf::MessageType ResetMessage::_internal_messagetype() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::click::protobuf::MessageType>(_impl_.messagetype_);
}
inline void ResetMessage::_internal_set_messagetype(::click::protobuf::MessageType value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.messagetype_ = value;
}

// -------------------------------------------------------------------

// ErrorMessage

// .click.protobuf.MessageType messageType = 1;
inline void ErrorMessage::clear_messagetype() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.messagetype_ = 0;
}
inline ::click::protobuf::MessageType ErrorMessage::messagetype() const {
  // @@protoc_insertion_point(field_get:click.protobuf.ErrorMessage.messageType)
  return _internal_messagetype();
}
inline void ErrorMessage::set_messagetype(::click::protobuf::MessageType value) {
  _internal_set_messagetype(value);
  // @@protoc_insertion_point(field_set:click.protobuf.ErrorMessage.messageType)
}
inline ::click::protobuf::MessageType ErrorMessage::_internal_messagetype() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::click::protobuf::MessageType>(_impl_.messagetype_);
}
inline void ErrorMessage::_internal_set_messagetype(::click::protobuf::MessageType value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.messagetype_ = value;
}

// .click.protobuf.ErrorType error = 2;
inline void ErrorMessage::clear_error() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.error_ = 0;
}
inline ::click::protobuf::ErrorType ErrorMessage::error() const {
  // @@protoc_insertion_point(field_get:click.protobuf.ErrorMessage.error)
  return _internal_error();
}
inline void ErrorMessage::set_error(::click::protobuf::ErrorType value) {
  _internal_set_error(value);
  // @@protoc_insertion_point(field_set:click.protobuf.ErrorMessage.error)
}
inline ::click::protobuf::ErrorType ErrorMessage::_internal_error() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::click::protobuf::ErrorType>(_impl_.error_);
}
inline void ErrorMessage::_internal_set_error(::click::protobuf::ErrorType value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.error_ = value;
}

// string errormessage = 3;
inline void ErrorMessage::clear_errormessage() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.errormessage_.ClearToEmpty();
}
inline const std::string& ErrorMessage::errormessage() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:click.protobuf.ErrorMessage.errormessage)
  return _internal_errormessage();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ErrorMessage::set_errormessage(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.errormessage_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:click.protobuf.ErrorMessage.errormessage)
}
inline std::string* ErrorMessage::mutable_errormessage() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_errormessage();
  // @@protoc_insertion_point(field_mutable:click.protobuf.ErrorMessage.errormessage)
  return _s;
}
inline const std::string& ErrorMessage::_internal_errormessage() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.errormessage_.Get();
}
inline void ErrorMessage::_internal_set_errormessage(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.errormessage_.Set(value, GetArena());
}
inline std::string* ErrorMessage::_internal_mutable_errormessage() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.errormessage_.Mutable( GetArena());
}
inline std::string* ErrorMessage::release_errormessage() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:click.protobuf.ErrorMessage.errormessage)
  return _impl_.errormessage_.Release();
}
inline void ErrorMessage::set_allocated_errormessage(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.errormessage_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.errormessage_.IsDefault()) {
          _impl_.errormessage_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:click.protobuf.ErrorMessage.errormessage)
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace protobuf
}  // namespace click


namespace google {
namespace protobuf {

template <>
struct is_proto_enum<::click::protobuf::MessageType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::click::protobuf::MessageType>() {
  return ::click::protobuf::MessageType_descriptor();
}
template <>
struct is_proto_enum<::click::protobuf::ValueType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::click::protobuf::ValueType>() {
  return ::click::protobuf::ValueType_descriptor();
}
template <>
struct is_proto_enum<::click::protobuf::Version> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::click::protobuf::Version>() {
  return ::click::protobuf::Version_descriptor();
}
template <>
struct is_proto_enum<::click::protobuf::ErrorType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::click::protobuf::ErrorType>() {
  return ::click::protobuf::ErrorType_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // GOOGLE_PROTOBUF_INCLUDED_Messaging_2eproto_2epb_2eh
