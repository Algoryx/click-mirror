// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: Messaging.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_Messaging_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_Messaging_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/map.h>  // IWYU pragma: export
#include <google/protobuf/map_entry.h>
#include <google/protobuf/map_field_inl.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_Messaging_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_Messaging_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_Messaging_2eproto;
namespace click {
namespace protobuf {
class ControlMessage;
struct ControlMessageDefaultTypeInternal;
extern ControlMessageDefaultTypeInternal _ControlMessage_default_instance_;
class ControlMessage_Object;
struct ControlMessage_ObjectDefaultTypeInternal;
extern ControlMessage_ObjectDefaultTypeInternal _ControlMessage_Object_default_instance_;
class ControlMessage_Object_ControlEventsEntry_DoNotUse;
struct ControlMessage_Object_ControlEventsEntry_DoNotUseDefaultTypeInternal;
extern ControlMessage_Object_ControlEventsEntry_DoNotUseDefaultTypeInternal _ControlMessage_Object_ControlEventsEntry_DoNotUse_default_instance_;
class ControlMessage_ObjectsEntry_DoNotUse;
struct ControlMessage_ObjectsEntry_DoNotUseDefaultTypeInternal;
extern ControlMessage_ObjectsEntry_DoNotUseDefaultTypeInternal _ControlMessage_ObjectsEntry_DoNotUse_default_instance_;
class ErrorMessage;
struct ErrorMessageDefaultTypeInternal;
extern ErrorMessageDefaultTypeInternal _ErrorMessage_default_instance_;
class HandshakeInitMessage;
struct HandshakeInitMessageDefaultTypeInternal;
extern HandshakeInitMessageDefaultTypeInternal _HandshakeInitMessage_default_instance_;
class HandshakeMessage;
struct HandshakeMessageDefaultTypeInternal;
extern HandshakeMessageDefaultTypeInternal _HandshakeMessage_default_instance_;
class HandshakeMessage_Object;
struct HandshakeMessage_ObjectDefaultTypeInternal;
extern HandshakeMessage_ObjectDefaultTypeInternal _HandshakeMessage_Object_default_instance_;
class HandshakeMessage_Object_ControlEventsEntry_DoNotUse;
struct HandshakeMessage_Object_ControlEventsEntry_DoNotUseDefaultTypeInternal;
extern HandshakeMessage_Object_ControlEventsEntry_DoNotUseDefaultTypeInternal _HandshakeMessage_Object_ControlEventsEntry_DoNotUse_default_instance_;
class HandshakeMessage_Object_SensorsEntry_DoNotUse;
struct HandshakeMessage_Object_SensorsEntry_DoNotUseDefaultTypeInternal;
extern HandshakeMessage_Object_SensorsEntry_DoNotUseDefaultTypeInternal _HandshakeMessage_Object_SensorsEntry_DoNotUse_default_instance_;
class HandshakeMessage_ObjectsEntry_DoNotUse;
struct HandshakeMessage_ObjectsEntry_DoNotUseDefaultTypeInternal;
extern HandshakeMessage_ObjectsEntry_DoNotUseDefaultTypeInternal _HandshakeMessage_ObjectsEntry_DoNotUse_default_instance_;
class HandshakeMessage_Sensors;
struct HandshakeMessage_SensorsDefaultTypeInternal;
extern HandshakeMessage_SensorsDefaultTypeInternal _HandshakeMessage_Sensors_default_instance_;
class HandshakeMessage_SimulationSettings;
struct HandshakeMessage_SimulationSettingsDefaultTypeInternal;
extern HandshakeMessage_SimulationSettingsDefaultTypeInternal _HandshakeMessage_SimulationSettings_default_instance_;
class Message;
struct MessageDefaultTypeInternal;
extern MessageDefaultTypeInternal _Message_default_instance_;
class ResetMessage;
struct ResetMessageDefaultTypeInternal;
extern ResetMessageDefaultTypeInternal _ResetMessage_default_instance_;
class SensorMessage;
struct SensorMessageDefaultTypeInternal;
extern SensorMessageDefaultTypeInternal _SensorMessage_default_instance_;
class SensorMessage_Object;
struct SensorMessage_ObjectDefaultTypeInternal;
extern SensorMessage_ObjectDefaultTypeInternal _SensorMessage_Object_default_instance_;
class SensorMessage_Object_SensorsEntry_DoNotUse;
struct SensorMessage_Object_SensorsEntry_DoNotUseDefaultTypeInternal;
extern SensorMessage_Object_SensorsEntry_DoNotUseDefaultTypeInternal _SensorMessage_Object_SensorsEntry_DoNotUse_default_instance_;
class SensorMessage_ObjectsEntry_DoNotUse;
struct SensorMessage_ObjectsEntry_DoNotUseDefaultTypeInternal;
extern SensorMessage_ObjectsEntry_DoNotUseDefaultTypeInternal _SensorMessage_ObjectsEntry_DoNotUse_default_instance_;
class SensorMessage_Sensor;
struct SensorMessage_SensorDefaultTypeInternal;
extern SensorMessage_SensorDefaultTypeInternal _SensorMessage_Sensor_default_instance_;
class SensorMessage_Sensors;
struct SensorMessage_SensorsDefaultTypeInternal;
extern SensorMessage_SensorsDefaultTypeInternal _SensorMessage_Sensors_default_instance_;
class SensorMessage_SimulationVariables;
struct SensorMessage_SimulationVariablesDefaultTypeInternal;
extern SensorMessage_SimulationVariablesDefaultTypeInternal _SensorMessage_SimulationVariables_default_instance_;
class SensorMessage_Vec3;
struct SensorMessage_Vec3DefaultTypeInternal;
extern SensorMessage_Vec3DefaultTypeInternal _SensorMessage_Vec3_default_instance_;
class SensorRequestMessage;
struct SensorRequestMessageDefaultTypeInternal;
extern SensorRequestMessageDefaultTypeInternal _SensorRequestMessage_default_instance_;
}  // namespace protobuf
}  // namespace click
PROTOBUF_NAMESPACE_OPEN
template<> ::click::protobuf::ControlMessage* Arena::CreateMaybeMessage<::click::protobuf::ControlMessage>(Arena*);
template<> ::click::protobuf::ControlMessage_Object* Arena::CreateMaybeMessage<::click::protobuf::ControlMessage_Object>(Arena*);
template<> ::click::protobuf::ControlMessage_Object_ControlEventsEntry_DoNotUse* Arena::CreateMaybeMessage<::click::protobuf::ControlMessage_Object_ControlEventsEntry_DoNotUse>(Arena*);
template<> ::click::protobuf::ControlMessage_ObjectsEntry_DoNotUse* Arena::CreateMaybeMessage<::click::protobuf::ControlMessage_ObjectsEntry_DoNotUse>(Arena*);
template<> ::click::protobuf::ErrorMessage* Arena::CreateMaybeMessage<::click::protobuf::ErrorMessage>(Arena*);
template<> ::click::protobuf::HandshakeInitMessage* Arena::CreateMaybeMessage<::click::protobuf::HandshakeInitMessage>(Arena*);
template<> ::click::protobuf::HandshakeMessage* Arena::CreateMaybeMessage<::click::protobuf::HandshakeMessage>(Arena*);
template<> ::click::protobuf::HandshakeMessage_Object* Arena::CreateMaybeMessage<::click::protobuf::HandshakeMessage_Object>(Arena*);
template<> ::click::protobuf::HandshakeMessage_Object_ControlEventsEntry_DoNotUse* Arena::CreateMaybeMessage<::click::protobuf::HandshakeMessage_Object_ControlEventsEntry_DoNotUse>(Arena*);
template<> ::click::protobuf::HandshakeMessage_Object_SensorsEntry_DoNotUse* Arena::CreateMaybeMessage<::click::protobuf::HandshakeMessage_Object_SensorsEntry_DoNotUse>(Arena*);
template<> ::click::protobuf::HandshakeMessage_ObjectsEntry_DoNotUse* Arena::CreateMaybeMessage<::click::protobuf::HandshakeMessage_ObjectsEntry_DoNotUse>(Arena*);
template<> ::click::protobuf::HandshakeMessage_Sensors* Arena::CreateMaybeMessage<::click::protobuf::HandshakeMessage_Sensors>(Arena*);
template<> ::click::protobuf::HandshakeMessage_SimulationSettings* Arena::CreateMaybeMessage<::click::protobuf::HandshakeMessage_SimulationSettings>(Arena*);
template<> ::click::protobuf::Message* Arena::CreateMaybeMessage<::click::protobuf::Message>(Arena*);
template<> ::click::protobuf::ResetMessage* Arena::CreateMaybeMessage<::click::protobuf::ResetMessage>(Arena*);
template<> ::click::protobuf::SensorMessage* Arena::CreateMaybeMessage<::click::protobuf::SensorMessage>(Arena*);
template<> ::click::protobuf::SensorMessage_Object* Arena::CreateMaybeMessage<::click::protobuf::SensorMessage_Object>(Arena*);
template<> ::click::protobuf::SensorMessage_Object_SensorsEntry_DoNotUse* Arena::CreateMaybeMessage<::click::protobuf::SensorMessage_Object_SensorsEntry_DoNotUse>(Arena*);
template<> ::click::protobuf::SensorMessage_ObjectsEntry_DoNotUse* Arena::CreateMaybeMessage<::click::protobuf::SensorMessage_ObjectsEntry_DoNotUse>(Arena*);
template<> ::click::protobuf::SensorMessage_Sensor* Arena::CreateMaybeMessage<::click::protobuf::SensorMessage_Sensor>(Arena*);
template<> ::click::protobuf::SensorMessage_Sensors* Arena::CreateMaybeMessage<::click::protobuf::SensorMessage_Sensors>(Arena*);
template<> ::click::protobuf::SensorMessage_SimulationVariables* Arena::CreateMaybeMessage<::click::protobuf::SensorMessage_SimulationVariables>(Arena*);
template<> ::click::protobuf::SensorMessage_Vec3* Arena::CreateMaybeMessage<::click::protobuf::SensorMessage_Vec3>(Arena*);
template<> ::click::protobuf::SensorRequestMessage* Arena::CreateMaybeMessage<::click::protobuf::SensorRequestMessage>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace click {
namespace protobuf {

enum MessageType : int {
  HandshakeInitMessageType = 0,
  HandshakeMessageType = 1,
  SensorRequestMessageType = 6,
  ControlMessageType = 2,
  SensorMessageType = 3,
  ResetMessageType = 4,
  ErrorMessageType = 5,
  MessageType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  MessageType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool MessageType_IsValid(int value);
constexpr MessageType MessageType_MIN = HandshakeInitMessageType;
constexpr MessageType MessageType_MAX = SensorRequestMessageType;
constexpr int MessageType_ARRAYSIZE = MessageType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* MessageType_descriptor();
template<typename T>
inline const std::string& MessageType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, MessageType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function MessageType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    MessageType_descriptor(), enum_t_value);
}
inline bool MessageType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, MessageType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<MessageType>(
    MessageType_descriptor(), name, value);
}
enum ValueType : int {
  Angle = 0,
  AngularVelocity1D = 1,
  Torque1D = 2,
  Position = 3,
  RPY = 4,
  Activated = 5,
  Acceleration3D = 6,
  Force1D = 12,
  Force3D = 7,
  Torque3D = 8,
  AngularAcceleration3D = 9,
  Velocity3D = 10,
  AngularVelocity3D = 11,
  Multiple = 15,
  ValueType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  ValueType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool ValueType_IsValid(int value);
constexpr ValueType ValueType_MIN = Angle;
constexpr ValueType ValueType_MAX = Multiple;
constexpr int ValueType_ARRAYSIZE = ValueType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ValueType_descriptor();
template<typename T>
inline const std::string& ValueType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ValueType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ValueType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ValueType_descriptor(), enum_t_value);
}
inline bool ValueType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ValueType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ValueType>(
    ValueType_descriptor(), name, value);
}
enum Version : int {
  UNDEFINED = 0,
  CURRENT_VERSION = 1,
  Version_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  Version_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool Version_IsValid(int value);
constexpr Version Version_MIN = UNDEFINED;
constexpr Version Version_MAX = CURRENT_VERSION;
constexpr int Version_ARRAYSIZE = Version_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Version_descriptor();
template<typename T>
inline const std::string& Version_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Version>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Version_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Version_descriptor(), enum_t_value);
}
inline bool Version_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Version* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Version>(
    Version_descriptor(), name, value);
}
enum ErrorType : int {
  VersionNotSupported = 0,
  ErrorType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  ErrorType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool ErrorType_IsValid(int value);
constexpr ErrorType ErrorType_MIN = VersionNotSupported;
constexpr ErrorType ErrorType_MAX = VersionNotSupported;
constexpr int ErrorType_ARRAYSIZE = ErrorType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ErrorType_descriptor();
template<typename T>
inline const std::string& ErrorType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ErrorType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ErrorType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ErrorType_descriptor(), enum_t_value);
}
inline bool ErrorType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ErrorType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ErrorType>(
    ErrorType_descriptor(), name, value);
}
// ===================================================================

class Message final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:click.protobuf.Message) */ {
 public:
  inline Message() : Message(nullptr) {}
  ~Message() override;
  explicit PROTOBUF_CONSTEXPR Message(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Message(const Message& from);
  Message(Message&& from) noexcept
    : Message() {
    *this = ::std::move(from);
  }

  inline Message& operator=(const Message& from) {
    CopyFrom(from);
    return *this;
  }
  inline Message& operator=(Message&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Message& default_instance() {
    return *internal_default_instance();
  }
  static inline const Message* internal_default_instance() {
    return reinterpret_cast<const Message*>(
               &_Message_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Message& a, Message& b) {
    a.Swap(&b);
  }
  inline void Swap(Message* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Message* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Message* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Message>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Message& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Message& from) {
    Message::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Message* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "click.protobuf.Message";
  }
  protected:
  explicit Message(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMessageTypeFieldNumber = 1,
    kIdFieldNumber = 2,
  };
  // .click.protobuf.MessageType messageType = 1;
  void clear_messagetype();
  ::click::protobuf::MessageType messagetype() const;
  void set_messagetype(::click::protobuf::MessageType value);
  private:
  ::click::protobuf::MessageType _internal_messagetype() const;
  void _internal_set_messagetype(::click::protobuf::MessageType value);
  public:

  // int32 id = 2;
  void clear_id();
  int32_t id() const;
  void set_id(int32_t value);
  private:
  int32_t _internal_id() const;
  void _internal_set_id(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:click.protobuf.Message)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int messagetype_;
    int32_t id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Messaging_2eproto;
};
// -------------------------------------------------------------------

class HandshakeInitMessage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:click.protobuf.HandshakeInitMessage) */ {
 public:
  inline HandshakeInitMessage() : HandshakeInitMessage(nullptr) {}
  ~HandshakeInitMessage() override;
  explicit PROTOBUF_CONSTEXPR HandshakeInitMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  HandshakeInitMessage(const HandshakeInitMessage& from);
  HandshakeInitMessage(HandshakeInitMessage&& from) noexcept
    : HandshakeInitMessage() {
    *this = ::std::move(from);
  }

  inline HandshakeInitMessage& operator=(const HandshakeInitMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline HandshakeInitMessage& operator=(HandshakeInitMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const HandshakeInitMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const HandshakeInitMessage* internal_default_instance() {
    return reinterpret_cast<const HandshakeInitMessage*>(
               &_HandshakeInitMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(HandshakeInitMessage& a, HandshakeInitMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(HandshakeInitMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HandshakeInitMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  HandshakeInitMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<HandshakeInitMessage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const HandshakeInitMessage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const HandshakeInitMessage& from) {
    HandshakeInitMessage::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HandshakeInitMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "click.protobuf.HandshakeInitMessage";
  }
  protected:
  explicit HandshakeInitMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMessageTypeFieldNumber = 1,
    kVersionFieldNumber = 2,
  };
  // .click.protobuf.MessageType messageType = 1;
  void clear_messagetype();
  ::click::protobuf::MessageType messagetype() const;
  void set_messagetype(::click::protobuf::MessageType value);
  private:
  ::click::protobuf::MessageType _internal_messagetype() const;
  void _internal_set_messagetype(::click::protobuf::MessageType value);
  public:

  // .click.protobuf.Version version = 2;
  void clear_version();
  ::click::protobuf::Version version() const;
  void set_version(::click::protobuf::Version value);
  private:
  ::click::protobuf::Version _internal_version() const;
  void _internal_set_version(::click::protobuf::Version value);
  public:

  // @@protoc_insertion_point(class_scope:click.protobuf.HandshakeInitMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int messagetype_;
    int version_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Messaging_2eproto;
};
// -------------------------------------------------------------------

class SensorRequestMessage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:click.protobuf.SensorRequestMessage) */ {
 public:
  inline SensorRequestMessage() : SensorRequestMessage(nullptr) {}
  ~SensorRequestMessage() override;
  explicit PROTOBUF_CONSTEXPR SensorRequestMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SensorRequestMessage(const SensorRequestMessage& from);
  SensorRequestMessage(SensorRequestMessage&& from) noexcept
    : SensorRequestMessage() {
    *this = ::std::move(from);
  }

  inline SensorRequestMessage& operator=(const SensorRequestMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline SensorRequestMessage& operator=(SensorRequestMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SensorRequestMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const SensorRequestMessage* internal_default_instance() {
    return reinterpret_cast<const SensorRequestMessage*>(
               &_SensorRequestMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(SensorRequestMessage& a, SensorRequestMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(SensorRequestMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SensorRequestMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SensorRequestMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SensorRequestMessage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SensorRequestMessage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SensorRequestMessage& from) {
    SensorRequestMessage::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SensorRequestMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "click.protobuf.SensorRequestMessage";
  }
  protected:
  explicit SensorRequestMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMessageTypeFieldNumber = 1,
  };
  // .click.protobuf.MessageType messageType = 1;
  void clear_messagetype();
  ::click::protobuf::MessageType messagetype() const;
  void set_messagetype(::click::protobuf::MessageType value);
  private:
  ::click::protobuf::MessageType _internal_messagetype() const;
  void _internal_set_messagetype(::click::protobuf::MessageType value);
  public:

  // @@protoc_insertion_point(class_scope:click.protobuf.SensorRequestMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int messagetype_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Messaging_2eproto;
};
// -------------------------------------------------------------------

class HandshakeMessage_Sensors final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:click.protobuf.HandshakeMessage.Sensors) */ {
 public:
  inline HandshakeMessage_Sensors() : HandshakeMessage_Sensors(nullptr) {}
  ~HandshakeMessage_Sensors() override;
  explicit PROTOBUF_CONSTEXPR HandshakeMessage_Sensors(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  HandshakeMessage_Sensors(const HandshakeMessage_Sensors& from);
  HandshakeMessage_Sensors(HandshakeMessage_Sensors&& from) noexcept
    : HandshakeMessage_Sensors() {
    *this = ::std::move(from);
  }

  inline HandshakeMessage_Sensors& operator=(const HandshakeMessage_Sensors& from) {
    CopyFrom(from);
    return *this;
  }
  inline HandshakeMessage_Sensors& operator=(HandshakeMessage_Sensors&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const HandshakeMessage_Sensors& default_instance() {
    return *internal_default_instance();
  }
  static inline const HandshakeMessage_Sensors* internal_default_instance() {
    return reinterpret_cast<const HandshakeMessage_Sensors*>(
               &_HandshakeMessage_Sensors_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(HandshakeMessage_Sensors& a, HandshakeMessage_Sensors& b) {
    a.Swap(&b);
  }
  inline void Swap(HandshakeMessage_Sensors* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HandshakeMessage_Sensors* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  HandshakeMessage_Sensors* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<HandshakeMessage_Sensors>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const HandshakeMessage_Sensors& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const HandshakeMessage_Sensors& from) {
    HandshakeMessage_Sensors::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HandshakeMessage_Sensors* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "click.protobuf.HandshakeMessage.Sensors";
  }
  protected:
  explicit HandshakeMessage_Sensors(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTypesFieldNumber = 1,
  };
  // repeated .click.protobuf.ValueType types = 1;
  int types_size() const;
  private:
  int _internal_types_size() const;
  public:
  void clear_types();
  private:
  ::click::protobuf::ValueType _internal_types(int index) const;
  void _internal_add_types(::click::protobuf::ValueType value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* _internal_mutable_types();
  public:
  ::click::protobuf::ValueType types(int index) const;
  void set_types(int index, ::click::protobuf::ValueType value);
  void add_types(::click::protobuf::ValueType value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>& types() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* mutable_types();

  // @@protoc_insertion_point(class_scope:click.protobuf.HandshakeMessage.Sensors)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedField<int> types_;
    mutable std::atomic<int> _types_cached_byte_size_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Messaging_2eproto;
};
// -------------------------------------------------------------------

class HandshakeMessage_Object_ControlEventsEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<HandshakeMessage_Object_ControlEventsEntry_DoNotUse, 
    std::string, ::click::protobuf::ValueType,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_ENUM> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<HandshakeMessage_Object_ControlEventsEntry_DoNotUse, 
    std::string, ::click::protobuf::ValueType,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_ENUM> SuperType;
  HandshakeMessage_Object_ControlEventsEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR HandshakeMessage_Object_ControlEventsEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit HandshakeMessage_Object_ControlEventsEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const HandshakeMessage_Object_ControlEventsEntry_DoNotUse& other);
  static const HandshakeMessage_Object_ControlEventsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const HandshakeMessage_Object_ControlEventsEntry_DoNotUse*>(&_HandshakeMessage_Object_ControlEventsEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "click.protobuf.HandshakeMessage.Object.ControlEventsEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_Messaging_2eproto;
};

// -------------------------------------------------------------------

class HandshakeMessage_Object_SensorsEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<HandshakeMessage_Object_SensorsEntry_DoNotUse, 
    std::string, ::click::protobuf::HandshakeMessage_Sensors,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<HandshakeMessage_Object_SensorsEntry_DoNotUse, 
    std::string, ::click::protobuf::HandshakeMessage_Sensors,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> SuperType;
  HandshakeMessage_Object_SensorsEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR HandshakeMessage_Object_SensorsEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit HandshakeMessage_Object_SensorsEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const HandshakeMessage_Object_SensorsEntry_DoNotUse& other);
  static const HandshakeMessage_Object_SensorsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const HandshakeMessage_Object_SensorsEntry_DoNotUse*>(&_HandshakeMessage_Object_SensorsEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "click.protobuf.HandshakeMessage.Object.SensorsEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_Messaging_2eproto;
};

// -------------------------------------------------------------------

class HandshakeMessage_Object final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:click.protobuf.HandshakeMessage.Object) */ {
 public:
  inline HandshakeMessage_Object() : HandshakeMessage_Object(nullptr) {}
  ~HandshakeMessage_Object() override;
  explicit PROTOBUF_CONSTEXPR HandshakeMessage_Object(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  HandshakeMessage_Object(const HandshakeMessage_Object& from);
  HandshakeMessage_Object(HandshakeMessage_Object&& from) noexcept
    : HandshakeMessage_Object() {
    *this = ::std::move(from);
  }

  inline HandshakeMessage_Object& operator=(const HandshakeMessage_Object& from) {
    CopyFrom(from);
    return *this;
  }
  inline HandshakeMessage_Object& operator=(HandshakeMessage_Object&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const HandshakeMessage_Object& default_instance() {
    return *internal_default_instance();
  }
  static inline const HandshakeMessage_Object* internal_default_instance() {
    return reinterpret_cast<const HandshakeMessage_Object*>(
               &_HandshakeMessage_Object_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(HandshakeMessage_Object& a, HandshakeMessage_Object& b) {
    a.Swap(&b);
  }
  inline void Swap(HandshakeMessage_Object* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HandshakeMessage_Object* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  HandshakeMessage_Object* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<HandshakeMessage_Object>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const HandshakeMessage_Object& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const HandshakeMessage_Object& from) {
    HandshakeMessage_Object::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HandshakeMessage_Object* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "click.protobuf.HandshakeMessage.Object";
  }
  protected:
  explicit HandshakeMessage_Object(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kControlsInOrderFieldNumber = 1,
    kJointSensorsFieldNumber = 2,
    kControlEventsFieldNumber = 3,
    kSensorsFieldNumber = 4,
    kObjectSensorsFieldNumber = 6,
    kJointSensorsInOrderFieldNumber = 7,
    kControlTypesInOrderFieldNumber = 8,
  };
  // repeated string controlsInOrder = 1;
  int controlsinorder_size() const;
  private:
  int _internal_controlsinorder_size() const;
  public:
  void clear_controlsinorder();
  const std::string& controlsinorder(int index) const;
  std::string* mutable_controlsinorder(int index);
  void set_controlsinorder(int index, const std::string& value);
  void set_controlsinorder(int index, std::string&& value);
  void set_controlsinorder(int index, const char* value);
  void set_controlsinorder(int index, const char* value, size_t size);
  std::string* add_controlsinorder();
  void add_controlsinorder(const std::string& value);
  void add_controlsinorder(std::string&& value);
  void add_controlsinorder(const char* value);
  void add_controlsinorder(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& controlsinorder() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_controlsinorder();
  private:
  const std::string& _internal_controlsinorder(int index) const;
  std::string* _internal_add_controlsinorder();
  public:

  // repeated .click.protobuf.ValueType jointSensors = 2;
  int jointsensors_size() const;
  private:
  int _internal_jointsensors_size() const;
  public:
  void clear_jointsensors();
  private:
  ::click::protobuf::ValueType _internal_jointsensors(int index) const;
  void _internal_add_jointsensors(::click::protobuf::ValueType value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* _internal_mutable_jointsensors();
  public:
  ::click::protobuf::ValueType jointsensors(int index) const;
  void set_jointsensors(int index, ::click::protobuf::ValueType value);
  void add_jointsensors(::click::protobuf::ValueType value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>& jointsensors() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* mutable_jointsensors();

  // map<string, .click.protobuf.ValueType> controlEvents = 3;
  int controlevents_size() const;
  private:
  int _internal_controlevents_size() const;
  public:
  void clear_controlevents();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::click::protobuf::ValueType >&
      _internal_controlevents() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::click::protobuf::ValueType >*
      _internal_mutable_controlevents();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::click::protobuf::ValueType >&
      controlevents() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::click::protobuf::ValueType >*
      mutable_controlevents();

  // map<string, .click.protobuf.HandshakeMessage.Sensors> sensors = 4;
  int sensors_size() const;
  private:
  int _internal_sensors_size() const;
  public:
  void clear_sensors();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::click::protobuf::HandshakeMessage_Sensors >&
      _internal_sensors() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::click::protobuf::HandshakeMessage_Sensors >*
      _internal_mutable_sensors();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::click::protobuf::HandshakeMessage_Sensors >&
      sensors() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::click::protobuf::HandshakeMessage_Sensors >*
      mutable_sensors();

  // repeated .click.protobuf.ValueType objectSensors = 6;
  int objectsensors_size() const;
  private:
  int _internal_objectsensors_size() const;
  public:
  void clear_objectsensors();
  private:
  ::click::protobuf::ValueType _internal_objectsensors(int index) const;
  void _internal_add_objectsensors(::click::protobuf::ValueType value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* _internal_mutable_objectsensors();
  public:
  ::click::protobuf::ValueType objectsensors(int index) const;
  void set_objectsensors(int index, ::click::protobuf::ValueType value);
  void add_objectsensors(::click::protobuf::ValueType value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>& objectsensors() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* mutable_objectsensors();

  // repeated string jointSensorsInOrder = 7;
  int jointsensorsinorder_size() const;
  private:
  int _internal_jointsensorsinorder_size() const;
  public:
  void clear_jointsensorsinorder();
  const std::string& jointsensorsinorder(int index) const;
  std::string* mutable_jointsensorsinorder(int index);
  void set_jointsensorsinorder(int index, const std::string& value);
  void set_jointsensorsinorder(int index, std::string&& value);
  void set_jointsensorsinorder(int index, const char* value);
  void set_jointsensorsinorder(int index, const char* value, size_t size);
  std::string* add_jointsensorsinorder();
  void add_jointsensorsinorder(const std::string& value);
  void add_jointsensorsinorder(std::string&& value);
  void add_jointsensorsinorder(const char* value);
  void add_jointsensorsinorder(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& jointsensorsinorder() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_jointsensorsinorder();
  private:
  const std::string& _internal_jointsensorsinorder(int index) const;
  std::string* _internal_add_jointsensorsinorder();
  public:

  // repeated .click.protobuf.ValueType controlTypesInOrder = 8;
  int controltypesinorder_size() const;
  private:
  int _internal_controltypesinorder_size() const;
  public:
  void clear_controltypesinorder();
  private:
  ::click::protobuf::ValueType _internal_controltypesinorder(int index) const;
  void _internal_add_controltypesinorder(::click::protobuf::ValueType value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* _internal_mutable_controltypesinorder();
  public:
  ::click::protobuf::ValueType controltypesinorder(int index) const;
  void set_controltypesinorder(int index, ::click::protobuf::ValueType value);
  void add_controltypesinorder(::click::protobuf::ValueType value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>& controltypesinorder() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* mutable_controltypesinorder();

  // @@protoc_insertion_point(class_scope:click.protobuf.HandshakeMessage.Object)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> controlsinorder_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField<int> jointsensors_;
    mutable std::atomic<int> _jointsensors_cached_byte_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        HandshakeMessage_Object_ControlEventsEntry_DoNotUse,
        std::string, ::click::protobuf::ValueType,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_ENUM> controlevents_;
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        HandshakeMessage_Object_SensorsEntry_DoNotUse,
        std::string, ::click::protobuf::HandshakeMessage_Sensors,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> sensors_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField<int> objectsensors_;
    mutable std::atomic<int> _objectsensors_cached_byte_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> jointsensorsinorder_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField<int> controltypesinorder_;
    mutable std::atomic<int> _controltypesinorder_cached_byte_size_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Messaging_2eproto;
};
// -------------------------------------------------------------------

class HandshakeMessage_SimulationSettings final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:click.protobuf.HandshakeMessage.SimulationSettings) */ {
 public:
  inline HandshakeMessage_SimulationSettings() : HandshakeMessage_SimulationSettings(nullptr) {}
  ~HandshakeMessage_SimulationSettings() override;
  explicit PROTOBUF_CONSTEXPR HandshakeMessage_SimulationSettings(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  HandshakeMessage_SimulationSettings(const HandshakeMessage_SimulationSettings& from);
  HandshakeMessage_SimulationSettings(HandshakeMessage_SimulationSettings&& from) noexcept
    : HandshakeMessage_SimulationSettings() {
    *this = ::std::move(from);
  }

  inline HandshakeMessage_SimulationSettings& operator=(const HandshakeMessage_SimulationSettings& from) {
    CopyFrom(from);
    return *this;
  }
  inline HandshakeMessage_SimulationSettings& operator=(HandshakeMessage_SimulationSettings&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const HandshakeMessage_SimulationSettings& default_instance() {
    return *internal_default_instance();
  }
  static inline const HandshakeMessage_SimulationSettings* internal_default_instance() {
    return reinterpret_cast<const HandshakeMessage_SimulationSettings*>(
               &_HandshakeMessage_SimulationSettings_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(HandshakeMessage_SimulationSettings& a, HandshakeMessage_SimulationSettings& b) {
    a.Swap(&b);
  }
  inline void Swap(HandshakeMessage_SimulationSettings* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HandshakeMessage_SimulationSettings* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  HandshakeMessage_SimulationSettings* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<HandshakeMessage_SimulationSettings>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const HandshakeMessage_SimulationSettings& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const HandshakeMessage_SimulationSettings& from) {
    HandshakeMessage_SimulationSettings::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HandshakeMessage_SimulationSettings* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "click.protobuf.HandshakeMessage.SimulationSettings";
  }
  protected:
  explicit HandshakeMessage_SimulationSettings(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTimeStepFieldNumber = 1,
  };
  // double timeStep = 1;
  void clear_timestep();
  double timestep() const;
  void set_timestep(double value);
  private:
  double _internal_timestep() const;
  void _internal_set_timestep(double value);
  public:

  // @@protoc_insertion_point(class_scope:click.protobuf.HandshakeMessage.SimulationSettings)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    double timestep_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Messaging_2eproto;
};
// -------------------------------------------------------------------

class HandshakeMessage_ObjectsEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<HandshakeMessage_ObjectsEntry_DoNotUse, 
    std::string, ::click::protobuf::HandshakeMessage_Object,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<HandshakeMessage_ObjectsEntry_DoNotUse, 
    std::string, ::click::protobuf::HandshakeMessage_Object,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> SuperType;
  HandshakeMessage_ObjectsEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR HandshakeMessage_ObjectsEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit HandshakeMessage_ObjectsEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const HandshakeMessage_ObjectsEntry_DoNotUse& other);
  static const HandshakeMessage_ObjectsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const HandshakeMessage_ObjectsEntry_DoNotUse*>(&_HandshakeMessage_ObjectsEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "click.protobuf.HandshakeMessage.ObjectsEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_Messaging_2eproto;
};

// -------------------------------------------------------------------

class HandshakeMessage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:click.protobuf.HandshakeMessage) */ {
 public:
  inline HandshakeMessage() : HandshakeMessage(nullptr) {}
  ~HandshakeMessage() override;
  explicit PROTOBUF_CONSTEXPR HandshakeMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  HandshakeMessage(const HandshakeMessage& from);
  HandshakeMessage(HandshakeMessage&& from) noexcept
    : HandshakeMessage() {
    *this = ::std::move(from);
  }

  inline HandshakeMessage& operator=(const HandshakeMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline HandshakeMessage& operator=(HandshakeMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const HandshakeMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const HandshakeMessage* internal_default_instance() {
    return reinterpret_cast<const HandshakeMessage*>(
               &_HandshakeMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(HandshakeMessage& a, HandshakeMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(HandshakeMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HandshakeMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  HandshakeMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<HandshakeMessage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const HandshakeMessage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const HandshakeMessage& from) {
    HandshakeMessage::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HandshakeMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "click.protobuf.HandshakeMessage";
  }
  protected:
  explicit HandshakeMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef HandshakeMessage_Sensors Sensors;
  typedef HandshakeMessage_Object Object;
  typedef HandshakeMessage_SimulationSettings SimulationSettings;

  // accessors -------------------------------------------------------

  enum : int {
    kObjectsFieldNumber = 4,
    kSimSettingsFieldNumber = 5,
    kMessageTypeFieldNumber = 1,
    kVersionFieldNumber = 2,
    kControlTypeFieldNumber = 3,
  };
  // map<string, .click.protobuf.HandshakeMessage.Object> objects = 4;
  int objects_size() const;
  private:
  int _internal_objects_size() const;
  public:
  void clear_objects();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::click::protobuf::HandshakeMessage_Object >&
      _internal_objects() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::click::protobuf::HandshakeMessage_Object >*
      _internal_mutable_objects();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::click::protobuf::HandshakeMessage_Object >&
      objects() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::click::protobuf::HandshakeMessage_Object >*
      mutable_objects();

  // .click.protobuf.HandshakeMessage.SimulationSettings simSettings = 5;
  bool has_simsettings() const;
  private:
  bool _internal_has_simsettings() const;
  public:
  void clear_simsettings();
  const ::click::protobuf::HandshakeMessage_SimulationSettings& simsettings() const;
  PROTOBUF_NODISCARD ::click::protobuf::HandshakeMessage_SimulationSettings* release_simsettings();
  ::click::protobuf::HandshakeMessage_SimulationSettings* mutable_simsettings();
  void set_allocated_simsettings(::click::protobuf::HandshakeMessage_SimulationSettings* simsettings);
  private:
  const ::click::protobuf::HandshakeMessage_SimulationSettings& _internal_simsettings() const;
  ::click::protobuf::HandshakeMessage_SimulationSettings* _internal_mutable_simsettings();
  public:
  void unsafe_arena_set_allocated_simsettings(
      ::click::protobuf::HandshakeMessage_SimulationSettings* simsettings);
  ::click::protobuf::HandshakeMessage_SimulationSettings* unsafe_arena_release_simsettings();

  // .click.protobuf.MessageType messageType = 1;
  void clear_messagetype();
  ::click::protobuf::MessageType messagetype() const;
  void set_messagetype(::click::protobuf::MessageType value);
  private:
  ::click::protobuf::MessageType _internal_messagetype() const;
  void _internal_set_messagetype(::click::protobuf::MessageType value);
  public:

  // .click.protobuf.Version version = 2;
  void clear_version();
  ::click::protobuf::Version version() const;
  void set_version(::click::protobuf::Version value);
  private:
  ::click::protobuf::Version _internal_version() const;
  void _internal_set_version(::click::protobuf::Version value);
  public:

  // .click.protobuf.ValueType controlType = 3;
  void clear_controltype();
  ::click::protobuf::ValueType controltype() const;
  void set_controltype(::click::protobuf::ValueType value);
  private:
  ::click::protobuf::ValueType _internal_controltype() const;
  void _internal_set_controltype(::click::protobuf::ValueType value);
  public:

  // @@protoc_insertion_point(class_scope:click.protobuf.HandshakeMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        HandshakeMessage_ObjectsEntry_DoNotUse,
        std::string, ::click::protobuf::HandshakeMessage_Object,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> objects_;
    ::click::protobuf::HandshakeMessage_SimulationSettings* simsettings_;
    int messagetype_;
    int version_;
    int controltype_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Messaging_2eproto;
};
// -------------------------------------------------------------------

class ControlMessage_Object_ControlEventsEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<ControlMessage_Object_ControlEventsEntry_DoNotUse, 
    std::string, bool,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_BOOL> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<ControlMessage_Object_ControlEventsEntry_DoNotUse, 
    std::string, bool,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_BOOL> SuperType;
  ControlMessage_Object_ControlEventsEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR ControlMessage_Object_ControlEventsEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit ControlMessage_Object_ControlEventsEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const ControlMessage_Object_ControlEventsEntry_DoNotUse& other);
  static const ControlMessage_Object_ControlEventsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const ControlMessage_Object_ControlEventsEntry_DoNotUse*>(&_ControlMessage_Object_ControlEventsEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "click.protobuf.ControlMessage.Object.ControlEventsEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_Messaging_2eproto;
};

// -------------------------------------------------------------------

class ControlMessage_Object final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:click.protobuf.ControlMessage.Object) */ {
 public:
  inline ControlMessage_Object() : ControlMessage_Object(nullptr) {}
  ~ControlMessage_Object() override;
  explicit PROTOBUF_CONSTEXPR ControlMessage_Object(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ControlMessage_Object(const ControlMessage_Object& from);
  ControlMessage_Object(ControlMessage_Object&& from) noexcept
    : ControlMessage_Object() {
    *this = ::std::move(from);
  }

  inline ControlMessage_Object& operator=(const ControlMessage_Object& from) {
    CopyFrom(from);
    return *this;
  }
  inline ControlMessage_Object& operator=(ControlMessage_Object&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ControlMessage_Object& default_instance() {
    return *internal_default_instance();
  }
  static inline const ControlMessage_Object* internal_default_instance() {
    return reinterpret_cast<const ControlMessage_Object*>(
               &_ControlMessage_Object_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(ControlMessage_Object& a, ControlMessage_Object& b) {
    a.Swap(&b);
  }
  inline void Swap(ControlMessage_Object* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ControlMessage_Object* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ControlMessage_Object* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ControlMessage_Object>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ControlMessage_Object& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ControlMessage_Object& from) {
    ControlMessage_Object::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ControlMessage_Object* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "click.protobuf.ControlMessage.Object";
  }
  protected:
  explicit ControlMessage_Object(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kAnglesFieldNumber = 1,
    kAngularVelocitiesFieldNumber = 2,
    kTorquesFieldNumber = 3,
    kControlEventsFieldNumber = 4,
    kValuesFieldNumber = 5,
  };
  // repeated double angles = 1;
  int angles_size() const;
  private:
  int _internal_angles_size() const;
  public:
  void clear_angles();
  private:
  double _internal_angles(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
      _internal_angles() const;
  void _internal_add_angles(double value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
      _internal_mutable_angles();
  public:
  double angles(int index) const;
  void set_angles(int index, double value);
  void add_angles(double value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
      angles() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
      mutable_angles();

  // repeated double angularVelocities = 2;
  int angularvelocities_size() const;
  private:
  int _internal_angularvelocities_size() const;
  public:
  void clear_angularvelocities();
  private:
  double _internal_angularvelocities(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
      _internal_angularvelocities() const;
  void _internal_add_angularvelocities(double value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
      _internal_mutable_angularvelocities();
  public:
  double angularvelocities(int index) const;
  void set_angularvelocities(int index, double value);
  void add_angularvelocities(double value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
      angularvelocities() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
      mutable_angularvelocities();

  // repeated double torques = 3;
  int torques_size() const;
  private:
  int _internal_torques_size() const;
  public:
  void clear_torques();
  private:
  double _internal_torques(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
      _internal_torques() const;
  void _internal_add_torques(double value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
      _internal_mutable_torques();
  public:
  double torques(int index) const;
  void set_torques(int index, double value);
  void add_torques(double value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
      torques() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
      mutable_torques();

  // map<string, bool> controlEvents = 4;
  int controlevents_size() const;
  private:
  int _internal_controlevents_size() const;
  public:
  void clear_controlevents();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, bool >&
      _internal_controlevents() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, bool >*
      _internal_mutable_controlevents();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, bool >&
      controlevents() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, bool >*
      mutable_controlevents();

  // repeated double values = 5;
  int values_size() const;
  private:
  int _internal_values_size() const;
  public:
  void clear_values();
  private:
  double _internal_values(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
      _internal_values() const;
  void _internal_add_values(double value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
      _internal_mutable_values();
  public:
  double values(int index) const;
  void set_values(int index, double value);
  void add_values(double value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
      values() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
      mutable_values();

  // @@protoc_insertion_point(class_scope:click.protobuf.ControlMessage.Object)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< double > angles_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< double > angularvelocities_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< double > torques_;
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        ControlMessage_Object_ControlEventsEntry_DoNotUse,
        std::string, bool,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_BOOL> controlevents_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< double > values_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Messaging_2eproto;
};
// -------------------------------------------------------------------

class ControlMessage_ObjectsEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<ControlMessage_ObjectsEntry_DoNotUse, 
    std::string, ::click::protobuf::ControlMessage_Object,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<ControlMessage_ObjectsEntry_DoNotUse, 
    std::string, ::click::protobuf::ControlMessage_Object,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> SuperType;
  ControlMessage_ObjectsEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR ControlMessage_ObjectsEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit ControlMessage_ObjectsEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const ControlMessage_ObjectsEntry_DoNotUse& other);
  static const ControlMessage_ObjectsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const ControlMessage_ObjectsEntry_DoNotUse*>(&_ControlMessage_ObjectsEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "click.protobuf.ControlMessage.ObjectsEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_Messaging_2eproto;
};

// -------------------------------------------------------------------

class ControlMessage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:click.protobuf.ControlMessage) */ {
 public:
  inline ControlMessage() : ControlMessage(nullptr) {}
  ~ControlMessage() override;
  explicit PROTOBUF_CONSTEXPR ControlMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ControlMessage(const ControlMessage& from);
  ControlMessage(ControlMessage&& from) noexcept
    : ControlMessage() {
    *this = ::std::move(from);
  }

  inline ControlMessage& operator=(const ControlMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline ControlMessage& operator=(ControlMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ControlMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const ControlMessage* internal_default_instance() {
    return reinterpret_cast<const ControlMessage*>(
               &_ControlMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(ControlMessage& a, ControlMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(ControlMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ControlMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ControlMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ControlMessage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ControlMessage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ControlMessage& from) {
    ControlMessage::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ControlMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "click.protobuf.ControlMessage";
  }
  protected:
  explicit ControlMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ControlMessage_Object Object;

  // accessors -------------------------------------------------------

  enum : int {
    kObjectsFieldNumber = 2,
    kMessageTypeFieldNumber = 1,
  };
  // map<string, .click.protobuf.ControlMessage.Object> objects = 2;
  int objects_size() const;
  private:
  int _internal_objects_size() const;
  public:
  void clear_objects();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::click::protobuf::ControlMessage_Object >&
      _internal_objects() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::click::protobuf::ControlMessage_Object >*
      _internal_mutable_objects();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::click::protobuf::ControlMessage_Object >&
      objects() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::click::protobuf::ControlMessage_Object >*
      mutable_objects();

  // .click.protobuf.MessageType messageType = 1;
  void clear_messagetype();
  ::click::protobuf::MessageType messagetype() const;
  void set_messagetype(::click::protobuf::MessageType value);
  private:
  ::click::protobuf::MessageType _internal_messagetype() const;
  void _internal_set_messagetype(::click::protobuf::MessageType value);
  public:

  // @@protoc_insertion_point(class_scope:click.protobuf.ControlMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        ControlMessage_ObjectsEntry_DoNotUse,
        std::string, ::click::protobuf::ControlMessage_Object,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> objects_;
    int messagetype_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Messaging_2eproto;
};
// -------------------------------------------------------------------

class SensorMessage_Vec3 final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:click.protobuf.SensorMessage.Vec3) */ {
 public:
  inline SensorMessage_Vec3() : SensorMessage_Vec3(nullptr) {}
  ~SensorMessage_Vec3() override;
  explicit PROTOBUF_CONSTEXPR SensorMessage_Vec3(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SensorMessage_Vec3(const SensorMessage_Vec3& from);
  SensorMessage_Vec3(SensorMessage_Vec3&& from) noexcept
    : SensorMessage_Vec3() {
    *this = ::std::move(from);
  }

  inline SensorMessage_Vec3& operator=(const SensorMessage_Vec3& from) {
    CopyFrom(from);
    return *this;
  }
  inline SensorMessage_Vec3& operator=(SensorMessage_Vec3&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SensorMessage_Vec3& default_instance() {
    return *internal_default_instance();
  }
  static inline const SensorMessage_Vec3* internal_default_instance() {
    return reinterpret_cast<const SensorMessage_Vec3*>(
               &_SensorMessage_Vec3_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(SensorMessage_Vec3& a, SensorMessage_Vec3& b) {
    a.Swap(&b);
  }
  inline void Swap(SensorMessage_Vec3* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SensorMessage_Vec3* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SensorMessage_Vec3* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SensorMessage_Vec3>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SensorMessage_Vec3& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SensorMessage_Vec3& from) {
    SensorMessage_Vec3::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SensorMessage_Vec3* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "click.protobuf.SensorMessage.Vec3";
  }
  protected:
  explicit SensorMessage_Vec3(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kArrFieldNumber = 1,
  };
  // repeated double arr = 1;
  int arr_size() const;
  private:
  int _internal_arr_size() const;
  public:
  void clear_arr();
  private:
  double _internal_arr(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
      _internal_arr() const;
  void _internal_add_arr(double value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
      _internal_mutable_arr();
  public:
  double arr(int index) const;
  void set_arr(int index, double value);
  void add_arr(double value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
      arr() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
      mutable_arr();

  // @@protoc_insertion_point(class_scope:click.protobuf.SensorMessage.Vec3)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< double > arr_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Messaging_2eproto;
};
// -------------------------------------------------------------------

class SensorMessage_Sensor final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:click.protobuf.SensorMessage.Sensor) */ {
 public:
  inline SensorMessage_Sensor() : SensorMessage_Sensor(nullptr) {}
  ~SensorMessage_Sensor() override;
  explicit PROTOBUF_CONSTEXPR SensorMessage_Sensor(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SensorMessage_Sensor(const SensorMessage_Sensor& from);
  SensorMessage_Sensor(SensorMessage_Sensor&& from) noexcept
    : SensorMessage_Sensor() {
    *this = ::std::move(from);
  }

  inline SensorMessage_Sensor& operator=(const SensorMessage_Sensor& from) {
    CopyFrom(from);
    return *this;
  }
  inline SensorMessage_Sensor& operator=(SensorMessage_Sensor&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SensorMessage_Sensor& default_instance() {
    return *internal_default_instance();
  }
  enum ValueCase {
    kAngle = 1,
    kAngularVelocity1D = 2,
    kTorque1D = 3,
    kPosition = 4,
    kRpy = 5,
    kActivated = 6,
    kAcceleration3D = 7,
    kForce3D = 8,
    kTorque3D = 9,
    kAngularAcceleration3D = 10,
    kVelocity3D = 12,
    kAngularVelocity3D = 13,
    kForce1D = 14,
    VALUE_NOT_SET = 0,
  };

  static inline const SensorMessage_Sensor* internal_default_instance() {
    return reinterpret_cast<const SensorMessage_Sensor*>(
               &_SensorMessage_Sensor_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(SensorMessage_Sensor& a, SensorMessage_Sensor& b) {
    a.Swap(&b);
  }
  inline void Swap(SensorMessage_Sensor* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SensorMessage_Sensor* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SensorMessage_Sensor* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SensorMessage_Sensor>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SensorMessage_Sensor& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SensorMessage_Sensor& from) {
    SensorMessage_Sensor::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SensorMessage_Sensor* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "click.protobuf.SensorMessage.Sensor";
  }
  protected:
  explicit SensorMessage_Sensor(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAngleFieldNumber = 1,
    kAngularVelocity1DFieldNumber = 2,
    kTorque1DFieldNumber = 3,
    kPositionFieldNumber = 4,
    kRpyFieldNumber = 5,
    kActivatedFieldNumber = 6,
    kAcceleration3DFieldNumber = 7,
    kForce3DFieldNumber = 8,
    kTorque3DFieldNumber = 9,
    kAngularAcceleration3DFieldNumber = 10,
    kVelocity3DFieldNumber = 12,
    kAngularVelocity3DFieldNumber = 13,
    kForce1DFieldNumber = 14,
  };
  // double angle = 1;
  bool has_angle() const;
  private:
  bool _internal_has_angle() const;
  public:
  void clear_angle();
  double angle() const;
  void set_angle(double value);
  private:
  double _internal_angle() const;
  void _internal_set_angle(double value);
  public:

  // double angularVelocity1d = 2;
  bool has_angularvelocity1d() const;
  private:
  bool _internal_has_angularvelocity1d() const;
  public:
  void clear_angularvelocity1d();
  double angularvelocity1d() const;
  void set_angularvelocity1d(double value);
  private:
  double _internal_angularvelocity1d() const;
  void _internal_set_angularvelocity1d(double value);
  public:

  // double torque1d = 3;
  bool has_torque1d() const;
  private:
  bool _internal_has_torque1d() const;
  public:
  void clear_torque1d();
  double torque1d() const;
  void set_torque1d(double value);
  private:
  double _internal_torque1d() const;
  void _internal_set_torque1d(double value);
  public:

  // .click.protobuf.SensorMessage.Vec3 position = 4;
  bool has_position() const;
  private:
  bool _internal_has_position() const;
  public:
  void clear_position();
  const ::click::protobuf::SensorMessage_Vec3& position() const;
  PROTOBUF_NODISCARD ::click::protobuf::SensorMessage_Vec3* release_position();
  ::click::protobuf::SensorMessage_Vec3* mutable_position();
  void set_allocated_position(::click::protobuf::SensorMessage_Vec3* position);
  private:
  const ::click::protobuf::SensorMessage_Vec3& _internal_position() const;
  ::click::protobuf::SensorMessage_Vec3* _internal_mutable_position();
  public:
  void unsafe_arena_set_allocated_position(
      ::click::protobuf::SensorMessage_Vec3* position);
  ::click::protobuf::SensorMessage_Vec3* unsafe_arena_release_position();

  // .click.protobuf.SensorMessage.Vec3 rpy = 5;
  bool has_rpy() const;
  private:
  bool _internal_has_rpy() const;
  public:
  void clear_rpy();
  const ::click::protobuf::SensorMessage_Vec3& rpy() const;
  PROTOBUF_NODISCARD ::click::protobuf::SensorMessage_Vec3* release_rpy();
  ::click::protobuf::SensorMessage_Vec3* mutable_rpy();
  void set_allocated_rpy(::click::protobuf::SensorMessage_Vec3* rpy);
  private:
  const ::click::protobuf::SensorMessage_Vec3& _internal_rpy() const;
  ::click::protobuf::SensorMessage_Vec3* _internal_mutable_rpy();
  public:
  void unsafe_arena_set_allocated_rpy(
      ::click::protobuf::SensorMessage_Vec3* rpy);
  ::click::protobuf::SensorMessage_Vec3* unsafe_arena_release_rpy();

  // bool activated = 6;
  bool has_activated() const;
  private:
  bool _internal_has_activated() const;
  public:
  void clear_activated();
  bool activated() const;
  void set_activated(bool value);
  private:
  bool _internal_activated() const;
  void _internal_set_activated(bool value);
  public:

  // .click.protobuf.SensorMessage.Vec3 acceleration3d = 7;
  bool has_acceleration3d() const;
  private:
  bool _internal_has_acceleration3d() const;
  public:
  void clear_acceleration3d();
  const ::click::protobuf::SensorMessage_Vec3& acceleration3d() const;
  PROTOBUF_NODISCARD ::click::protobuf::SensorMessage_Vec3* release_acceleration3d();
  ::click::protobuf::SensorMessage_Vec3* mutable_acceleration3d();
  void set_allocated_acceleration3d(::click::protobuf::SensorMessage_Vec3* acceleration3d);
  private:
  const ::click::protobuf::SensorMessage_Vec3& _internal_acceleration3d() const;
  ::click::protobuf::SensorMessage_Vec3* _internal_mutable_acceleration3d();
  public:
  void unsafe_arena_set_allocated_acceleration3d(
      ::click::protobuf::SensorMessage_Vec3* acceleration3d);
  ::click::protobuf::SensorMessage_Vec3* unsafe_arena_release_acceleration3d();

  // .click.protobuf.SensorMessage.Vec3 force3d = 8;
  bool has_force3d() const;
  private:
  bool _internal_has_force3d() const;
  public:
  void clear_force3d();
  const ::click::protobuf::SensorMessage_Vec3& force3d() const;
  PROTOBUF_NODISCARD ::click::protobuf::SensorMessage_Vec3* release_force3d();
  ::click::protobuf::SensorMessage_Vec3* mutable_force3d();
  void set_allocated_force3d(::click::protobuf::SensorMessage_Vec3* force3d);
  private:
  const ::click::protobuf::SensorMessage_Vec3& _internal_force3d() const;
  ::click::protobuf::SensorMessage_Vec3* _internal_mutable_force3d();
  public:
  void unsafe_arena_set_allocated_force3d(
      ::click::protobuf::SensorMessage_Vec3* force3d);
  ::click::protobuf::SensorMessage_Vec3* unsafe_arena_release_force3d();

  // .click.protobuf.SensorMessage.Vec3 torque3d = 9;
  bool has_torque3d() const;
  private:
  bool _internal_has_torque3d() const;
  public:
  void clear_torque3d();
  const ::click::protobuf::SensorMessage_Vec3& torque3d() const;
  PROTOBUF_NODISCARD ::click::protobuf::SensorMessage_Vec3* release_torque3d();
  ::click::protobuf::SensorMessage_Vec3* mutable_torque3d();
  void set_allocated_torque3d(::click::protobuf::SensorMessage_Vec3* torque3d);
  private:
  const ::click::protobuf::SensorMessage_Vec3& _internal_torque3d() const;
  ::click::protobuf::SensorMessage_Vec3* _internal_mutable_torque3d();
  public:
  void unsafe_arena_set_allocated_torque3d(
      ::click::protobuf::SensorMessage_Vec3* torque3d);
  ::click::protobuf::SensorMessage_Vec3* unsafe_arena_release_torque3d();

  // .click.protobuf.SensorMessage.Vec3 angularAcceleration3d = 10;
  bool has_angularacceleration3d() const;
  private:
  bool _internal_has_angularacceleration3d() const;
  public:
  void clear_angularacceleration3d();
  const ::click::protobuf::SensorMessage_Vec3& angularacceleration3d() const;
  PROTOBUF_NODISCARD ::click::protobuf::SensorMessage_Vec3* release_angularacceleration3d();
  ::click::protobuf::SensorMessage_Vec3* mutable_angularacceleration3d();
  void set_allocated_angularacceleration3d(::click::protobuf::SensorMessage_Vec3* angularacceleration3d);
  private:
  const ::click::protobuf::SensorMessage_Vec3& _internal_angularacceleration3d() const;
  ::click::protobuf::SensorMessage_Vec3* _internal_mutable_angularacceleration3d();
  public:
  void unsafe_arena_set_allocated_angularacceleration3d(
      ::click::protobuf::SensorMessage_Vec3* angularacceleration3d);
  ::click::protobuf::SensorMessage_Vec3* unsafe_arena_release_angularacceleration3d();

  // .click.protobuf.SensorMessage.Vec3 velocity3d = 12;
  bool has_velocity3d() const;
  private:
  bool _internal_has_velocity3d() const;
  public:
  void clear_velocity3d();
  const ::click::protobuf::SensorMessage_Vec3& velocity3d() const;
  PROTOBUF_NODISCARD ::click::protobuf::SensorMessage_Vec3* release_velocity3d();
  ::click::protobuf::SensorMessage_Vec3* mutable_velocity3d();
  void set_allocated_velocity3d(::click::protobuf::SensorMessage_Vec3* velocity3d);
  private:
  const ::click::protobuf::SensorMessage_Vec3& _internal_velocity3d() const;
  ::click::protobuf::SensorMessage_Vec3* _internal_mutable_velocity3d();
  public:
  void unsafe_arena_set_allocated_velocity3d(
      ::click::protobuf::SensorMessage_Vec3* velocity3d);
  ::click::protobuf::SensorMessage_Vec3* unsafe_arena_release_velocity3d();

  // .click.protobuf.SensorMessage.Vec3 angularVelocity3d = 13;
  bool has_angularvelocity3d() const;
  private:
  bool _internal_has_angularvelocity3d() const;
  public:
  void clear_angularvelocity3d();
  const ::click::protobuf::SensorMessage_Vec3& angularvelocity3d() const;
  PROTOBUF_NODISCARD ::click::protobuf::SensorMessage_Vec3* release_angularvelocity3d();
  ::click::protobuf::SensorMessage_Vec3* mutable_angularvelocity3d();
  void set_allocated_angularvelocity3d(::click::protobuf::SensorMessage_Vec3* angularvelocity3d);
  private:
  const ::click::protobuf::SensorMessage_Vec3& _internal_angularvelocity3d() const;
  ::click::protobuf::SensorMessage_Vec3* _internal_mutable_angularvelocity3d();
  public:
  void unsafe_arena_set_allocated_angularvelocity3d(
      ::click::protobuf::SensorMessage_Vec3* angularvelocity3d);
  ::click::protobuf::SensorMessage_Vec3* unsafe_arena_release_angularvelocity3d();

  // double force1d = 14;
  bool has_force1d() const;
  private:
  bool _internal_has_force1d() const;
  public:
  void clear_force1d();
  double force1d() const;
  void set_force1d(double value);
  private:
  double _internal_force1d() const;
  void _internal_set_force1d(double value);
  public:

  void clear_value();
  ValueCase value_case() const;
  // @@protoc_insertion_point(class_scope:click.protobuf.SensorMessage.Sensor)
 private:
  class _Internal;
  void set_has_angle();
  void set_has_angularvelocity1d();
  void set_has_torque1d();
  void set_has_position();
  void set_has_rpy();
  void set_has_activated();
  void set_has_acceleration3d();
  void set_has_force3d();
  void set_has_torque3d();
  void set_has_angularacceleration3d();
  void set_has_velocity3d();
  void set_has_angularvelocity3d();
  void set_has_force1d();

  inline bool has_value() const;
  inline void clear_has_value();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    union ValueUnion {
      constexpr ValueUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      double angle_;
      double angularvelocity1d_;
      double torque1d_;
      ::click::protobuf::SensorMessage_Vec3* position_;
      ::click::protobuf::SensorMessage_Vec3* rpy_;
      bool activated_;
      ::click::protobuf::SensorMessage_Vec3* acceleration3d_;
      ::click::protobuf::SensorMessage_Vec3* force3d_;
      ::click::protobuf::SensorMessage_Vec3* torque3d_;
      ::click::protobuf::SensorMessage_Vec3* angularacceleration3d_;
      ::click::protobuf::SensorMessage_Vec3* velocity3d_;
      ::click::protobuf::SensorMessage_Vec3* angularvelocity3d_;
      double force1d_;
    } value_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Messaging_2eproto;
};
// -------------------------------------------------------------------

class SensorMessage_Sensors final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:click.protobuf.SensorMessage.Sensors) */ {
 public:
  inline SensorMessage_Sensors() : SensorMessage_Sensors(nullptr) {}
  ~SensorMessage_Sensors() override;
  explicit PROTOBUF_CONSTEXPR SensorMessage_Sensors(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SensorMessage_Sensors(const SensorMessage_Sensors& from);
  SensorMessage_Sensors(SensorMessage_Sensors&& from) noexcept
    : SensorMessage_Sensors() {
    *this = ::std::move(from);
  }

  inline SensorMessage_Sensors& operator=(const SensorMessage_Sensors& from) {
    CopyFrom(from);
    return *this;
  }
  inline SensorMessage_Sensors& operator=(SensorMessage_Sensors&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SensorMessage_Sensors& default_instance() {
    return *internal_default_instance();
  }
  static inline const SensorMessage_Sensors* internal_default_instance() {
    return reinterpret_cast<const SensorMessage_Sensors*>(
               &_SensorMessage_Sensors_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(SensorMessage_Sensors& a, SensorMessage_Sensors& b) {
    a.Swap(&b);
  }
  inline void Swap(SensorMessage_Sensors* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SensorMessage_Sensors* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SensorMessage_Sensors* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SensorMessage_Sensors>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SensorMessage_Sensors& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SensorMessage_Sensors& from) {
    SensorMessage_Sensors::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SensorMessage_Sensors* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "click.protobuf.SensorMessage.Sensors";
  }
  protected:
  explicit SensorMessage_Sensors(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSensorFieldNumber = 1,
  };
  // repeated .click.protobuf.SensorMessage.Sensor sensor = 1;
  int sensor_size() const;
  private:
  int _internal_sensor_size() const;
  public:
  void clear_sensor();
  ::click::protobuf::SensorMessage_Sensor* mutable_sensor(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::click::protobuf::SensorMessage_Sensor >*
      mutable_sensor();
  private:
  const ::click::protobuf::SensorMessage_Sensor& _internal_sensor(int index) const;
  ::click::protobuf::SensorMessage_Sensor* _internal_add_sensor();
  public:
  const ::click::protobuf::SensorMessage_Sensor& sensor(int index) const;
  ::click::protobuf::SensorMessage_Sensor* add_sensor();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::click::protobuf::SensorMessage_Sensor >&
      sensor() const;

  // @@protoc_insertion_point(class_scope:click.protobuf.SensorMessage.Sensors)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::click::protobuf::SensorMessage_Sensor > sensor_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Messaging_2eproto;
};
// -------------------------------------------------------------------

class SensorMessage_Object_SensorsEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<SensorMessage_Object_SensorsEntry_DoNotUse, 
    std::string, ::click::protobuf::SensorMessage_Sensors,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<SensorMessage_Object_SensorsEntry_DoNotUse, 
    std::string, ::click::protobuf::SensorMessage_Sensors,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> SuperType;
  SensorMessage_Object_SensorsEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR SensorMessage_Object_SensorsEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit SensorMessage_Object_SensorsEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const SensorMessage_Object_SensorsEntry_DoNotUse& other);
  static const SensorMessage_Object_SensorsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const SensorMessage_Object_SensorsEntry_DoNotUse*>(&_SensorMessage_Object_SensorsEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "click.protobuf.SensorMessage.Object.SensorsEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_Messaging_2eproto;
};

// -------------------------------------------------------------------

class SensorMessage_Object final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:click.protobuf.SensorMessage.Object) */ {
 public:
  inline SensorMessage_Object() : SensorMessage_Object(nullptr) {}
  ~SensorMessage_Object() override;
  explicit PROTOBUF_CONSTEXPR SensorMessage_Object(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SensorMessage_Object(const SensorMessage_Object& from);
  SensorMessage_Object(SensorMessage_Object&& from) noexcept
    : SensorMessage_Object() {
    *this = ::std::move(from);
  }

  inline SensorMessage_Object& operator=(const SensorMessage_Object& from) {
    CopyFrom(from);
    return *this;
  }
  inline SensorMessage_Object& operator=(SensorMessage_Object&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SensorMessage_Object& default_instance() {
    return *internal_default_instance();
  }
  static inline const SensorMessage_Object* internal_default_instance() {
    return reinterpret_cast<const SensorMessage_Object*>(
               &_SensorMessage_Object_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(SensorMessage_Object& a, SensorMessage_Object& b) {
    a.Swap(&b);
  }
  inline void Swap(SensorMessage_Object* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SensorMessage_Object* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SensorMessage_Object* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SensorMessage_Object>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SensorMessage_Object& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SensorMessage_Object& from) {
    SensorMessage_Object::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SensorMessage_Object* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "click.protobuf.SensorMessage.Object";
  }
  protected:
  explicit SensorMessage_Object(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kAngleSensorsFieldNumber = 1,
    kAngularVelocitySensorsFieldNumber = 2,
    kTorqueSensorsFieldNumber = 3,
    kObjectSensorsFieldNumber = 4,
    kForceSensorsFieldNumber = 5,
    kSensorsFieldNumber = 6,
  };
  // repeated double angleSensors = 1;
  int anglesensors_size() const;
  private:
  int _internal_anglesensors_size() const;
  public:
  void clear_anglesensors();
  private:
  double _internal_anglesensors(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
      _internal_anglesensors() const;
  void _internal_add_anglesensors(double value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
      _internal_mutable_anglesensors();
  public:
  double anglesensors(int index) const;
  void set_anglesensors(int index, double value);
  void add_anglesensors(double value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
      anglesensors() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
      mutable_anglesensors();

  // repeated double angularVelocitySensors = 2;
  int angularvelocitysensors_size() const;
  private:
  int _internal_angularvelocitysensors_size() const;
  public:
  void clear_angularvelocitysensors();
  private:
  double _internal_angularvelocitysensors(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
      _internal_angularvelocitysensors() const;
  void _internal_add_angularvelocitysensors(double value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
      _internal_mutable_angularvelocitysensors();
  public:
  double angularvelocitysensors(int index) const;
  void set_angularvelocitysensors(int index, double value);
  void add_angularvelocitysensors(double value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
      angularvelocitysensors() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
      mutable_angularvelocitysensors();

  // repeated double torqueSensors = 3;
  int torquesensors_size() const;
  private:
  int _internal_torquesensors_size() const;
  public:
  void clear_torquesensors();
  private:
  double _internal_torquesensors(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
      _internal_torquesensors() const;
  void _internal_add_torquesensors(double value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
      _internal_mutable_torquesensors();
  public:
  double torquesensors(int index) const;
  void set_torquesensors(int index, double value);
  void add_torquesensors(double value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
      torquesensors() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
      mutable_torquesensors();

  // repeated .click.protobuf.SensorMessage.Sensor objectSensors = 4;
  int objectsensors_size() const;
  private:
  int _internal_objectsensors_size() const;
  public:
  void clear_objectsensors();
  ::click::protobuf::SensorMessage_Sensor* mutable_objectsensors(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::click::protobuf::SensorMessage_Sensor >*
      mutable_objectsensors();
  private:
  const ::click::protobuf::SensorMessage_Sensor& _internal_objectsensors(int index) const;
  ::click::protobuf::SensorMessage_Sensor* _internal_add_objectsensors();
  public:
  const ::click::protobuf::SensorMessage_Sensor& objectsensors(int index) const;
  ::click::protobuf::SensorMessage_Sensor* add_objectsensors();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::click::protobuf::SensorMessage_Sensor >&
      objectsensors() const;

  // repeated .click.protobuf.SensorMessage.Vec3 forceSensors = 5;
  int forcesensors_size() const;
  private:
  int _internal_forcesensors_size() const;
  public:
  void clear_forcesensors();
  ::click::protobuf::SensorMessage_Vec3* mutable_forcesensors(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::click::protobuf::SensorMessage_Vec3 >*
      mutable_forcesensors();
  private:
  const ::click::protobuf::SensorMessage_Vec3& _internal_forcesensors(int index) const;
  ::click::protobuf::SensorMessage_Vec3* _internal_add_forcesensors();
  public:
  const ::click::protobuf::SensorMessage_Vec3& forcesensors(int index) const;
  ::click::protobuf::SensorMessage_Vec3* add_forcesensors();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::click::protobuf::SensorMessage_Vec3 >&
      forcesensors() const;

  // map<string, .click.protobuf.SensorMessage.Sensors> sensors = 6;
  int sensors_size() const;
  private:
  int _internal_sensors_size() const;
  public:
  void clear_sensors();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::click::protobuf::SensorMessage_Sensors >&
      _internal_sensors() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::click::protobuf::SensorMessage_Sensors >*
      _internal_mutable_sensors();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::click::protobuf::SensorMessage_Sensors >&
      sensors() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::click::protobuf::SensorMessage_Sensors >*
      mutable_sensors();

  // @@protoc_insertion_point(class_scope:click.protobuf.SensorMessage.Object)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< double > anglesensors_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< double > angularvelocitysensors_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< double > torquesensors_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::click::protobuf::SensorMessage_Sensor > objectsensors_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::click::protobuf::SensorMessage_Vec3 > forcesensors_;
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        SensorMessage_Object_SensorsEntry_DoNotUse,
        std::string, ::click::protobuf::SensorMessage_Sensors,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> sensors_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Messaging_2eproto;
};
// -------------------------------------------------------------------

class SensorMessage_SimulationVariables final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:click.protobuf.SensorMessage.SimulationVariables) */ {
 public:
  inline SensorMessage_SimulationVariables() : SensorMessage_SimulationVariables(nullptr) {}
  ~SensorMessage_SimulationVariables() override;
  explicit PROTOBUF_CONSTEXPR SensorMessage_SimulationVariables(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SensorMessage_SimulationVariables(const SensorMessage_SimulationVariables& from);
  SensorMessage_SimulationVariables(SensorMessage_SimulationVariables&& from) noexcept
    : SensorMessage_SimulationVariables() {
    *this = ::std::move(from);
  }

  inline SensorMessage_SimulationVariables& operator=(const SensorMessage_SimulationVariables& from) {
    CopyFrom(from);
    return *this;
  }
  inline SensorMessage_SimulationVariables& operator=(SensorMessage_SimulationVariables&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SensorMessage_SimulationVariables& default_instance() {
    return *internal_default_instance();
  }
  static inline const SensorMessage_SimulationVariables* internal_default_instance() {
    return reinterpret_cast<const SensorMessage_SimulationVariables*>(
               &_SensorMessage_SimulationVariables_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(SensorMessage_SimulationVariables& a, SensorMessage_SimulationVariables& b) {
    a.Swap(&b);
  }
  inline void Swap(SensorMessage_SimulationVariables* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SensorMessage_SimulationVariables* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SensorMessage_SimulationVariables* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SensorMessage_SimulationVariables>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SensorMessage_SimulationVariables& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SensorMessage_SimulationVariables& from) {
    SensorMessage_SimulationVariables::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SensorMessage_SimulationVariables* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "click.protobuf.SensorMessage.SimulationVariables";
  }
  protected:
  explicit SensorMessage_SimulationVariables(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSimulatedTimeFieldNumber = 1,
  };
  // double simulatedTime = 1;
  void clear_simulatedtime();
  double simulatedtime() const;
  void set_simulatedtime(double value);
  private:
  double _internal_simulatedtime() const;
  void _internal_set_simulatedtime(double value);
  public:

  // @@protoc_insertion_point(class_scope:click.protobuf.SensorMessage.SimulationVariables)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    double simulatedtime_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Messaging_2eproto;
};
// -------------------------------------------------------------------

class SensorMessage_ObjectsEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<SensorMessage_ObjectsEntry_DoNotUse, 
    std::string, ::click::protobuf::SensorMessage_Object,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<SensorMessage_ObjectsEntry_DoNotUse, 
    std::string, ::click::protobuf::SensorMessage_Object,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> SuperType;
  SensorMessage_ObjectsEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR SensorMessage_ObjectsEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit SensorMessage_ObjectsEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const SensorMessage_ObjectsEntry_DoNotUse& other);
  static const SensorMessage_ObjectsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const SensorMessage_ObjectsEntry_DoNotUse*>(&_SensorMessage_ObjectsEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "click.protobuf.SensorMessage.ObjectsEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_Messaging_2eproto;
};

// -------------------------------------------------------------------

class SensorMessage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:click.protobuf.SensorMessage) */ {
 public:
  inline SensorMessage() : SensorMessage(nullptr) {}
  ~SensorMessage() override;
  explicit PROTOBUF_CONSTEXPR SensorMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SensorMessage(const SensorMessage& from);
  SensorMessage(SensorMessage&& from) noexcept
    : SensorMessage() {
    *this = ::std::move(from);
  }

  inline SensorMessage& operator=(const SensorMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline SensorMessage& operator=(SensorMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SensorMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const SensorMessage* internal_default_instance() {
    return reinterpret_cast<const SensorMessage*>(
               &_SensorMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(SensorMessage& a, SensorMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(SensorMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SensorMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SensorMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SensorMessage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SensorMessage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SensorMessage& from) {
    SensorMessage::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SensorMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "click.protobuf.SensorMessage";
  }
  protected:
  explicit SensorMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef SensorMessage_Vec3 Vec3;
  typedef SensorMessage_Sensor Sensor;
  typedef SensorMessage_Sensors Sensors;
  typedef SensorMessage_Object Object;
  typedef SensorMessage_SimulationVariables SimulationVariables;

  // accessors -------------------------------------------------------

  enum : int {
    kObjectsFieldNumber = 3,
    kSimVarsFieldNumber = 4,
    kMessageTypeFieldNumber = 1,
  };
  // map<string, .click.protobuf.SensorMessage.Object> objects = 3;
  int objects_size() const;
  private:
  int _internal_objects_size() const;
  public:
  void clear_objects();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::click::protobuf::SensorMessage_Object >&
      _internal_objects() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::click::protobuf::SensorMessage_Object >*
      _internal_mutable_objects();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::click::protobuf::SensorMessage_Object >&
      objects() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::click::protobuf::SensorMessage_Object >*
      mutable_objects();

  // .click.protobuf.SensorMessage.SimulationVariables simVars = 4;
  bool has_simvars() const;
  private:
  bool _internal_has_simvars() const;
  public:
  void clear_simvars();
  const ::click::protobuf::SensorMessage_SimulationVariables& simvars() const;
  PROTOBUF_NODISCARD ::click::protobuf::SensorMessage_SimulationVariables* release_simvars();
  ::click::protobuf::SensorMessage_SimulationVariables* mutable_simvars();
  void set_allocated_simvars(::click::protobuf::SensorMessage_SimulationVariables* simvars);
  private:
  const ::click::protobuf::SensorMessage_SimulationVariables& _internal_simvars() const;
  ::click::protobuf::SensorMessage_SimulationVariables* _internal_mutable_simvars();
  public:
  void unsafe_arena_set_allocated_simvars(
      ::click::protobuf::SensorMessage_SimulationVariables* simvars);
  ::click::protobuf::SensorMessage_SimulationVariables* unsafe_arena_release_simvars();

  // .click.protobuf.MessageType messageType = 1;
  void clear_messagetype();
  ::click::protobuf::MessageType messagetype() const;
  void set_messagetype(::click::protobuf::MessageType value);
  private:
  ::click::protobuf::MessageType _internal_messagetype() const;
  void _internal_set_messagetype(::click::protobuf::MessageType value);
  public:

  // @@protoc_insertion_point(class_scope:click.protobuf.SensorMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        SensorMessage_ObjectsEntry_DoNotUse,
        std::string, ::click::protobuf::SensorMessage_Object,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> objects_;
    ::click::protobuf::SensorMessage_SimulationVariables* simvars_;
    int messagetype_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Messaging_2eproto;
};
// -------------------------------------------------------------------

class ResetMessage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:click.protobuf.ResetMessage) */ {
 public:
  inline ResetMessage() : ResetMessage(nullptr) {}
  ~ResetMessage() override;
  explicit PROTOBUF_CONSTEXPR ResetMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ResetMessage(const ResetMessage& from);
  ResetMessage(ResetMessage&& from) noexcept
    : ResetMessage() {
    *this = ::std::move(from);
  }

  inline ResetMessage& operator=(const ResetMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline ResetMessage& operator=(ResetMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ResetMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const ResetMessage* internal_default_instance() {
    return reinterpret_cast<const ResetMessage*>(
               &_ResetMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(ResetMessage& a, ResetMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(ResetMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ResetMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ResetMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ResetMessage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ResetMessage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ResetMessage& from) {
    ResetMessage::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ResetMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "click.protobuf.ResetMessage";
  }
  protected:
  explicit ResetMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMessageTypeFieldNumber = 1,
  };
  // .click.protobuf.MessageType messageType = 1;
  void clear_messagetype();
  ::click::protobuf::MessageType messagetype() const;
  void set_messagetype(::click::protobuf::MessageType value);
  private:
  ::click::protobuf::MessageType _internal_messagetype() const;
  void _internal_set_messagetype(::click::protobuf::MessageType value);
  public:

  // @@protoc_insertion_point(class_scope:click.protobuf.ResetMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int messagetype_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Messaging_2eproto;
};
// -------------------------------------------------------------------

class ErrorMessage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:click.protobuf.ErrorMessage) */ {
 public:
  inline ErrorMessage() : ErrorMessage(nullptr) {}
  ~ErrorMessage() override;
  explicit PROTOBUF_CONSTEXPR ErrorMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ErrorMessage(const ErrorMessage& from);
  ErrorMessage(ErrorMessage&& from) noexcept
    : ErrorMessage() {
    *this = ::std::move(from);
  }

  inline ErrorMessage& operator=(const ErrorMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline ErrorMessage& operator=(ErrorMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ErrorMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const ErrorMessage* internal_default_instance() {
    return reinterpret_cast<const ErrorMessage*>(
               &_ErrorMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(ErrorMessage& a, ErrorMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(ErrorMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ErrorMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ErrorMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ErrorMessage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ErrorMessage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ErrorMessage& from) {
    ErrorMessage::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ErrorMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "click.protobuf.ErrorMessage";
  }
  protected:
  explicit ErrorMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kErrormessageFieldNumber = 3,
    kMessageTypeFieldNumber = 1,
    kErrorFieldNumber = 2,
  };
  // string errormessage = 3;
  void clear_errormessage();
  const std::string& errormessage() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_errormessage(ArgT0&& arg0, ArgT... args);
  std::string* mutable_errormessage();
  PROTOBUF_NODISCARD std::string* release_errormessage();
  void set_allocated_errormessage(std::string* errormessage);
  private:
  const std::string& _internal_errormessage() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_errormessage(const std::string& value);
  std::string* _internal_mutable_errormessage();
  public:

  // .click.protobuf.MessageType messageType = 1;
  void clear_messagetype();
  ::click::protobuf::MessageType messagetype() const;
  void set_messagetype(::click::protobuf::MessageType value);
  private:
  ::click::protobuf::MessageType _internal_messagetype() const;
  void _internal_set_messagetype(::click::protobuf::MessageType value);
  public:

  // .click.protobuf.ErrorType error = 2;
  void clear_error();
  ::click::protobuf::ErrorType error() const;
  void set_error(::click::protobuf::ErrorType value);
  private:
  ::click::protobuf::ErrorType _internal_error() const;
  void _internal_set_error(::click::protobuf::ErrorType value);
  public:

  // @@protoc_insertion_point(class_scope:click.protobuf.ErrorMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr errormessage_;
    int messagetype_;
    int error_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Messaging_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Message

// .click.protobuf.MessageType messageType = 1;
inline void Message::clear_messagetype() {
  _impl_.messagetype_ = 0;
}
inline ::click::protobuf::MessageType Message::_internal_messagetype() const {
  return static_cast< ::click::protobuf::MessageType >(_impl_.messagetype_);
}
inline ::click::protobuf::MessageType Message::messagetype() const {
  // @@protoc_insertion_point(field_get:click.protobuf.Message.messageType)
  return _internal_messagetype();
}
inline void Message::_internal_set_messagetype(::click::protobuf::MessageType value) {
  
  _impl_.messagetype_ = value;
}
inline void Message::set_messagetype(::click::protobuf::MessageType value) {
  _internal_set_messagetype(value);
  // @@protoc_insertion_point(field_set:click.protobuf.Message.messageType)
}

// int32 id = 2;
inline void Message::clear_id() {
  _impl_.id_ = 0;
}
inline int32_t Message::_internal_id() const {
  return _impl_.id_;
}
inline int32_t Message::id() const {
  // @@protoc_insertion_point(field_get:click.protobuf.Message.id)
  return _internal_id();
}
inline void Message::_internal_set_id(int32_t value) {
  
  _impl_.id_ = value;
}
inline void Message::set_id(int32_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:click.protobuf.Message.id)
}

// -------------------------------------------------------------------

// HandshakeInitMessage

// .click.protobuf.MessageType messageType = 1;
inline void HandshakeInitMessage::clear_messagetype() {
  _impl_.messagetype_ = 0;
}
inline ::click::protobuf::MessageType HandshakeInitMessage::_internal_messagetype() const {
  return static_cast< ::click::protobuf::MessageType >(_impl_.messagetype_);
}
inline ::click::protobuf::MessageType HandshakeInitMessage::messagetype() const {
  // @@protoc_insertion_point(field_get:click.protobuf.HandshakeInitMessage.messageType)
  return _internal_messagetype();
}
inline void HandshakeInitMessage::_internal_set_messagetype(::click::protobuf::MessageType value) {
  
  _impl_.messagetype_ = value;
}
inline void HandshakeInitMessage::set_messagetype(::click::protobuf::MessageType value) {
  _internal_set_messagetype(value);
  // @@protoc_insertion_point(field_set:click.protobuf.HandshakeInitMessage.messageType)
}

// .click.protobuf.Version version = 2;
inline void HandshakeInitMessage::clear_version() {
  _impl_.version_ = 0;
}
inline ::click::protobuf::Version HandshakeInitMessage::_internal_version() const {
  return static_cast< ::click::protobuf::Version >(_impl_.version_);
}
inline ::click::protobuf::Version HandshakeInitMessage::version() const {
  // @@protoc_insertion_point(field_get:click.protobuf.HandshakeInitMessage.version)
  return _internal_version();
}
inline void HandshakeInitMessage::_internal_set_version(::click::protobuf::Version value) {
  
  _impl_.version_ = value;
}
inline void HandshakeInitMessage::set_version(::click::protobuf::Version value) {
  _internal_set_version(value);
  // @@protoc_insertion_point(field_set:click.protobuf.HandshakeInitMessage.version)
}

// -------------------------------------------------------------------

// SensorRequestMessage

// .click.protobuf.MessageType messageType = 1;
inline void SensorRequestMessage::clear_messagetype() {
  _impl_.messagetype_ = 0;
}
inline ::click::protobuf::MessageType SensorRequestMessage::_internal_messagetype() const {
  return static_cast< ::click::protobuf::MessageType >(_impl_.messagetype_);
}
inline ::click::protobuf::MessageType SensorRequestMessage::messagetype() const {
  // @@protoc_insertion_point(field_get:click.protobuf.SensorRequestMessage.messageType)
  return _internal_messagetype();
}
inline void SensorRequestMessage::_internal_set_messagetype(::click::protobuf::MessageType value) {
  
  _impl_.messagetype_ = value;
}
inline void SensorRequestMessage::set_messagetype(::click::protobuf::MessageType value) {
  _internal_set_messagetype(value);
  // @@protoc_insertion_point(field_set:click.protobuf.SensorRequestMessage.messageType)
}

// -------------------------------------------------------------------

// HandshakeMessage_Sensors

// repeated .click.protobuf.ValueType types = 1;
inline int HandshakeMessage_Sensors::_internal_types_size() const {
  return _impl_.types_.size();
}
inline int HandshakeMessage_Sensors::types_size() const {
  return _internal_types_size();
}
inline void HandshakeMessage_Sensors::clear_types() {
  _impl_.types_.Clear();
}
inline ::click::protobuf::ValueType HandshakeMessage_Sensors::_internal_types(int index) const {
  return static_cast< ::click::protobuf::ValueType >(_impl_.types_.Get(index));
}
inline ::click::protobuf::ValueType HandshakeMessage_Sensors::types(int index) const {
  // @@protoc_insertion_point(field_get:click.protobuf.HandshakeMessage.Sensors.types)
  return _internal_types(index);
}
inline void HandshakeMessage_Sensors::set_types(int index, ::click::protobuf::ValueType value) {
  _impl_.types_.Set(index, value);
  // @@protoc_insertion_point(field_set:click.protobuf.HandshakeMessage.Sensors.types)
}
inline void HandshakeMessage_Sensors::_internal_add_types(::click::protobuf::ValueType value) {
  _impl_.types_.Add(value);
}
inline void HandshakeMessage_Sensors::add_types(::click::protobuf::ValueType value) {
  _internal_add_types(value);
  // @@protoc_insertion_point(field_add:click.protobuf.HandshakeMessage.Sensors.types)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>&
HandshakeMessage_Sensors::types() const {
  // @@protoc_insertion_point(field_list:click.protobuf.HandshakeMessage.Sensors.types)
  return _impl_.types_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>*
HandshakeMessage_Sensors::_internal_mutable_types() {
  return &_impl_.types_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>*
HandshakeMessage_Sensors::mutable_types() {
  // @@protoc_insertion_point(field_mutable_list:click.protobuf.HandshakeMessage.Sensors.types)
  return _internal_mutable_types();
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// HandshakeMessage_Object

// repeated string controlsInOrder = 1;
inline int HandshakeMessage_Object::_internal_controlsinorder_size() const {
  return _impl_.controlsinorder_.size();
}
inline int HandshakeMessage_Object::controlsinorder_size() const {
  return _internal_controlsinorder_size();
}
inline void HandshakeMessage_Object::clear_controlsinorder() {
  _impl_.controlsinorder_.Clear();
}
inline std::string* HandshakeMessage_Object::add_controlsinorder() {
  std::string* _s = _internal_add_controlsinorder();
  // @@protoc_insertion_point(field_add_mutable:click.protobuf.HandshakeMessage.Object.controlsInOrder)
  return _s;
}
inline const std::string& HandshakeMessage_Object::_internal_controlsinorder(int index) const {
  return _impl_.controlsinorder_.Get(index);
}
inline const std::string& HandshakeMessage_Object::controlsinorder(int index) const {
  // @@protoc_insertion_point(field_get:click.protobuf.HandshakeMessage.Object.controlsInOrder)
  return _internal_controlsinorder(index);
}
inline std::string* HandshakeMessage_Object::mutable_controlsinorder(int index) {
  // @@protoc_insertion_point(field_mutable:click.protobuf.HandshakeMessage.Object.controlsInOrder)
  return _impl_.controlsinorder_.Mutable(index);
}
inline void HandshakeMessage_Object::set_controlsinorder(int index, const std::string& value) {
  _impl_.controlsinorder_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:click.protobuf.HandshakeMessage.Object.controlsInOrder)
}
inline void HandshakeMessage_Object::set_controlsinorder(int index, std::string&& value) {
  _impl_.controlsinorder_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:click.protobuf.HandshakeMessage.Object.controlsInOrder)
}
inline void HandshakeMessage_Object::set_controlsinorder(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.controlsinorder_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:click.protobuf.HandshakeMessage.Object.controlsInOrder)
}
inline void HandshakeMessage_Object::set_controlsinorder(int index, const char* value, size_t size) {
  _impl_.controlsinorder_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:click.protobuf.HandshakeMessage.Object.controlsInOrder)
}
inline std::string* HandshakeMessage_Object::_internal_add_controlsinorder() {
  return _impl_.controlsinorder_.Add();
}
inline void HandshakeMessage_Object::add_controlsinorder(const std::string& value) {
  _impl_.controlsinorder_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:click.protobuf.HandshakeMessage.Object.controlsInOrder)
}
inline void HandshakeMessage_Object::add_controlsinorder(std::string&& value) {
  _impl_.controlsinorder_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:click.protobuf.HandshakeMessage.Object.controlsInOrder)
}
inline void HandshakeMessage_Object::add_controlsinorder(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.controlsinorder_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:click.protobuf.HandshakeMessage.Object.controlsInOrder)
}
inline void HandshakeMessage_Object::add_controlsinorder(const char* value, size_t size) {
  _impl_.controlsinorder_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:click.protobuf.HandshakeMessage.Object.controlsInOrder)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
HandshakeMessage_Object::controlsinorder() const {
  // @@protoc_insertion_point(field_list:click.protobuf.HandshakeMessage.Object.controlsInOrder)
  return _impl_.controlsinorder_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
HandshakeMessage_Object::mutable_controlsinorder() {
  // @@protoc_insertion_point(field_mutable_list:click.protobuf.HandshakeMessage.Object.controlsInOrder)
  return &_impl_.controlsinorder_;
}

// repeated .click.protobuf.ValueType controlTypesInOrder = 8;
inline int HandshakeMessage_Object::_internal_controltypesinorder_size() const {
  return _impl_.controltypesinorder_.size();
}
inline int HandshakeMessage_Object::controltypesinorder_size() const {
  return _internal_controltypesinorder_size();
}
inline void HandshakeMessage_Object::clear_controltypesinorder() {
  _impl_.controltypesinorder_.Clear();
}
inline ::click::protobuf::ValueType HandshakeMessage_Object::_internal_controltypesinorder(int index) const {
  return static_cast< ::click::protobuf::ValueType >(_impl_.controltypesinorder_.Get(index));
}
inline ::click::protobuf::ValueType HandshakeMessage_Object::controltypesinorder(int index) const {
  // @@protoc_insertion_point(field_get:click.protobuf.HandshakeMessage.Object.controlTypesInOrder)
  return _internal_controltypesinorder(index);
}
inline void HandshakeMessage_Object::set_controltypesinorder(int index, ::click::protobuf::ValueType value) {
  _impl_.controltypesinorder_.Set(index, value);
  // @@protoc_insertion_point(field_set:click.protobuf.HandshakeMessage.Object.controlTypesInOrder)
}
inline void HandshakeMessage_Object::_internal_add_controltypesinorder(::click::protobuf::ValueType value) {
  _impl_.controltypesinorder_.Add(value);
}
inline void HandshakeMessage_Object::add_controltypesinorder(::click::protobuf::ValueType value) {
  _internal_add_controltypesinorder(value);
  // @@protoc_insertion_point(field_add:click.protobuf.HandshakeMessage.Object.controlTypesInOrder)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>&
HandshakeMessage_Object::controltypesinorder() const {
  // @@protoc_insertion_point(field_list:click.protobuf.HandshakeMessage.Object.controlTypesInOrder)
  return _impl_.controltypesinorder_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>*
HandshakeMessage_Object::_internal_mutable_controltypesinorder() {
  return &_impl_.controltypesinorder_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>*
HandshakeMessage_Object::mutable_controltypesinorder() {
  // @@protoc_insertion_point(field_mutable_list:click.protobuf.HandshakeMessage.Object.controlTypesInOrder)
  return _internal_mutable_controltypesinorder();
}

// repeated string jointSensorsInOrder = 7;
inline int HandshakeMessage_Object::_internal_jointsensorsinorder_size() const {
  return _impl_.jointsensorsinorder_.size();
}
inline int HandshakeMessage_Object::jointsensorsinorder_size() const {
  return _internal_jointsensorsinorder_size();
}
inline void HandshakeMessage_Object::clear_jointsensorsinorder() {
  _impl_.jointsensorsinorder_.Clear();
}
inline std::string* HandshakeMessage_Object::add_jointsensorsinorder() {
  std::string* _s = _internal_add_jointsensorsinorder();
  // @@protoc_insertion_point(field_add_mutable:click.protobuf.HandshakeMessage.Object.jointSensorsInOrder)
  return _s;
}
inline const std::string& HandshakeMessage_Object::_internal_jointsensorsinorder(int index) const {
  return _impl_.jointsensorsinorder_.Get(index);
}
inline const std::string& HandshakeMessage_Object::jointsensorsinorder(int index) const {
  // @@protoc_insertion_point(field_get:click.protobuf.HandshakeMessage.Object.jointSensorsInOrder)
  return _internal_jointsensorsinorder(index);
}
inline std::string* HandshakeMessage_Object::mutable_jointsensorsinorder(int index) {
  // @@protoc_insertion_point(field_mutable:click.protobuf.HandshakeMessage.Object.jointSensorsInOrder)
  return _impl_.jointsensorsinorder_.Mutable(index);
}
inline void HandshakeMessage_Object::set_jointsensorsinorder(int index, const std::string& value) {
  _impl_.jointsensorsinorder_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:click.protobuf.HandshakeMessage.Object.jointSensorsInOrder)
}
inline void HandshakeMessage_Object::set_jointsensorsinorder(int index, std::string&& value) {
  _impl_.jointsensorsinorder_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:click.protobuf.HandshakeMessage.Object.jointSensorsInOrder)
}
inline void HandshakeMessage_Object::set_jointsensorsinorder(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.jointsensorsinorder_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:click.protobuf.HandshakeMessage.Object.jointSensorsInOrder)
}
inline void HandshakeMessage_Object::set_jointsensorsinorder(int index, const char* value, size_t size) {
  _impl_.jointsensorsinorder_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:click.protobuf.HandshakeMessage.Object.jointSensorsInOrder)
}
inline std::string* HandshakeMessage_Object::_internal_add_jointsensorsinorder() {
  return _impl_.jointsensorsinorder_.Add();
}
inline void HandshakeMessage_Object::add_jointsensorsinorder(const std::string& value) {
  _impl_.jointsensorsinorder_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:click.protobuf.HandshakeMessage.Object.jointSensorsInOrder)
}
inline void HandshakeMessage_Object::add_jointsensorsinorder(std::string&& value) {
  _impl_.jointsensorsinorder_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:click.protobuf.HandshakeMessage.Object.jointSensorsInOrder)
}
inline void HandshakeMessage_Object::add_jointsensorsinorder(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.jointsensorsinorder_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:click.protobuf.HandshakeMessage.Object.jointSensorsInOrder)
}
inline void HandshakeMessage_Object::add_jointsensorsinorder(const char* value, size_t size) {
  _impl_.jointsensorsinorder_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:click.protobuf.HandshakeMessage.Object.jointSensorsInOrder)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
HandshakeMessage_Object::jointsensorsinorder() const {
  // @@protoc_insertion_point(field_list:click.protobuf.HandshakeMessage.Object.jointSensorsInOrder)
  return _impl_.jointsensorsinorder_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
HandshakeMessage_Object::mutable_jointsensorsinorder() {
  // @@protoc_insertion_point(field_mutable_list:click.protobuf.HandshakeMessage.Object.jointSensorsInOrder)
  return &_impl_.jointsensorsinorder_;
}

// repeated .click.protobuf.ValueType jointSensors = 2;
inline int HandshakeMessage_Object::_internal_jointsensors_size() const {
  return _impl_.jointsensors_.size();
}
inline int HandshakeMessage_Object::jointsensors_size() const {
  return _internal_jointsensors_size();
}
inline void HandshakeMessage_Object::clear_jointsensors() {
  _impl_.jointsensors_.Clear();
}
inline ::click::protobuf::ValueType HandshakeMessage_Object::_internal_jointsensors(int index) const {
  return static_cast< ::click::protobuf::ValueType >(_impl_.jointsensors_.Get(index));
}
inline ::click::protobuf::ValueType HandshakeMessage_Object::jointsensors(int index) const {
  // @@protoc_insertion_point(field_get:click.protobuf.HandshakeMessage.Object.jointSensors)
  return _internal_jointsensors(index);
}
inline void HandshakeMessage_Object::set_jointsensors(int index, ::click::protobuf::ValueType value) {
  _impl_.jointsensors_.Set(index, value);
  // @@protoc_insertion_point(field_set:click.protobuf.HandshakeMessage.Object.jointSensors)
}
inline void HandshakeMessage_Object::_internal_add_jointsensors(::click::protobuf::ValueType value) {
  _impl_.jointsensors_.Add(value);
}
inline void HandshakeMessage_Object::add_jointsensors(::click::protobuf::ValueType value) {
  _internal_add_jointsensors(value);
  // @@protoc_insertion_point(field_add:click.protobuf.HandshakeMessage.Object.jointSensors)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>&
HandshakeMessage_Object::jointsensors() const {
  // @@protoc_insertion_point(field_list:click.protobuf.HandshakeMessage.Object.jointSensors)
  return _impl_.jointsensors_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>*
HandshakeMessage_Object::_internal_mutable_jointsensors() {
  return &_impl_.jointsensors_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>*
HandshakeMessage_Object::mutable_jointsensors() {
  // @@protoc_insertion_point(field_mutable_list:click.protobuf.HandshakeMessage.Object.jointSensors)
  return _internal_mutable_jointsensors();
}

// map<string, .click.protobuf.ValueType> controlEvents = 3;
inline int HandshakeMessage_Object::_internal_controlevents_size() const {
  return _impl_.controlevents_.size();
}
inline int HandshakeMessage_Object::controlevents_size() const {
  return _internal_controlevents_size();
}
inline void HandshakeMessage_Object::clear_controlevents() {
  _impl_.controlevents_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::click::protobuf::ValueType >&
HandshakeMessage_Object::_internal_controlevents() const {
  return _impl_.controlevents_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::click::protobuf::ValueType >&
HandshakeMessage_Object::controlevents() const {
  // @@protoc_insertion_point(field_map:click.protobuf.HandshakeMessage.Object.controlEvents)
  return _internal_controlevents();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::click::protobuf::ValueType >*
HandshakeMessage_Object::_internal_mutable_controlevents() {
  return _impl_.controlevents_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::click::protobuf::ValueType >*
HandshakeMessage_Object::mutable_controlevents() {
  // @@protoc_insertion_point(field_mutable_map:click.protobuf.HandshakeMessage.Object.controlEvents)
  return _internal_mutable_controlevents();
}

// map<string, .click.protobuf.HandshakeMessage.Sensors> sensors = 4;
inline int HandshakeMessage_Object::_internal_sensors_size() const {
  return _impl_.sensors_.size();
}
inline int HandshakeMessage_Object::sensors_size() const {
  return _internal_sensors_size();
}
inline void HandshakeMessage_Object::clear_sensors() {
  _impl_.sensors_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::click::protobuf::HandshakeMessage_Sensors >&
HandshakeMessage_Object::_internal_sensors() const {
  return _impl_.sensors_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::click::protobuf::HandshakeMessage_Sensors >&
HandshakeMessage_Object::sensors() const {
  // @@protoc_insertion_point(field_map:click.protobuf.HandshakeMessage.Object.sensors)
  return _internal_sensors();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::click::protobuf::HandshakeMessage_Sensors >*
HandshakeMessage_Object::_internal_mutable_sensors() {
  return _impl_.sensors_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::click::protobuf::HandshakeMessage_Sensors >*
HandshakeMessage_Object::mutable_sensors() {
  // @@protoc_insertion_point(field_mutable_map:click.protobuf.HandshakeMessage.Object.sensors)
  return _internal_mutable_sensors();
}

// repeated .click.protobuf.ValueType objectSensors = 6;
inline int HandshakeMessage_Object::_internal_objectsensors_size() const {
  return _impl_.objectsensors_.size();
}
inline int HandshakeMessage_Object::objectsensors_size() const {
  return _internal_objectsensors_size();
}
inline void HandshakeMessage_Object::clear_objectsensors() {
  _impl_.objectsensors_.Clear();
}
inline ::click::protobuf::ValueType HandshakeMessage_Object::_internal_objectsensors(int index) const {
  return static_cast< ::click::protobuf::ValueType >(_impl_.objectsensors_.Get(index));
}
inline ::click::protobuf::ValueType HandshakeMessage_Object::objectsensors(int index) const {
  // @@protoc_insertion_point(field_get:click.protobuf.HandshakeMessage.Object.objectSensors)
  return _internal_objectsensors(index);
}
inline void HandshakeMessage_Object::set_objectsensors(int index, ::click::protobuf::ValueType value) {
  _impl_.objectsensors_.Set(index, value);
  // @@protoc_insertion_point(field_set:click.protobuf.HandshakeMessage.Object.objectSensors)
}
inline void HandshakeMessage_Object::_internal_add_objectsensors(::click::protobuf::ValueType value) {
  _impl_.objectsensors_.Add(value);
}
inline void HandshakeMessage_Object::add_objectsensors(::click::protobuf::ValueType value) {
  _internal_add_objectsensors(value);
  // @@protoc_insertion_point(field_add:click.protobuf.HandshakeMessage.Object.objectSensors)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>&
HandshakeMessage_Object::objectsensors() const {
  // @@protoc_insertion_point(field_list:click.protobuf.HandshakeMessage.Object.objectSensors)
  return _impl_.objectsensors_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>*
HandshakeMessage_Object::_internal_mutable_objectsensors() {
  return &_impl_.objectsensors_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>*
HandshakeMessage_Object::mutable_objectsensors() {
  // @@protoc_insertion_point(field_mutable_list:click.protobuf.HandshakeMessage.Object.objectSensors)
  return _internal_mutable_objectsensors();
}

// -------------------------------------------------------------------

// HandshakeMessage_SimulationSettings

// double timeStep = 1;
inline void HandshakeMessage_SimulationSettings::clear_timestep() {
  _impl_.timestep_ = 0;
}
inline double HandshakeMessage_SimulationSettings::_internal_timestep() const {
  return _impl_.timestep_;
}
inline double HandshakeMessage_SimulationSettings::timestep() const {
  // @@protoc_insertion_point(field_get:click.protobuf.HandshakeMessage.SimulationSettings.timeStep)
  return _internal_timestep();
}
inline void HandshakeMessage_SimulationSettings::_internal_set_timestep(double value) {
  
  _impl_.timestep_ = value;
}
inline void HandshakeMessage_SimulationSettings::set_timestep(double value) {
  _internal_set_timestep(value);
  // @@protoc_insertion_point(field_set:click.protobuf.HandshakeMessage.SimulationSettings.timeStep)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// HandshakeMessage

// .click.protobuf.MessageType messageType = 1;
inline void HandshakeMessage::clear_messagetype() {
  _impl_.messagetype_ = 0;
}
inline ::click::protobuf::MessageType HandshakeMessage::_internal_messagetype() const {
  return static_cast< ::click::protobuf::MessageType >(_impl_.messagetype_);
}
inline ::click::protobuf::MessageType HandshakeMessage::messagetype() const {
  // @@protoc_insertion_point(field_get:click.protobuf.HandshakeMessage.messageType)
  return _internal_messagetype();
}
inline void HandshakeMessage::_internal_set_messagetype(::click::protobuf::MessageType value) {
  
  _impl_.messagetype_ = value;
}
inline void HandshakeMessage::set_messagetype(::click::protobuf::MessageType value) {
  _internal_set_messagetype(value);
  // @@protoc_insertion_point(field_set:click.protobuf.HandshakeMessage.messageType)
}

// .click.protobuf.Version version = 2;
inline void HandshakeMessage::clear_version() {
  _impl_.version_ = 0;
}
inline ::click::protobuf::Version HandshakeMessage::_internal_version() const {
  return static_cast< ::click::protobuf::Version >(_impl_.version_);
}
inline ::click::protobuf::Version HandshakeMessage::version() const {
  // @@protoc_insertion_point(field_get:click.protobuf.HandshakeMessage.version)
  return _internal_version();
}
inline void HandshakeMessage::_internal_set_version(::click::protobuf::Version value) {
  
  _impl_.version_ = value;
}
inline void HandshakeMessage::set_version(::click::protobuf::Version value) {
  _internal_set_version(value);
  // @@protoc_insertion_point(field_set:click.protobuf.HandshakeMessage.version)
}

// .click.protobuf.ValueType controlType = 3;
inline void HandshakeMessage::clear_controltype() {
  _impl_.controltype_ = 0;
}
inline ::click::protobuf::ValueType HandshakeMessage::_internal_controltype() const {
  return static_cast< ::click::protobuf::ValueType >(_impl_.controltype_);
}
inline ::click::protobuf::ValueType HandshakeMessage::controltype() const {
  // @@protoc_insertion_point(field_get:click.protobuf.HandshakeMessage.controlType)
  return _internal_controltype();
}
inline void HandshakeMessage::_internal_set_controltype(::click::protobuf::ValueType value) {
  
  _impl_.controltype_ = value;
}
inline void HandshakeMessage::set_controltype(::click::protobuf::ValueType value) {
  _internal_set_controltype(value);
  // @@protoc_insertion_point(field_set:click.protobuf.HandshakeMessage.controlType)
}

// map<string, .click.protobuf.HandshakeMessage.Object> objects = 4;
inline int HandshakeMessage::_internal_objects_size() const {
  return _impl_.objects_.size();
}
inline int HandshakeMessage::objects_size() const {
  return _internal_objects_size();
}
inline void HandshakeMessage::clear_objects() {
  _impl_.objects_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::click::protobuf::HandshakeMessage_Object >&
HandshakeMessage::_internal_objects() const {
  return _impl_.objects_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::click::protobuf::HandshakeMessage_Object >&
HandshakeMessage::objects() const {
  // @@protoc_insertion_point(field_map:click.protobuf.HandshakeMessage.objects)
  return _internal_objects();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::click::protobuf::HandshakeMessage_Object >*
HandshakeMessage::_internal_mutable_objects() {
  return _impl_.objects_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::click::protobuf::HandshakeMessage_Object >*
HandshakeMessage::mutable_objects() {
  // @@protoc_insertion_point(field_mutable_map:click.protobuf.HandshakeMessage.objects)
  return _internal_mutable_objects();
}

// .click.protobuf.HandshakeMessage.SimulationSettings simSettings = 5;
inline bool HandshakeMessage::_internal_has_simsettings() const {
  return this != internal_default_instance() && _impl_.simsettings_ != nullptr;
}
inline bool HandshakeMessage::has_simsettings() const {
  return _internal_has_simsettings();
}
inline void HandshakeMessage::clear_simsettings() {
  if (GetArenaForAllocation() == nullptr && _impl_.simsettings_ != nullptr) {
    delete _impl_.simsettings_;
  }
  _impl_.simsettings_ = nullptr;
}
inline const ::click::protobuf::HandshakeMessage_SimulationSettings& HandshakeMessage::_internal_simsettings() const {
  const ::click::protobuf::HandshakeMessage_SimulationSettings* p = _impl_.simsettings_;
  return p != nullptr ? *p : reinterpret_cast<const ::click::protobuf::HandshakeMessage_SimulationSettings&>(
      ::click::protobuf::_HandshakeMessage_SimulationSettings_default_instance_);
}
inline const ::click::protobuf::HandshakeMessage_SimulationSettings& HandshakeMessage::simsettings() const {
  // @@protoc_insertion_point(field_get:click.protobuf.HandshakeMessage.simSettings)
  return _internal_simsettings();
}
inline void HandshakeMessage::unsafe_arena_set_allocated_simsettings(
    ::click::protobuf::HandshakeMessage_SimulationSettings* simsettings) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.simsettings_);
  }
  _impl_.simsettings_ = simsettings;
  if (simsettings) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:click.protobuf.HandshakeMessage.simSettings)
}
inline ::click::protobuf::HandshakeMessage_SimulationSettings* HandshakeMessage::release_simsettings() {
  
  ::click::protobuf::HandshakeMessage_SimulationSettings* temp = _impl_.simsettings_;
  _impl_.simsettings_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::click::protobuf::HandshakeMessage_SimulationSettings* HandshakeMessage::unsafe_arena_release_simsettings() {
  // @@protoc_insertion_point(field_release:click.protobuf.HandshakeMessage.simSettings)
  
  ::click::protobuf::HandshakeMessage_SimulationSettings* temp = _impl_.simsettings_;
  _impl_.simsettings_ = nullptr;
  return temp;
}
inline ::click::protobuf::HandshakeMessage_SimulationSettings* HandshakeMessage::_internal_mutable_simsettings() {
  
  if (_impl_.simsettings_ == nullptr) {
    auto* p = CreateMaybeMessage<::click::protobuf::HandshakeMessage_SimulationSettings>(GetArenaForAllocation());
    _impl_.simsettings_ = p;
  }
  return _impl_.simsettings_;
}
inline ::click::protobuf::HandshakeMessage_SimulationSettings* HandshakeMessage::mutable_simsettings() {
  ::click::protobuf::HandshakeMessage_SimulationSettings* _msg = _internal_mutable_simsettings();
  // @@protoc_insertion_point(field_mutable:click.protobuf.HandshakeMessage.simSettings)
  return _msg;
}
inline void HandshakeMessage::set_allocated_simsettings(::click::protobuf::HandshakeMessage_SimulationSettings* simsettings) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.simsettings_;
  }
  if (simsettings) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(simsettings);
    if (message_arena != submessage_arena) {
      simsettings = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, simsettings, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.simsettings_ = simsettings;
  // @@protoc_insertion_point(field_set_allocated:click.protobuf.HandshakeMessage.simSettings)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// ControlMessage_Object

// repeated double angles = 1;
inline int ControlMessage_Object::_internal_angles_size() const {
  return _impl_.angles_.size();
}
inline int ControlMessage_Object::angles_size() const {
  return _internal_angles_size();
}
inline void ControlMessage_Object::clear_angles() {
  _impl_.angles_.Clear();
}
inline double ControlMessage_Object::_internal_angles(int index) const {
  return _impl_.angles_.Get(index);
}
inline double ControlMessage_Object::angles(int index) const {
  // @@protoc_insertion_point(field_get:click.protobuf.ControlMessage.Object.angles)
  return _internal_angles(index);
}
inline void ControlMessage_Object::set_angles(int index, double value) {
  _impl_.angles_.Set(index, value);
  // @@protoc_insertion_point(field_set:click.protobuf.ControlMessage.Object.angles)
}
inline void ControlMessage_Object::_internal_add_angles(double value) {
  _impl_.angles_.Add(value);
}
inline void ControlMessage_Object::add_angles(double value) {
  _internal_add_angles(value);
  // @@protoc_insertion_point(field_add:click.protobuf.ControlMessage.Object.angles)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
ControlMessage_Object::_internal_angles() const {
  return _impl_.angles_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
ControlMessage_Object::angles() const {
  // @@protoc_insertion_point(field_list:click.protobuf.ControlMessage.Object.angles)
  return _internal_angles();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
ControlMessage_Object::_internal_mutable_angles() {
  return &_impl_.angles_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
ControlMessage_Object::mutable_angles() {
  // @@protoc_insertion_point(field_mutable_list:click.protobuf.ControlMessage.Object.angles)
  return _internal_mutable_angles();
}

// repeated double angularVelocities = 2;
inline int ControlMessage_Object::_internal_angularvelocities_size() const {
  return _impl_.angularvelocities_.size();
}
inline int ControlMessage_Object::angularvelocities_size() const {
  return _internal_angularvelocities_size();
}
inline void ControlMessage_Object::clear_angularvelocities() {
  _impl_.angularvelocities_.Clear();
}
inline double ControlMessage_Object::_internal_angularvelocities(int index) const {
  return _impl_.angularvelocities_.Get(index);
}
inline double ControlMessage_Object::angularvelocities(int index) const {
  // @@protoc_insertion_point(field_get:click.protobuf.ControlMessage.Object.angularVelocities)
  return _internal_angularvelocities(index);
}
inline void ControlMessage_Object::set_angularvelocities(int index, double value) {
  _impl_.angularvelocities_.Set(index, value);
  // @@protoc_insertion_point(field_set:click.protobuf.ControlMessage.Object.angularVelocities)
}
inline void ControlMessage_Object::_internal_add_angularvelocities(double value) {
  _impl_.angularvelocities_.Add(value);
}
inline void ControlMessage_Object::add_angularvelocities(double value) {
  _internal_add_angularvelocities(value);
  // @@protoc_insertion_point(field_add:click.protobuf.ControlMessage.Object.angularVelocities)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
ControlMessage_Object::_internal_angularvelocities() const {
  return _impl_.angularvelocities_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
ControlMessage_Object::angularvelocities() const {
  // @@protoc_insertion_point(field_list:click.protobuf.ControlMessage.Object.angularVelocities)
  return _internal_angularvelocities();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
ControlMessage_Object::_internal_mutable_angularvelocities() {
  return &_impl_.angularvelocities_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
ControlMessage_Object::mutable_angularvelocities() {
  // @@protoc_insertion_point(field_mutable_list:click.protobuf.ControlMessage.Object.angularVelocities)
  return _internal_mutable_angularvelocities();
}

// repeated double torques = 3;
inline int ControlMessage_Object::_internal_torques_size() const {
  return _impl_.torques_.size();
}
inline int ControlMessage_Object::torques_size() const {
  return _internal_torques_size();
}
inline void ControlMessage_Object::clear_torques() {
  _impl_.torques_.Clear();
}
inline double ControlMessage_Object::_internal_torques(int index) const {
  return _impl_.torques_.Get(index);
}
inline double ControlMessage_Object::torques(int index) const {
  // @@protoc_insertion_point(field_get:click.protobuf.ControlMessage.Object.torques)
  return _internal_torques(index);
}
inline void ControlMessage_Object::set_torques(int index, double value) {
  _impl_.torques_.Set(index, value);
  // @@protoc_insertion_point(field_set:click.protobuf.ControlMessage.Object.torques)
}
inline void ControlMessage_Object::_internal_add_torques(double value) {
  _impl_.torques_.Add(value);
}
inline void ControlMessage_Object::add_torques(double value) {
  _internal_add_torques(value);
  // @@protoc_insertion_point(field_add:click.protobuf.ControlMessage.Object.torques)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
ControlMessage_Object::_internal_torques() const {
  return _impl_.torques_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
ControlMessage_Object::torques() const {
  // @@protoc_insertion_point(field_list:click.protobuf.ControlMessage.Object.torques)
  return _internal_torques();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
ControlMessage_Object::_internal_mutable_torques() {
  return &_impl_.torques_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
ControlMessage_Object::mutable_torques() {
  // @@protoc_insertion_point(field_mutable_list:click.protobuf.ControlMessage.Object.torques)
  return _internal_mutable_torques();
}

// repeated double values = 5;
inline int ControlMessage_Object::_internal_values_size() const {
  return _impl_.values_.size();
}
inline int ControlMessage_Object::values_size() const {
  return _internal_values_size();
}
inline void ControlMessage_Object::clear_values() {
  _impl_.values_.Clear();
}
inline double ControlMessage_Object::_internal_values(int index) const {
  return _impl_.values_.Get(index);
}
inline double ControlMessage_Object::values(int index) const {
  // @@protoc_insertion_point(field_get:click.protobuf.ControlMessage.Object.values)
  return _internal_values(index);
}
inline void ControlMessage_Object::set_values(int index, double value) {
  _impl_.values_.Set(index, value);
  // @@protoc_insertion_point(field_set:click.protobuf.ControlMessage.Object.values)
}
inline void ControlMessage_Object::_internal_add_values(double value) {
  _impl_.values_.Add(value);
}
inline void ControlMessage_Object::add_values(double value) {
  _internal_add_values(value);
  // @@protoc_insertion_point(field_add:click.protobuf.ControlMessage.Object.values)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
ControlMessage_Object::_internal_values() const {
  return _impl_.values_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
ControlMessage_Object::values() const {
  // @@protoc_insertion_point(field_list:click.protobuf.ControlMessage.Object.values)
  return _internal_values();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
ControlMessage_Object::_internal_mutable_values() {
  return &_impl_.values_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
ControlMessage_Object::mutable_values() {
  // @@protoc_insertion_point(field_mutable_list:click.protobuf.ControlMessage.Object.values)
  return _internal_mutable_values();
}

// map<string, bool> controlEvents = 4;
inline int ControlMessage_Object::_internal_controlevents_size() const {
  return _impl_.controlevents_.size();
}
inline int ControlMessage_Object::controlevents_size() const {
  return _internal_controlevents_size();
}
inline void ControlMessage_Object::clear_controlevents() {
  _impl_.controlevents_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, bool >&
ControlMessage_Object::_internal_controlevents() const {
  return _impl_.controlevents_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, bool >&
ControlMessage_Object::controlevents() const {
  // @@protoc_insertion_point(field_map:click.protobuf.ControlMessage.Object.controlEvents)
  return _internal_controlevents();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, bool >*
ControlMessage_Object::_internal_mutable_controlevents() {
  return _impl_.controlevents_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, bool >*
ControlMessage_Object::mutable_controlevents() {
  // @@protoc_insertion_point(field_mutable_map:click.protobuf.ControlMessage.Object.controlEvents)
  return _internal_mutable_controlevents();
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// ControlMessage

// .click.protobuf.MessageType messageType = 1;
inline void ControlMessage::clear_messagetype() {
  _impl_.messagetype_ = 0;
}
inline ::click::protobuf::MessageType ControlMessage::_internal_messagetype() const {
  return static_cast< ::click::protobuf::MessageType >(_impl_.messagetype_);
}
inline ::click::protobuf::MessageType ControlMessage::messagetype() const {
  // @@protoc_insertion_point(field_get:click.protobuf.ControlMessage.messageType)
  return _internal_messagetype();
}
inline void ControlMessage::_internal_set_messagetype(::click::protobuf::MessageType value) {
  
  _impl_.messagetype_ = value;
}
inline void ControlMessage::set_messagetype(::click::protobuf::MessageType value) {
  _internal_set_messagetype(value);
  // @@protoc_insertion_point(field_set:click.protobuf.ControlMessage.messageType)
}

// map<string, .click.protobuf.ControlMessage.Object> objects = 2;
inline int ControlMessage::_internal_objects_size() const {
  return _impl_.objects_.size();
}
inline int ControlMessage::objects_size() const {
  return _internal_objects_size();
}
inline void ControlMessage::clear_objects() {
  _impl_.objects_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::click::protobuf::ControlMessage_Object >&
ControlMessage::_internal_objects() const {
  return _impl_.objects_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::click::protobuf::ControlMessage_Object >&
ControlMessage::objects() const {
  // @@protoc_insertion_point(field_map:click.protobuf.ControlMessage.objects)
  return _internal_objects();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::click::protobuf::ControlMessage_Object >*
ControlMessage::_internal_mutable_objects() {
  return _impl_.objects_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::click::protobuf::ControlMessage_Object >*
ControlMessage::mutable_objects() {
  // @@protoc_insertion_point(field_mutable_map:click.protobuf.ControlMessage.objects)
  return _internal_mutable_objects();
}

// -------------------------------------------------------------------

// SensorMessage_Vec3

// repeated double arr = 1;
inline int SensorMessage_Vec3::_internal_arr_size() const {
  return _impl_.arr_.size();
}
inline int SensorMessage_Vec3::arr_size() const {
  return _internal_arr_size();
}
inline void SensorMessage_Vec3::clear_arr() {
  _impl_.arr_.Clear();
}
inline double SensorMessage_Vec3::_internal_arr(int index) const {
  return _impl_.arr_.Get(index);
}
inline double SensorMessage_Vec3::arr(int index) const {
  // @@protoc_insertion_point(field_get:click.protobuf.SensorMessage.Vec3.arr)
  return _internal_arr(index);
}
inline void SensorMessage_Vec3::set_arr(int index, double value) {
  _impl_.arr_.Set(index, value);
  // @@protoc_insertion_point(field_set:click.protobuf.SensorMessage.Vec3.arr)
}
inline void SensorMessage_Vec3::_internal_add_arr(double value) {
  _impl_.arr_.Add(value);
}
inline void SensorMessage_Vec3::add_arr(double value) {
  _internal_add_arr(value);
  // @@protoc_insertion_point(field_add:click.protobuf.SensorMessage.Vec3.arr)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
SensorMessage_Vec3::_internal_arr() const {
  return _impl_.arr_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
SensorMessage_Vec3::arr() const {
  // @@protoc_insertion_point(field_list:click.protobuf.SensorMessage.Vec3.arr)
  return _internal_arr();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
SensorMessage_Vec3::_internal_mutable_arr() {
  return &_impl_.arr_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
SensorMessage_Vec3::mutable_arr() {
  // @@protoc_insertion_point(field_mutable_list:click.protobuf.SensorMessage.Vec3.arr)
  return _internal_mutable_arr();
}

// -------------------------------------------------------------------

// SensorMessage_Sensor

// double angle = 1;
inline bool SensorMessage_Sensor::_internal_has_angle() const {
  return value_case() == kAngle;
}
inline bool SensorMessage_Sensor::has_angle() const {
  return _internal_has_angle();
}
inline void SensorMessage_Sensor::set_has_angle() {
  _impl_._oneof_case_[0] = kAngle;
}
inline void SensorMessage_Sensor::clear_angle() {
  if (_internal_has_angle()) {
    _impl_.value_.angle_ = 0;
    clear_has_value();
  }
}
inline double SensorMessage_Sensor::_internal_angle() const {
  if (_internal_has_angle()) {
    return _impl_.value_.angle_;
  }
  return 0;
}
inline void SensorMessage_Sensor::_internal_set_angle(double value) {
  if (!_internal_has_angle()) {
    clear_value();
    set_has_angle();
  }
  _impl_.value_.angle_ = value;
}
inline double SensorMessage_Sensor::angle() const {
  // @@protoc_insertion_point(field_get:click.protobuf.SensorMessage.Sensor.angle)
  return _internal_angle();
}
inline void SensorMessage_Sensor::set_angle(double value) {
  _internal_set_angle(value);
  // @@protoc_insertion_point(field_set:click.protobuf.SensorMessage.Sensor.angle)
}

// double angularVelocity1d = 2;
inline bool SensorMessage_Sensor::_internal_has_angularvelocity1d() const {
  return value_case() == kAngularVelocity1D;
}
inline bool SensorMessage_Sensor::has_angularvelocity1d() const {
  return _internal_has_angularvelocity1d();
}
inline void SensorMessage_Sensor::set_has_angularvelocity1d() {
  _impl_._oneof_case_[0] = kAngularVelocity1D;
}
inline void SensorMessage_Sensor::clear_angularvelocity1d() {
  if (_internal_has_angularvelocity1d()) {
    _impl_.value_.angularvelocity1d_ = 0;
    clear_has_value();
  }
}
inline double SensorMessage_Sensor::_internal_angularvelocity1d() const {
  if (_internal_has_angularvelocity1d()) {
    return _impl_.value_.angularvelocity1d_;
  }
  return 0;
}
inline void SensorMessage_Sensor::_internal_set_angularvelocity1d(double value) {
  if (!_internal_has_angularvelocity1d()) {
    clear_value();
    set_has_angularvelocity1d();
  }
  _impl_.value_.angularvelocity1d_ = value;
}
inline double SensorMessage_Sensor::angularvelocity1d() const {
  // @@protoc_insertion_point(field_get:click.protobuf.SensorMessage.Sensor.angularVelocity1d)
  return _internal_angularvelocity1d();
}
inline void SensorMessage_Sensor::set_angularvelocity1d(double value) {
  _internal_set_angularvelocity1d(value);
  // @@protoc_insertion_point(field_set:click.protobuf.SensorMessage.Sensor.angularVelocity1d)
}

// double torque1d = 3;
inline bool SensorMessage_Sensor::_internal_has_torque1d() const {
  return value_case() == kTorque1D;
}
inline bool SensorMessage_Sensor::has_torque1d() const {
  return _internal_has_torque1d();
}
inline void SensorMessage_Sensor::set_has_torque1d() {
  _impl_._oneof_case_[0] = kTorque1D;
}
inline void SensorMessage_Sensor::clear_torque1d() {
  if (_internal_has_torque1d()) {
    _impl_.value_.torque1d_ = 0;
    clear_has_value();
  }
}
inline double SensorMessage_Sensor::_internal_torque1d() const {
  if (_internal_has_torque1d()) {
    return _impl_.value_.torque1d_;
  }
  return 0;
}
inline void SensorMessage_Sensor::_internal_set_torque1d(double value) {
  if (!_internal_has_torque1d()) {
    clear_value();
    set_has_torque1d();
  }
  _impl_.value_.torque1d_ = value;
}
inline double SensorMessage_Sensor::torque1d() const {
  // @@protoc_insertion_point(field_get:click.protobuf.SensorMessage.Sensor.torque1d)
  return _internal_torque1d();
}
inline void SensorMessage_Sensor::set_torque1d(double value) {
  _internal_set_torque1d(value);
  // @@protoc_insertion_point(field_set:click.protobuf.SensorMessage.Sensor.torque1d)
}

// .click.protobuf.SensorMessage.Vec3 position = 4;
inline bool SensorMessage_Sensor::_internal_has_position() const {
  return value_case() == kPosition;
}
inline bool SensorMessage_Sensor::has_position() const {
  return _internal_has_position();
}
inline void SensorMessage_Sensor::set_has_position() {
  _impl_._oneof_case_[0] = kPosition;
}
inline void SensorMessage_Sensor::clear_position() {
  if (_internal_has_position()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.value_.position_;
    }
    clear_has_value();
  }
}
inline ::click::protobuf::SensorMessage_Vec3* SensorMessage_Sensor::release_position() {
  // @@protoc_insertion_point(field_release:click.protobuf.SensorMessage.Sensor.position)
  if (_internal_has_position()) {
    clear_has_value();
    ::click::protobuf::SensorMessage_Vec3* temp = _impl_.value_.position_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.value_.position_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::click::protobuf::SensorMessage_Vec3& SensorMessage_Sensor::_internal_position() const {
  return _internal_has_position()
      ? *_impl_.value_.position_
      : reinterpret_cast< ::click::protobuf::SensorMessage_Vec3&>(::click::protobuf::_SensorMessage_Vec3_default_instance_);
}
inline const ::click::protobuf::SensorMessage_Vec3& SensorMessage_Sensor::position() const {
  // @@protoc_insertion_point(field_get:click.protobuf.SensorMessage.Sensor.position)
  return _internal_position();
}
inline ::click::protobuf::SensorMessage_Vec3* SensorMessage_Sensor::unsafe_arena_release_position() {
  // @@protoc_insertion_point(field_unsafe_arena_release:click.protobuf.SensorMessage.Sensor.position)
  if (_internal_has_position()) {
    clear_has_value();
    ::click::protobuf::SensorMessage_Vec3* temp = _impl_.value_.position_;
    _impl_.value_.position_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SensorMessage_Sensor::unsafe_arena_set_allocated_position(::click::protobuf::SensorMessage_Vec3* position) {
  clear_value();
  if (position) {
    set_has_position();
    _impl_.value_.position_ = position;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:click.protobuf.SensorMessage.Sensor.position)
}
inline ::click::protobuf::SensorMessage_Vec3* SensorMessage_Sensor::_internal_mutable_position() {
  if (!_internal_has_position()) {
    clear_value();
    set_has_position();
    _impl_.value_.position_ = CreateMaybeMessage< ::click::protobuf::SensorMessage_Vec3 >(GetArenaForAllocation());
  }
  return _impl_.value_.position_;
}
inline ::click::protobuf::SensorMessage_Vec3* SensorMessage_Sensor::mutable_position() {
  ::click::protobuf::SensorMessage_Vec3* _msg = _internal_mutable_position();
  // @@protoc_insertion_point(field_mutable:click.protobuf.SensorMessage.Sensor.position)
  return _msg;
}

// .click.protobuf.SensorMessage.Vec3 rpy = 5;
inline bool SensorMessage_Sensor::_internal_has_rpy() const {
  return value_case() == kRpy;
}
inline bool SensorMessage_Sensor::has_rpy() const {
  return _internal_has_rpy();
}
inline void SensorMessage_Sensor::set_has_rpy() {
  _impl_._oneof_case_[0] = kRpy;
}
inline void SensorMessage_Sensor::clear_rpy() {
  if (_internal_has_rpy()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.value_.rpy_;
    }
    clear_has_value();
  }
}
inline ::click::protobuf::SensorMessage_Vec3* SensorMessage_Sensor::release_rpy() {
  // @@protoc_insertion_point(field_release:click.protobuf.SensorMessage.Sensor.rpy)
  if (_internal_has_rpy()) {
    clear_has_value();
    ::click::protobuf::SensorMessage_Vec3* temp = _impl_.value_.rpy_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.value_.rpy_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::click::protobuf::SensorMessage_Vec3& SensorMessage_Sensor::_internal_rpy() const {
  return _internal_has_rpy()
      ? *_impl_.value_.rpy_
      : reinterpret_cast< ::click::protobuf::SensorMessage_Vec3&>(::click::protobuf::_SensorMessage_Vec3_default_instance_);
}
inline const ::click::protobuf::SensorMessage_Vec3& SensorMessage_Sensor::rpy() const {
  // @@protoc_insertion_point(field_get:click.protobuf.SensorMessage.Sensor.rpy)
  return _internal_rpy();
}
inline ::click::protobuf::SensorMessage_Vec3* SensorMessage_Sensor::unsafe_arena_release_rpy() {
  // @@protoc_insertion_point(field_unsafe_arena_release:click.protobuf.SensorMessage.Sensor.rpy)
  if (_internal_has_rpy()) {
    clear_has_value();
    ::click::protobuf::SensorMessage_Vec3* temp = _impl_.value_.rpy_;
    _impl_.value_.rpy_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SensorMessage_Sensor::unsafe_arena_set_allocated_rpy(::click::protobuf::SensorMessage_Vec3* rpy) {
  clear_value();
  if (rpy) {
    set_has_rpy();
    _impl_.value_.rpy_ = rpy;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:click.protobuf.SensorMessage.Sensor.rpy)
}
inline ::click::protobuf::SensorMessage_Vec3* SensorMessage_Sensor::_internal_mutable_rpy() {
  if (!_internal_has_rpy()) {
    clear_value();
    set_has_rpy();
    _impl_.value_.rpy_ = CreateMaybeMessage< ::click::protobuf::SensorMessage_Vec3 >(GetArenaForAllocation());
  }
  return _impl_.value_.rpy_;
}
inline ::click::protobuf::SensorMessage_Vec3* SensorMessage_Sensor::mutable_rpy() {
  ::click::protobuf::SensorMessage_Vec3* _msg = _internal_mutable_rpy();
  // @@protoc_insertion_point(field_mutable:click.protobuf.SensorMessage.Sensor.rpy)
  return _msg;
}

// bool activated = 6;
inline bool SensorMessage_Sensor::_internal_has_activated() const {
  return value_case() == kActivated;
}
inline bool SensorMessage_Sensor::has_activated() const {
  return _internal_has_activated();
}
inline void SensorMessage_Sensor::set_has_activated() {
  _impl_._oneof_case_[0] = kActivated;
}
inline void SensorMessage_Sensor::clear_activated() {
  if (_internal_has_activated()) {
    _impl_.value_.activated_ = false;
    clear_has_value();
  }
}
inline bool SensorMessage_Sensor::_internal_activated() const {
  if (_internal_has_activated()) {
    return _impl_.value_.activated_;
  }
  return false;
}
inline void SensorMessage_Sensor::_internal_set_activated(bool value) {
  if (!_internal_has_activated()) {
    clear_value();
    set_has_activated();
  }
  _impl_.value_.activated_ = value;
}
inline bool SensorMessage_Sensor::activated() const {
  // @@protoc_insertion_point(field_get:click.protobuf.SensorMessage.Sensor.activated)
  return _internal_activated();
}
inline void SensorMessage_Sensor::set_activated(bool value) {
  _internal_set_activated(value);
  // @@protoc_insertion_point(field_set:click.protobuf.SensorMessage.Sensor.activated)
}

// .click.protobuf.SensorMessage.Vec3 acceleration3d = 7;
inline bool SensorMessage_Sensor::_internal_has_acceleration3d() const {
  return value_case() == kAcceleration3D;
}
inline bool SensorMessage_Sensor::has_acceleration3d() const {
  return _internal_has_acceleration3d();
}
inline void SensorMessage_Sensor::set_has_acceleration3d() {
  _impl_._oneof_case_[0] = kAcceleration3D;
}
inline void SensorMessage_Sensor::clear_acceleration3d() {
  if (_internal_has_acceleration3d()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.value_.acceleration3d_;
    }
    clear_has_value();
  }
}
inline ::click::protobuf::SensorMessage_Vec3* SensorMessage_Sensor::release_acceleration3d() {
  // @@protoc_insertion_point(field_release:click.protobuf.SensorMessage.Sensor.acceleration3d)
  if (_internal_has_acceleration3d()) {
    clear_has_value();
    ::click::protobuf::SensorMessage_Vec3* temp = _impl_.value_.acceleration3d_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.value_.acceleration3d_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::click::protobuf::SensorMessage_Vec3& SensorMessage_Sensor::_internal_acceleration3d() const {
  return _internal_has_acceleration3d()
      ? *_impl_.value_.acceleration3d_
      : reinterpret_cast< ::click::protobuf::SensorMessage_Vec3&>(::click::protobuf::_SensorMessage_Vec3_default_instance_);
}
inline const ::click::protobuf::SensorMessage_Vec3& SensorMessage_Sensor::acceleration3d() const {
  // @@protoc_insertion_point(field_get:click.protobuf.SensorMessage.Sensor.acceleration3d)
  return _internal_acceleration3d();
}
inline ::click::protobuf::SensorMessage_Vec3* SensorMessage_Sensor::unsafe_arena_release_acceleration3d() {
  // @@protoc_insertion_point(field_unsafe_arena_release:click.protobuf.SensorMessage.Sensor.acceleration3d)
  if (_internal_has_acceleration3d()) {
    clear_has_value();
    ::click::protobuf::SensorMessage_Vec3* temp = _impl_.value_.acceleration3d_;
    _impl_.value_.acceleration3d_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SensorMessage_Sensor::unsafe_arena_set_allocated_acceleration3d(::click::protobuf::SensorMessage_Vec3* acceleration3d) {
  clear_value();
  if (acceleration3d) {
    set_has_acceleration3d();
    _impl_.value_.acceleration3d_ = acceleration3d;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:click.protobuf.SensorMessage.Sensor.acceleration3d)
}
inline ::click::protobuf::SensorMessage_Vec3* SensorMessage_Sensor::_internal_mutable_acceleration3d() {
  if (!_internal_has_acceleration3d()) {
    clear_value();
    set_has_acceleration3d();
    _impl_.value_.acceleration3d_ = CreateMaybeMessage< ::click::protobuf::SensorMessage_Vec3 >(GetArenaForAllocation());
  }
  return _impl_.value_.acceleration3d_;
}
inline ::click::protobuf::SensorMessage_Vec3* SensorMessage_Sensor::mutable_acceleration3d() {
  ::click::protobuf::SensorMessage_Vec3* _msg = _internal_mutable_acceleration3d();
  // @@protoc_insertion_point(field_mutable:click.protobuf.SensorMessage.Sensor.acceleration3d)
  return _msg;
}

// .click.protobuf.SensorMessage.Vec3 force3d = 8;
inline bool SensorMessage_Sensor::_internal_has_force3d() const {
  return value_case() == kForce3D;
}
inline bool SensorMessage_Sensor::has_force3d() const {
  return _internal_has_force3d();
}
inline void SensorMessage_Sensor::set_has_force3d() {
  _impl_._oneof_case_[0] = kForce3D;
}
inline void SensorMessage_Sensor::clear_force3d() {
  if (_internal_has_force3d()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.value_.force3d_;
    }
    clear_has_value();
  }
}
inline ::click::protobuf::SensorMessage_Vec3* SensorMessage_Sensor::release_force3d() {
  // @@protoc_insertion_point(field_release:click.protobuf.SensorMessage.Sensor.force3d)
  if (_internal_has_force3d()) {
    clear_has_value();
    ::click::protobuf::SensorMessage_Vec3* temp = _impl_.value_.force3d_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.value_.force3d_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::click::protobuf::SensorMessage_Vec3& SensorMessage_Sensor::_internal_force3d() const {
  return _internal_has_force3d()
      ? *_impl_.value_.force3d_
      : reinterpret_cast< ::click::protobuf::SensorMessage_Vec3&>(::click::protobuf::_SensorMessage_Vec3_default_instance_);
}
inline const ::click::protobuf::SensorMessage_Vec3& SensorMessage_Sensor::force3d() const {
  // @@protoc_insertion_point(field_get:click.protobuf.SensorMessage.Sensor.force3d)
  return _internal_force3d();
}
inline ::click::protobuf::SensorMessage_Vec3* SensorMessage_Sensor::unsafe_arena_release_force3d() {
  // @@protoc_insertion_point(field_unsafe_arena_release:click.protobuf.SensorMessage.Sensor.force3d)
  if (_internal_has_force3d()) {
    clear_has_value();
    ::click::protobuf::SensorMessage_Vec3* temp = _impl_.value_.force3d_;
    _impl_.value_.force3d_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SensorMessage_Sensor::unsafe_arena_set_allocated_force3d(::click::protobuf::SensorMessage_Vec3* force3d) {
  clear_value();
  if (force3d) {
    set_has_force3d();
    _impl_.value_.force3d_ = force3d;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:click.protobuf.SensorMessage.Sensor.force3d)
}
inline ::click::protobuf::SensorMessage_Vec3* SensorMessage_Sensor::_internal_mutable_force3d() {
  if (!_internal_has_force3d()) {
    clear_value();
    set_has_force3d();
    _impl_.value_.force3d_ = CreateMaybeMessage< ::click::protobuf::SensorMessage_Vec3 >(GetArenaForAllocation());
  }
  return _impl_.value_.force3d_;
}
inline ::click::protobuf::SensorMessage_Vec3* SensorMessage_Sensor::mutable_force3d() {
  ::click::protobuf::SensorMessage_Vec3* _msg = _internal_mutable_force3d();
  // @@protoc_insertion_point(field_mutable:click.protobuf.SensorMessage.Sensor.force3d)
  return _msg;
}

// .click.protobuf.SensorMessage.Vec3 torque3d = 9;
inline bool SensorMessage_Sensor::_internal_has_torque3d() const {
  return value_case() == kTorque3D;
}
inline bool SensorMessage_Sensor::has_torque3d() const {
  return _internal_has_torque3d();
}
inline void SensorMessage_Sensor::set_has_torque3d() {
  _impl_._oneof_case_[0] = kTorque3D;
}
inline void SensorMessage_Sensor::clear_torque3d() {
  if (_internal_has_torque3d()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.value_.torque3d_;
    }
    clear_has_value();
  }
}
inline ::click::protobuf::SensorMessage_Vec3* SensorMessage_Sensor::release_torque3d() {
  // @@protoc_insertion_point(field_release:click.protobuf.SensorMessage.Sensor.torque3d)
  if (_internal_has_torque3d()) {
    clear_has_value();
    ::click::protobuf::SensorMessage_Vec3* temp = _impl_.value_.torque3d_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.value_.torque3d_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::click::protobuf::SensorMessage_Vec3& SensorMessage_Sensor::_internal_torque3d() const {
  return _internal_has_torque3d()
      ? *_impl_.value_.torque3d_
      : reinterpret_cast< ::click::protobuf::SensorMessage_Vec3&>(::click::protobuf::_SensorMessage_Vec3_default_instance_);
}
inline const ::click::protobuf::SensorMessage_Vec3& SensorMessage_Sensor::torque3d() const {
  // @@protoc_insertion_point(field_get:click.protobuf.SensorMessage.Sensor.torque3d)
  return _internal_torque3d();
}
inline ::click::protobuf::SensorMessage_Vec3* SensorMessage_Sensor::unsafe_arena_release_torque3d() {
  // @@protoc_insertion_point(field_unsafe_arena_release:click.protobuf.SensorMessage.Sensor.torque3d)
  if (_internal_has_torque3d()) {
    clear_has_value();
    ::click::protobuf::SensorMessage_Vec3* temp = _impl_.value_.torque3d_;
    _impl_.value_.torque3d_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SensorMessage_Sensor::unsafe_arena_set_allocated_torque3d(::click::protobuf::SensorMessage_Vec3* torque3d) {
  clear_value();
  if (torque3d) {
    set_has_torque3d();
    _impl_.value_.torque3d_ = torque3d;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:click.protobuf.SensorMessage.Sensor.torque3d)
}
inline ::click::protobuf::SensorMessage_Vec3* SensorMessage_Sensor::_internal_mutable_torque3d() {
  if (!_internal_has_torque3d()) {
    clear_value();
    set_has_torque3d();
    _impl_.value_.torque3d_ = CreateMaybeMessage< ::click::protobuf::SensorMessage_Vec3 >(GetArenaForAllocation());
  }
  return _impl_.value_.torque3d_;
}
inline ::click::protobuf::SensorMessage_Vec3* SensorMessage_Sensor::mutable_torque3d() {
  ::click::protobuf::SensorMessage_Vec3* _msg = _internal_mutable_torque3d();
  // @@protoc_insertion_point(field_mutable:click.protobuf.SensorMessage.Sensor.torque3d)
  return _msg;
}

// .click.protobuf.SensorMessage.Vec3 angularAcceleration3d = 10;
inline bool SensorMessage_Sensor::_internal_has_angularacceleration3d() const {
  return value_case() == kAngularAcceleration3D;
}
inline bool SensorMessage_Sensor::has_angularacceleration3d() const {
  return _internal_has_angularacceleration3d();
}
inline void SensorMessage_Sensor::set_has_angularacceleration3d() {
  _impl_._oneof_case_[0] = kAngularAcceleration3D;
}
inline void SensorMessage_Sensor::clear_angularacceleration3d() {
  if (_internal_has_angularacceleration3d()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.value_.angularacceleration3d_;
    }
    clear_has_value();
  }
}
inline ::click::protobuf::SensorMessage_Vec3* SensorMessage_Sensor::release_angularacceleration3d() {
  // @@protoc_insertion_point(field_release:click.protobuf.SensorMessage.Sensor.angularAcceleration3d)
  if (_internal_has_angularacceleration3d()) {
    clear_has_value();
    ::click::protobuf::SensorMessage_Vec3* temp = _impl_.value_.angularacceleration3d_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.value_.angularacceleration3d_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::click::protobuf::SensorMessage_Vec3& SensorMessage_Sensor::_internal_angularacceleration3d() const {
  return _internal_has_angularacceleration3d()
      ? *_impl_.value_.angularacceleration3d_
      : reinterpret_cast< ::click::protobuf::SensorMessage_Vec3&>(::click::protobuf::_SensorMessage_Vec3_default_instance_);
}
inline const ::click::protobuf::SensorMessage_Vec3& SensorMessage_Sensor::angularacceleration3d() const {
  // @@protoc_insertion_point(field_get:click.protobuf.SensorMessage.Sensor.angularAcceleration3d)
  return _internal_angularacceleration3d();
}
inline ::click::protobuf::SensorMessage_Vec3* SensorMessage_Sensor::unsafe_arena_release_angularacceleration3d() {
  // @@protoc_insertion_point(field_unsafe_arena_release:click.protobuf.SensorMessage.Sensor.angularAcceleration3d)
  if (_internal_has_angularacceleration3d()) {
    clear_has_value();
    ::click::protobuf::SensorMessage_Vec3* temp = _impl_.value_.angularacceleration3d_;
    _impl_.value_.angularacceleration3d_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SensorMessage_Sensor::unsafe_arena_set_allocated_angularacceleration3d(::click::protobuf::SensorMessage_Vec3* angularacceleration3d) {
  clear_value();
  if (angularacceleration3d) {
    set_has_angularacceleration3d();
    _impl_.value_.angularacceleration3d_ = angularacceleration3d;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:click.protobuf.SensorMessage.Sensor.angularAcceleration3d)
}
inline ::click::protobuf::SensorMessage_Vec3* SensorMessage_Sensor::_internal_mutable_angularacceleration3d() {
  if (!_internal_has_angularacceleration3d()) {
    clear_value();
    set_has_angularacceleration3d();
    _impl_.value_.angularacceleration3d_ = CreateMaybeMessage< ::click::protobuf::SensorMessage_Vec3 >(GetArenaForAllocation());
  }
  return _impl_.value_.angularacceleration3d_;
}
inline ::click::protobuf::SensorMessage_Vec3* SensorMessage_Sensor::mutable_angularacceleration3d() {
  ::click::protobuf::SensorMessage_Vec3* _msg = _internal_mutable_angularacceleration3d();
  // @@protoc_insertion_point(field_mutable:click.protobuf.SensorMessage.Sensor.angularAcceleration3d)
  return _msg;
}

// .click.protobuf.SensorMessage.Vec3 velocity3d = 12;
inline bool SensorMessage_Sensor::_internal_has_velocity3d() const {
  return value_case() == kVelocity3D;
}
inline bool SensorMessage_Sensor::has_velocity3d() const {
  return _internal_has_velocity3d();
}
inline void SensorMessage_Sensor::set_has_velocity3d() {
  _impl_._oneof_case_[0] = kVelocity3D;
}
inline void SensorMessage_Sensor::clear_velocity3d() {
  if (_internal_has_velocity3d()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.value_.velocity3d_;
    }
    clear_has_value();
  }
}
inline ::click::protobuf::SensorMessage_Vec3* SensorMessage_Sensor::release_velocity3d() {
  // @@protoc_insertion_point(field_release:click.protobuf.SensorMessage.Sensor.velocity3d)
  if (_internal_has_velocity3d()) {
    clear_has_value();
    ::click::protobuf::SensorMessage_Vec3* temp = _impl_.value_.velocity3d_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.value_.velocity3d_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::click::protobuf::SensorMessage_Vec3& SensorMessage_Sensor::_internal_velocity3d() const {
  return _internal_has_velocity3d()
      ? *_impl_.value_.velocity3d_
      : reinterpret_cast< ::click::protobuf::SensorMessage_Vec3&>(::click::protobuf::_SensorMessage_Vec3_default_instance_);
}
inline const ::click::protobuf::SensorMessage_Vec3& SensorMessage_Sensor::velocity3d() const {
  // @@protoc_insertion_point(field_get:click.protobuf.SensorMessage.Sensor.velocity3d)
  return _internal_velocity3d();
}
inline ::click::protobuf::SensorMessage_Vec3* SensorMessage_Sensor::unsafe_arena_release_velocity3d() {
  // @@protoc_insertion_point(field_unsafe_arena_release:click.protobuf.SensorMessage.Sensor.velocity3d)
  if (_internal_has_velocity3d()) {
    clear_has_value();
    ::click::protobuf::SensorMessage_Vec3* temp = _impl_.value_.velocity3d_;
    _impl_.value_.velocity3d_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SensorMessage_Sensor::unsafe_arena_set_allocated_velocity3d(::click::protobuf::SensorMessage_Vec3* velocity3d) {
  clear_value();
  if (velocity3d) {
    set_has_velocity3d();
    _impl_.value_.velocity3d_ = velocity3d;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:click.protobuf.SensorMessage.Sensor.velocity3d)
}
inline ::click::protobuf::SensorMessage_Vec3* SensorMessage_Sensor::_internal_mutable_velocity3d() {
  if (!_internal_has_velocity3d()) {
    clear_value();
    set_has_velocity3d();
    _impl_.value_.velocity3d_ = CreateMaybeMessage< ::click::protobuf::SensorMessage_Vec3 >(GetArenaForAllocation());
  }
  return _impl_.value_.velocity3d_;
}
inline ::click::protobuf::SensorMessage_Vec3* SensorMessage_Sensor::mutable_velocity3d() {
  ::click::protobuf::SensorMessage_Vec3* _msg = _internal_mutable_velocity3d();
  // @@protoc_insertion_point(field_mutable:click.protobuf.SensorMessage.Sensor.velocity3d)
  return _msg;
}

// .click.protobuf.SensorMessage.Vec3 angularVelocity3d = 13;
inline bool SensorMessage_Sensor::_internal_has_angularvelocity3d() const {
  return value_case() == kAngularVelocity3D;
}
inline bool SensorMessage_Sensor::has_angularvelocity3d() const {
  return _internal_has_angularvelocity3d();
}
inline void SensorMessage_Sensor::set_has_angularvelocity3d() {
  _impl_._oneof_case_[0] = kAngularVelocity3D;
}
inline void SensorMessage_Sensor::clear_angularvelocity3d() {
  if (_internal_has_angularvelocity3d()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.value_.angularvelocity3d_;
    }
    clear_has_value();
  }
}
inline ::click::protobuf::SensorMessage_Vec3* SensorMessage_Sensor::release_angularvelocity3d() {
  // @@protoc_insertion_point(field_release:click.protobuf.SensorMessage.Sensor.angularVelocity3d)
  if (_internal_has_angularvelocity3d()) {
    clear_has_value();
    ::click::protobuf::SensorMessage_Vec3* temp = _impl_.value_.angularvelocity3d_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.value_.angularvelocity3d_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::click::protobuf::SensorMessage_Vec3& SensorMessage_Sensor::_internal_angularvelocity3d() const {
  return _internal_has_angularvelocity3d()
      ? *_impl_.value_.angularvelocity3d_
      : reinterpret_cast< ::click::protobuf::SensorMessage_Vec3&>(::click::protobuf::_SensorMessage_Vec3_default_instance_);
}
inline const ::click::protobuf::SensorMessage_Vec3& SensorMessage_Sensor::angularvelocity3d() const {
  // @@protoc_insertion_point(field_get:click.protobuf.SensorMessage.Sensor.angularVelocity3d)
  return _internal_angularvelocity3d();
}
inline ::click::protobuf::SensorMessage_Vec3* SensorMessage_Sensor::unsafe_arena_release_angularvelocity3d() {
  // @@protoc_insertion_point(field_unsafe_arena_release:click.protobuf.SensorMessage.Sensor.angularVelocity3d)
  if (_internal_has_angularvelocity3d()) {
    clear_has_value();
    ::click::protobuf::SensorMessage_Vec3* temp = _impl_.value_.angularvelocity3d_;
    _impl_.value_.angularvelocity3d_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SensorMessage_Sensor::unsafe_arena_set_allocated_angularvelocity3d(::click::protobuf::SensorMessage_Vec3* angularvelocity3d) {
  clear_value();
  if (angularvelocity3d) {
    set_has_angularvelocity3d();
    _impl_.value_.angularvelocity3d_ = angularvelocity3d;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:click.protobuf.SensorMessage.Sensor.angularVelocity3d)
}
inline ::click::protobuf::SensorMessage_Vec3* SensorMessage_Sensor::_internal_mutable_angularvelocity3d() {
  if (!_internal_has_angularvelocity3d()) {
    clear_value();
    set_has_angularvelocity3d();
    _impl_.value_.angularvelocity3d_ = CreateMaybeMessage< ::click::protobuf::SensorMessage_Vec3 >(GetArenaForAllocation());
  }
  return _impl_.value_.angularvelocity3d_;
}
inline ::click::protobuf::SensorMessage_Vec3* SensorMessage_Sensor::mutable_angularvelocity3d() {
  ::click::protobuf::SensorMessage_Vec3* _msg = _internal_mutable_angularvelocity3d();
  // @@protoc_insertion_point(field_mutable:click.protobuf.SensorMessage.Sensor.angularVelocity3d)
  return _msg;
}

// double force1d = 14;
inline bool SensorMessage_Sensor::_internal_has_force1d() const {
  return value_case() == kForce1D;
}
inline bool SensorMessage_Sensor::has_force1d() const {
  return _internal_has_force1d();
}
inline void SensorMessage_Sensor::set_has_force1d() {
  _impl_._oneof_case_[0] = kForce1D;
}
inline void SensorMessage_Sensor::clear_force1d() {
  if (_internal_has_force1d()) {
    _impl_.value_.force1d_ = 0;
    clear_has_value();
  }
}
inline double SensorMessage_Sensor::_internal_force1d() const {
  if (_internal_has_force1d()) {
    return _impl_.value_.force1d_;
  }
  return 0;
}
inline void SensorMessage_Sensor::_internal_set_force1d(double value) {
  if (!_internal_has_force1d()) {
    clear_value();
    set_has_force1d();
  }
  _impl_.value_.force1d_ = value;
}
inline double SensorMessage_Sensor::force1d() const {
  // @@protoc_insertion_point(field_get:click.protobuf.SensorMessage.Sensor.force1d)
  return _internal_force1d();
}
inline void SensorMessage_Sensor::set_force1d(double value) {
  _internal_set_force1d(value);
  // @@protoc_insertion_point(field_set:click.protobuf.SensorMessage.Sensor.force1d)
}

inline bool SensorMessage_Sensor::has_value() const {
  return value_case() != VALUE_NOT_SET;
}
inline void SensorMessage_Sensor::clear_has_value() {
  _impl_._oneof_case_[0] = VALUE_NOT_SET;
}
inline SensorMessage_Sensor::ValueCase SensorMessage_Sensor::value_case() const {
  return SensorMessage_Sensor::ValueCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// SensorMessage_Sensors

// repeated .click.protobuf.SensorMessage.Sensor sensor = 1;
inline int SensorMessage_Sensors::_internal_sensor_size() const {
  return _impl_.sensor_.size();
}
inline int SensorMessage_Sensors::sensor_size() const {
  return _internal_sensor_size();
}
inline void SensorMessage_Sensors::clear_sensor() {
  _impl_.sensor_.Clear();
}
inline ::click::protobuf::SensorMessage_Sensor* SensorMessage_Sensors::mutable_sensor(int index) {
  // @@protoc_insertion_point(field_mutable:click.protobuf.SensorMessage.Sensors.sensor)
  return _impl_.sensor_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::click::protobuf::SensorMessage_Sensor >*
SensorMessage_Sensors::mutable_sensor() {
  // @@protoc_insertion_point(field_mutable_list:click.protobuf.SensorMessage.Sensors.sensor)
  return &_impl_.sensor_;
}
inline const ::click::protobuf::SensorMessage_Sensor& SensorMessage_Sensors::_internal_sensor(int index) const {
  return _impl_.sensor_.Get(index);
}
inline const ::click::protobuf::SensorMessage_Sensor& SensorMessage_Sensors::sensor(int index) const {
  // @@protoc_insertion_point(field_get:click.protobuf.SensorMessage.Sensors.sensor)
  return _internal_sensor(index);
}
inline ::click::protobuf::SensorMessage_Sensor* SensorMessage_Sensors::_internal_add_sensor() {
  return _impl_.sensor_.Add();
}
inline ::click::protobuf::SensorMessage_Sensor* SensorMessage_Sensors::add_sensor() {
  ::click::protobuf::SensorMessage_Sensor* _add = _internal_add_sensor();
  // @@protoc_insertion_point(field_add:click.protobuf.SensorMessage.Sensors.sensor)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::click::protobuf::SensorMessage_Sensor >&
SensorMessage_Sensors::sensor() const {
  // @@protoc_insertion_point(field_list:click.protobuf.SensorMessage.Sensors.sensor)
  return _impl_.sensor_;
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// SensorMessage_Object

// repeated double angleSensors = 1;
inline int SensorMessage_Object::_internal_anglesensors_size() const {
  return _impl_.anglesensors_.size();
}
inline int SensorMessage_Object::anglesensors_size() const {
  return _internal_anglesensors_size();
}
inline void SensorMessage_Object::clear_anglesensors() {
  _impl_.anglesensors_.Clear();
}
inline double SensorMessage_Object::_internal_anglesensors(int index) const {
  return _impl_.anglesensors_.Get(index);
}
inline double SensorMessage_Object::anglesensors(int index) const {
  // @@protoc_insertion_point(field_get:click.protobuf.SensorMessage.Object.angleSensors)
  return _internal_anglesensors(index);
}
inline void SensorMessage_Object::set_anglesensors(int index, double value) {
  _impl_.anglesensors_.Set(index, value);
  // @@protoc_insertion_point(field_set:click.protobuf.SensorMessage.Object.angleSensors)
}
inline void SensorMessage_Object::_internal_add_anglesensors(double value) {
  _impl_.anglesensors_.Add(value);
}
inline void SensorMessage_Object::add_anglesensors(double value) {
  _internal_add_anglesensors(value);
  // @@protoc_insertion_point(field_add:click.protobuf.SensorMessage.Object.angleSensors)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
SensorMessage_Object::_internal_anglesensors() const {
  return _impl_.anglesensors_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
SensorMessage_Object::anglesensors() const {
  // @@protoc_insertion_point(field_list:click.protobuf.SensorMessage.Object.angleSensors)
  return _internal_anglesensors();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
SensorMessage_Object::_internal_mutable_anglesensors() {
  return &_impl_.anglesensors_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
SensorMessage_Object::mutable_anglesensors() {
  // @@protoc_insertion_point(field_mutable_list:click.protobuf.SensorMessage.Object.angleSensors)
  return _internal_mutable_anglesensors();
}

// repeated double angularVelocitySensors = 2;
inline int SensorMessage_Object::_internal_angularvelocitysensors_size() const {
  return _impl_.angularvelocitysensors_.size();
}
inline int SensorMessage_Object::angularvelocitysensors_size() const {
  return _internal_angularvelocitysensors_size();
}
inline void SensorMessage_Object::clear_angularvelocitysensors() {
  _impl_.angularvelocitysensors_.Clear();
}
inline double SensorMessage_Object::_internal_angularvelocitysensors(int index) const {
  return _impl_.angularvelocitysensors_.Get(index);
}
inline double SensorMessage_Object::angularvelocitysensors(int index) const {
  // @@protoc_insertion_point(field_get:click.protobuf.SensorMessage.Object.angularVelocitySensors)
  return _internal_angularvelocitysensors(index);
}
inline void SensorMessage_Object::set_angularvelocitysensors(int index, double value) {
  _impl_.angularvelocitysensors_.Set(index, value);
  // @@protoc_insertion_point(field_set:click.protobuf.SensorMessage.Object.angularVelocitySensors)
}
inline void SensorMessage_Object::_internal_add_angularvelocitysensors(double value) {
  _impl_.angularvelocitysensors_.Add(value);
}
inline void SensorMessage_Object::add_angularvelocitysensors(double value) {
  _internal_add_angularvelocitysensors(value);
  // @@protoc_insertion_point(field_add:click.protobuf.SensorMessage.Object.angularVelocitySensors)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
SensorMessage_Object::_internal_angularvelocitysensors() const {
  return _impl_.angularvelocitysensors_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
SensorMessage_Object::angularvelocitysensors() const {
  // @@protoc_insertion_point(field_list:click.protobuf.SensorMessage.Object.angularVelocitySensors)
  return _internal_angularvelocitysensors();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
SensorMessage_Object::_internal_mutable_angularvelocitysensors() {
  return &_impl_.angularvelocitysensors_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
SensorMessage_Object::mutable_angularvelocitysensors() {
  // @@protoc_insertion_point(field_mutable_list:click.protobuf.SensorMessage.Object.angularVelocitySensors)
  return _internal_mutable_angularvelocitysensors();
}

// repeated double torqueSensors = 3;
inline int SensorMessage_Object::_internal_torquesensors_size() const {
  return _impl_.torquesensors_.size();
}
inline int SensorMessage_Object::torquesensors_size() const {
  return _internal_torquesensors_size();
}
inline void SensorMessage_Object::clear_torquesensors() {
  _impl_.torquesensors_.Clear();
}
inline double SensorMessage_Object::_internal_torquesensors(int index) const {
  return _impl_.torquesensors_.Get(index);
}
inline double SensorMessage_Object::torquesensors(int index) const {
  // @@protoc_insertion_point(field_get:click.protobuf.SensorMessage.Object.torqueSensors)
  return _internal_torquesensors(index);
}
inline void SensorMessage_Object::set_torquesensors(int index, double value) {
  _impl_.torquesensors_.Set(index, value);
  // @@protoc_insertion_point(field_set:click.protobuf.SensorMessage.Object.torqueSensors)
}
inline void SensorMessage_Object::_internal_add_torquesensors(double value) {
  _impl_.torquesensors_.Add(value);
}
inline void SensorMessage_Object::add_torquesensors(double value) {
  _internal_add_torquesensors(value);
  // @@protoc_insertion_point(field_add:click.protobuf.SensorMessage.Object.torqueSensors)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
SensorMessage_Object::_internal_torquesensors() const {
  return _impl_.torquesensors_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
SensorMessage_Object::torquesensors() const {
  // @@protoc_insertion_point(field_list:click.protobuf.SensorMessage.Object.torqueSensors)
  return _internal_torquesensors();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
SensorMessage_Object::_internal_mutable_torquesensors() {
  return &_impl_.torquesensors_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
SensorMessage_Object::mutable_torquesensors() {
  // @@protoc_insertion_point(field_mutable_list:click.protobuf.SensorMessage.Object.torqueSensors)
  return _internal_mutable_torquesensors();
}

// repeated .click.protobuf.SensorMessage.Vec3 forceSensors = 5;
inline int SensorMessage_Object::_internal_forcesensors_size() const {
  return _impl_.forcesensors_.size();
}
inline int SensorMessage_Object::forcesensors_size() const {
  return _internal_forcesensors_size();
}
inline void SensorMessage_Object::clear_forcesensors() {
  _impl_.forcesensors_.Clear();
}
inline ::click::protobuf::SensorMessage_Vec3* SensorMessage_Object::mutable_forcesensors(int index) {
  // @@protoc_insertion_point(field_mutable:click.protobuf.SensorMessage.Object.forceSensors)
  return _impl_.forcesensors_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::click::protobuf::SensorMessage_Vec3 >*
SensorMessage_Object::mutable_forcesensors() {
  // @@protoc_insertion_point(field_mutable_list:click.protobuf.SensorMessage.Object.forceSensors)
  return &_impl_.forcesensors_;
}
inline const ::click::protobuf::SensorMessage_Vec3& SensorMessage_Object::_internal_forcesensors(int index) const {
  return _impl_.forcesensors_.Get(index);
}
inline const ::click::protobuf::SensorMessage_Vec3& SensorMessage_Object::forcesensors(int index) const {
  // @@protoc_insertion_point(field_get:click.protobuf.SensorMessage.Object.forceSensors)
  return _internal_forcesensors(index);
}
inline ::click::protobuf::SensorMessage_Vec3* SensorMessage_Object::_internal_add_forcesensors() {
  return _impl_.forcesensors_.Add();
}
inline ::click::protobuf::SensorMessage_Vec3* SensorMessage_Object::add_forcesensors() {
  ::click::protobuf::SensorMessage_Vec3* _add = _internal_add_forcesensors();
  // @@protoc_insertion_point(field_add:click.protobuf.SensorMessage.Object.forceSensors)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::click::protobuf::SensorMessage_Vec3 >&
SensorMessage_Object::forcesensors() const {
  // @@protoc_insertion_point(field_list:click.protobuf.SensorMessage.Object.forceSensors)
  return _impl_.forcesensors_;
}

// repeated .click.protobuf.SensorMessage.Sensor objectSensors = 4;
inline int SensorMessage_Object::_internal_objectsensors_size() const {
  return _impl_.objectsensors_.size();
}
inline int SensorMessage_Object::objectsensors_size() const {
  return _internal_objectsensors_size();
}
inline void SensorMessage_Object::clear_objectsensors() {
  _impl_.objectsensors_.Clear();
}
inline ::click::protobuf::SensorMessage_Sensor* SensorMessage_Object::mutable_objectsensors(int index) {
  // @@protoc_insertion_point(field_mutable:click.protobuf.SensorMessage.Object.objectSensors)
  return _impl_.objectsensors_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::click::protobuf::SensorMessage_Sensor >*
SensorMessage_Object::mutable_objectsensors() {
  // @@protoc_insertion_point(field_mutable_list:click.protobuf.SensorMessage.Object.objectSensors)
  return &_impl_.objectsensors_;
}
inline const ::click::protobuf::SensorMessage_Sensor& SensorMessage_Object::_internal_objectsensors(int index) const {
  return _impl_.objectsensors_.Get(index);
}
inline const ::click::protobuf::SensorMessage_Sensor& SensorMessage_Object::objectsensors(int index) const {
  // @@protoc_insertion_point(field_get:click.protobuf.SensorMessage.Object.objectSensors)
  return _internal_objectsensors(index);
}
inline ::click::protobuf::SensorMessage_Sensor* SensorMessage_Object::_internal_add_objectsensors() {
  return _impl_.objectsensors_.Add();
}
inline ::click::protobuf::SensorMessage_Sensor* SensorMessage_Object::add_objectsensors() {
  ::click::protobuf::SensorMessage_Sensor* _add = _internal_add_objectsensors();
  // @@protoc_insertion_point(field_add:click.protobuf.SensorMessage.Object.objectSensors)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::click::protobuf::SensorMessage_Sensor >&
SensorMessage_Object::objectsensors() const {
  // @@protoc_insertion_point(field_list:click.protobuf.SensorMessage.Object.objectSensors)
  return _impl_.objectsensors_;
}

// map<string, .click.protobuf.SensorMessage.Sensors> sensors = 6;
inline int SensorMessage_Object::_internal_sensors_size() const {
  return _impl_.sensors_.size();
}
inline int SensorMessage_Object::sensors_size() const {
  return _internal_sensors_size();
}
inline void SensorMessage_Object::clear_sensors() {
  _impl_.sensors_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::click::protobuf::SensorMessage_Sensors >&
SensorMessage_Object::_internal_sensors() const {
  return _impl_.sensors_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::click::protobuf::SensorMessage_Sensors >&
SensorMessage_Object::sensors() const {
  // @@protoc_insertion_point(field_map:click.protobuf.SensorMessage.Object.sensors)
  return _internal_sensors();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::click::protobuf::SensorMessage_Sensors >*
SensorMessage_Object::_internal_mutable_sensors() {
  return _impl_.sensors_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::click::protobuf::SensorMessage_Sensors >*
SensorMessage_Object::mutable_sensors() {
  // @@protoc_insertion_point(field_mutable_map:click.protobuf.SensorMessage.Object.sensors)
  return _internal_mutable_sensors();
}

// -------------------------------------------------------------------

// SensorMessage_SimulationVariables

// double simulatedTime = 1;
inline void SensorMessage_SimulationVariables::clear_simulatedtime() {
  _impl_.simulatedtime_ = 0;
}
inline double SensorMessage_SimulationVariables::_internal_simulatedtime() const {
  return _impl_.simulatedtime_;
}
inline double SensorMessage_SimulationVariables::simulatedtime() const {
  // @@protoc_insertion_point(field_get:click.protobuf.SensorMessage.SimulationVariables.simulatedTime)
  return _internal_simulatedtime();
}
inline void SensorMessage_SimulationVariables::_internal_set_simulatedtime(double value) {
  
  _impl_.simulatedtime_ = value;
}
inline void SensorMessage_SimulationVariables::set_simulatedtime(double value) {
  _internal_set_simulatedtime(value);
  // @@protoc_insertion_point(field_set:click.protobuf.SensorMessage.SimulationVariables.simulatedTime)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// SensorMessage

// .click.protobuf.MessageType messageType = 1;
inline void SensorMessage::clear_messagetype() {
  _impl_.messagetype_ = 0;
}
inline ::click::protobuf::MessageType SensorMessage::_internal_messagetype() const {
  return static_cast< ::click::protobuf::MessageType >(_impl_.messagetype_);
}
inline ::click::protobuf::MessageType SensorMessage::messagetype() const {
  // @@protoc_insertion_point(field_get:click.protobuf.SensorMessage.messageType)
  return _internal_messagetype();
}
inline void SensorMessage::_internal_set_messagetype(::click::protobuf::MessageType value) {
  
  _impl_.messagetype_ = value;
}
inline void SensorMessage::set_messagetype(::click::protobuf::MessageType value) {
  _internal_set_messagetype(value);
  // @@protoc_insertion_point(field_set:click.protobuf.SensorMessage.messageType)
}

// map<string, .click.protobuf.SensorMessage.Object> objects = 3;
inline int SensorMessage::_internal_objects_size() const {
  return _impl_.objects_.size();
}
inline int SensorMessage::objects_size() const {
  return _internal_objects_size();
}
inline void SensorMessage::clear_objects() {
  _impl_.objects_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::click::protobuf::SensorMessage_Object >&
SensorMessage::_internal_objects() const {
  return _impl_.objects_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::click::protobuf::SensorMessage_Object >&
SensorMessage::objects() const {
  // @@protoc_insertion_point(field_map:click.protobuf.SensorMessage.objects)
  return _internal_objects();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::click::protobuf::SensorMessage_Object >*
SensorMessage::_internal_mutable_objects() {
  return _impl_.objects_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::click::protobuf::SensorMessage_Object >*
SensorMessage::mutable_objects() {
  // @@protoc_insertion_point(field_mutable_map:click.protobuf.SensorMessage.objects)
  return _internal_mutable_objects();
}

// .click.protobuf.SensorMessage.SimulationVariables simVars = 4;
inline bool SensorMessage::_internal_has_simvars() const {
  return this != internal_default_instance() && _impl_.simvars_ != nullptr;
}
inline bool SensorMessage::has_simvars() const {
  return _internal_has_simvars();
}
inline void SensorMessage::clear_simvars() {
  if (GetArenaForAllocation() == nullptr && _impl_.simvars_ != nullptr) {
    delete _impl_.simvars_;
  }
  _impl_.simvars_ = nullptr;
}
inline const ::click::protobuf::SensorMessage_SimulationVariables& SensorMessage::_internal_simvars() const {
  const ::click::protobuf::SensorMessage_SimulationVariables* p = _impl_.simvars_;
  return p != nullptr ? *p : reinterpret_cast<const ::click::protobuf::SensorMessage_SimulationVariables&>(
      ::click::protobuf::_SensorMessage_SimulationVariables_default_instance_);
}
inline const ::click::protobuf::SensorMessage_SimulationVariables& SensorMessage::simvars() const {
  // @@protoc_insertion_point(field_get:click.protobuf.SensorMessage.simVars)
  return _internal_simvars();
}
inline void SensorMessage::unsafe_arena_set_allocated_simvars(
    ::click::protobuf::SensorMessage_SimulationVariables* simvars) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.simvars_);
  }
  _impl_.simvars_ = simvars;
  if (simvars) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:click.protobuf.SensorMessage.simVars)
}
inline ::click::protobuf::SensorMessage_SimulationVariables* SensorMessage::release_simvars() {
  
  ::click::protobuf::SensorMessage_SimulationVariables* temp = _impl_.simvars_;
  _impl_.simvars_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::click::protobuf::SensorMessage_SimulationVariables* SensorMessage::unsafe_arena_release_simvars() {
  // @@protoc_insertion_point(field_release:click.protobuf.SensorMessage.simVars)
  
  ::click::protobuf::SensorMessage_SimulationVariables* temp = _impl_.simvars_;
  _impl_.simvars_ = nullptr;
  return temp;
}
inline ::click::protobuf::SensorMessage_SimulationVariables* SensorMessage::_internal_mutable_simvars() {
  
  if (_impl_.simvars_ == nullptr) {
    auto* p = CreateMaybeMessage<::click::protobuf::SensorMessage_SimulationVariables>(GetArenaForAllocation());
    _impl_.simvars_ = p;
  }
  return _impl_.simvars_;
}
inline ::click::protobuf::SensorMessage_SimulationVariables* SensorMessage::mutable_simvars() {
  ::click::protobuf::SensorMessage_SimulationVariables* _msg = _internal_mutable_simvars();
  // @@protoc_insertion_point(field_mutable:click.protobuf.SensorMessage.simVars)
  return _msg;
}
inline void SensorMessage::set_allocated_simvars(::click::protobuf::SensorMessage_SimulationVariables* simvars) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.simvars_;
  }
  if (simvars) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(simvars);
    if (message_arena != submessage_arena) {
      simvars = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, simvars, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.simvars_ = simvars;
  // @@protoc_insertion_point(field_set_allocated:click.protobuf.SensorMessage.simVars)
}

// -------------------------------------------------------------------

// ResetMessage

// .click.protobuf.MessageType messageType = 1;
inline void ResetMessage::clear_messagetype() {
  _impl_.messagetype_ = 0;
}
inline ::click::protobuf::MessageType ResetMessage::_internal_messagetype() const {
  return static_cast< ::click::protobuf::MessageType >(_impl_.messagetype_);
}
inline ::click::protobuf::MessageType ResetMessage::messagetype() const {
  // @@protoc_insertion_point(field_get:click.protobuf.ResetMessage.messageType)
  return _internal_messagetype();
}
inline void ResetMessage::_internal_set_messagetype(::click::protobuf::MessageType value) {
  
  _impl_.messagetype_ = value;
}
inline void ResetMessage::set_messagetype(::click::protobuf::MessageType value) {
  _internal_set_messagetype(value);
  // @@protoc_insertion_point(field_set:click.protobuf.ResetMessage.messageType)
}

// -------------------------------------------------------------------

// ErrorMessage

// .click.protobuf.MessageType messageType = 1;
inline void ErrorMessage::clear_messagetype() {
  _impl_.messagetype_ = 0;
}
inline ::click::protobuf::MessageType ErrorMessage::_internal_messagetype() const {
  return static_cast< ::click::protobuf::MessageType >(_impl_.messagetype_);
}
inline ::click::protobuf::MessageType ErrorMessage::messagetype() const {
  // @@protoc_insertion_point(field_get:click.protobuf.ErrorMessage.messageType)
  return _internal_messagetype();
}
inline void ErrorMessage::_internal_set_messagetype(::click::protobuf::MessageType value) {
  
  _impl_.messagetype_ = value;
}
inline void ErrorMessage::set_messagetype(::click::protobuf::MessageType value) {
  _internal_set_messagetype(value);
  // @@protoc_insertion_point(field_set:click.protobuf.ErrorMessage.messageType)
}

// .click.protobuf.ErrorType error = 2;
inline void ErrorMessage::clear_error() {
  _impl_.error_ = 0;
}
inline ::click::protobuf::ErrorType ErrorMessage::_internal_error() const {
  return static_cast< ::click::protobuf::ErrorType >(_impl_.error_);
}
inline ::click::protobuf::ErrorType ErrorMessage::error() const {
  // @@protoc_insertion_point(field_get:click.protobuf.ErrorMessage.error)
  return _internal_error();
}
inline void ErrorMessage::_internal_set_error(::click::protobuf::ErrorType value) {
  
  _impl_.error_ = value;
}
inline void ErrorMessage::set_error(::click::protobuf::ErrorType value) {
  _internal_set_error(value);
  // @@protoc_insertion_point(field_set:click.protobuf.ErrorMessage.error)
}

// string errormessage = 3;
inline void ErrorMessage::clear_errormessage() {
  _impl_.errormessage_.ClearToEmpty();
}
inline const std::string& ErrorMessage::errormessage() const {
  // @@protoc_insertion_point(field_get:click.protobuf.ErrorMessage.errormessage)
  return _internal_errormessage();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ErrorMessage::set_errormessage(ArgT0&& arg0, ArgT... args) {
 
 _impl_.errormessage_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:click.protobuf.ErrorMessage.errormessage)
}
inline std::string* ErrorMessage::mutable_errormessage() {
  std::string* _s = _internal_mutable_errormessage();
  // @@protoc_insertion_point(field_mutable:click.protobuf.ErrorMessage.errormessage)
  return _s;
}
inline const std::string& ErrorMessage::_internal_errormessage() const {
  return _impl_.errormessage_.Get();
}
inline void ErrorMessage::_internal_set_errormessage(const std::string& value) {
  
  _impl_.errormessage_.Set(value, GetArenaForAllocation());
}
inline std::string* ErrorMessage::_internal_mutable_errormessage() {
  
  return _impl_.errormessage_.Mutable(GetArenaForAllocation());
}
inline std::string* ErrorMessage::release_errormessage() {
  // @@protoc_insertion_point(field_release:click.protobuf.ErrorMessage.errormessage)
  return _impl_.errormessage_.Release();
}
inline void ErrorMessage::set_allocated_errormessage(std::string* errormessage) {
  if (errormessage != nullptr) {
    
  } else {
    
  }
  _impl_.errormessage_.SetAllocated(errormessage, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.errormessage_.IsDefault()) {
    _impl_.errormessage_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:click.protobuf.ErrorMessage.errormessage)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace protobuf
}  // namespace click

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::click::protobuf::MessageType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::click::protobuf::MessageType>() {
  return ::click::protobuf::MessageType_descriptor();
}
template <> struct is_proto_enum< ::click::protobuf::ValueType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::click::protobuf::ValueType>() {
  return ::click::protobuf::ValueType_descriptor();
}
template <> struct is_proto_enum< ::click::protobuf::Version> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::click::protobuf::Version>() {
  return ::click::protobuf::Version_descriptor();
}
template <> struct is_proto_enum< ::click::protobuf::ErrorType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::click::protobuf::ErrorType>() {
  return ::click::protobuf::ErrorType_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_Messaging_2eproto
