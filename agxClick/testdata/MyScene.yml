# This example demonstrates how to add Attachments and Connectors to a model. When this have
# been added, Brick will automatically try to position and align the bodies to make the joint
# equations be satisfied at the start of the simulation.

.format: 4

# Use imports to avoid having two write the whole name of the component
.import:
  MyRobot: [MyRobotPosition]

MyScenePosition:
  .extends: Physics.Component
  wantInternalPositioning: true

  robot1:
    .type: MyRobotPosition
    localTransform:
      position: Math.Vec3(-0.25, 3.45, 0.55)
      rotation: Math.EulerAngles(0, 0, 2.35)

  robot2:
    .type: MyRobotPosition
    localTransform:
      position: Math.Vec3(0, -0.45, 0.45)
      rotation: Math.EulerAngles(0, -0, -0.75)
  
  # box: 
  #   .type: PythonApplicationModels.BoxPile.ExampleBox
  #   localTransform:
  #     position: Math.Vec3(1, 2, 3)
  #     rotation: Math.EulerAngles(2, 1, 1)


MySceneVelocity:
  .extends: Physics.Component
  wantInternalPositioning: true

  robot1:
    .type: MyRobotPosition
    localTransform:
      position: Math.Vec3(-0.25, 3.45, 0.55)
      rotation: Math.EulerAngles(0, 0, 2.35)

    armJoint:
      inputSignalType: Robotics.SignalType.InputVelocitySignal

  robot2:
    .type: MyRobotPosition
    localTransform:
      position: Math.Vec3(0, -0.45, 0.45)
      rotation: Math.EulerAngles(0, -0, -0.75)

    armJoint:
      inputSignalType: Robotics.SignalType.InputVelocitySignal


MySceneForce:
  .extends: MyRobotPosition
  wantInternalPositioning: true

  robot1:
    .type: MyRobotPosition
    localTransform:
      position: Math.Vec3(-0.25, 3.45, 0.55)
      rotation: Math.EulerAngles(0, 0, 2.35)

    armJoint:
      inputSignalType: Robotics.SignalType.InputForceSignal
 

  robot2:
    .type: MyRobotPosition
    localTransform:
      position: Math.Vec3(0, -0.45, 0.45)
      rotation: Math.EulerAngles(0, -0, -0.75)

    armJoint:
      inputSignalType: Robotics.SignalType.InputForceSignal
